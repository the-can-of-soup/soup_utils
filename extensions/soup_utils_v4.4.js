// Name: Soup Utils
// Author: soup
// Description: Math, logic, and variable utilities galore!
// ID: souputils

// Version 4.4 --- 32 blocks
// Part of the Soup Utils pack, which contains
// Soup Utils, Soup Objects, Soup Arrays, and Soup Vectors

// NOTES & CREDITS
//
// - Written by Soup (https://penguinmod.com/profile?user=soup)
// - Made for PenguinMod; should also work in TurboWarp
// - Used some code from SharkPool's "Sty-Lists" and "Variables Expanded" extensions involving use of variables

// ############    ############    ####    ####    ############            ####    ####    ############    ############    ####            ############
// ############    ############    ####    ####    ############            ####    ####    ############    ############    ####            ############
// ####            ####    ####    ####    ####    ####    ####            ####    ####        ####            ####        ####            ####
// ####            ####    ####    ####    ####    ####    ####            ####    ####        ####            ####        ####            ####
// ############    ####    ####    ####    ####    ############            ####    ####        ####            ####        ####            ############
// ############    ####    ####    ####    ####    ############            ####    ####        ####            ####        ####            ############
//         ####    ####    ####    ####    ####    ####                    ####    ####        ####            ####        ####                    ####
//         ####    ####    ####    ####    ####    ####                    ####    ####        ####            ####        ####                    ####
// ############    ############    ############    ####                    ############        ####        ############    ############    ############
// ############    ############    ############    ####                    ############        ####        ############    ############    ############

(function(Scratch) {
  'use strict';

  if (!Scratch.extensions.unsandboxed) {
    throw new Error('Soup Utils must be unsandboxed to run!');
  }

  let prev_extensions = Array.from(vm.extensionManager._loadedExtensions.keys());
  if (prev_extensions.includes('souputils')) {
    return; // extension already loaded
  }

  // ######  ##      ######  ####    ######  ##      ######
  // ##      ##      ##  ##  ##  ##  ##  ##  ##      ##
  // ##      ##      ##  ##  ####    ######  ##      ######
  // ##  ##  ##      ##  ##  ##  ##  ##  ##  ##          ##
  // ######  ######  ######  ####    ##  ##  ######  ######
  // These globals are used across all extensions in the Soup Utils pack, and the entire "GLOBALS" section should be copy-pasted to every extension in the pack.
  // The one exception is that the extension's icon data (the next 2 lines) is specific to only that extension.

  const util_icon = "data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIyMC45MzM0OCIgaGVpZ2h0PSIzMS40MDAyMiIgdmlld0JveD0iMCwwLDIwLjkzMzQ4LDMxLjQwMDIyIj48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMzA1Ljk3NjQzLC0xNjAuNDY5NzEpIj48ZyBmaWxsPSJub25lIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMC41IiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiPjxpbWFnZSB4PSIzOTE3LjI1MDQzIiB5PSIyMDU0LjQwNjc0IiB0cmFuc2Zvcm09InNjYWxlKDAuMDc4MTEsMC4wNzgxMSkiIHdpZHRoPSIyNjgiIGhlaWdodD0iNDAyIiB4bGluazpocmVmPSJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQVF3QUFBR1NDQU1BQUFBaFBnK1NBQUFEQUZCTVZFVkhjRXdHQXdRS0JnWURBd01FQVFNS0FnSUZBZ0ozZDNjREJBTUVCQVVCQUFBSUFnSUFBQUFHQWdJQUFBQUFBQUFEQVFFQUFBQUFBQURiM3Q0QUFBQUFBUUJ5T1Q4RUJBUyt2cjZvcUtodkVCc1FFQkRPenM0ZUhoNWxEeHVLaW9waUVSdTV1YmxVRVJ3OU96dGdFQm1XbHBaMmRuWnFhbXFHaFlWSElpV3pzN04yZG5iYzNOeUxpNG8vRlJwTElTVkxTMHRaRUJsaVlXS1FrSkNQajQrYm01dDdlbnFCRHgyMHRMT2xwYVZyYkd5bXBhYWpvNk9BRVIyNXVibi8vLys0RUNXeUVDUzNFQ1hKRWluSUVpbkNFU2ZHRWlqdDdlMzQrZm4xOWZXOUVTYkVFaWl0RUNQQkVTZnM3T3k3RUNhL0VTZXdFQ1N6RUNUcTZ1cmc0T0NxRHlMOS92Nm5EeUxpNHVMeDhmSHo4L1A2K3ZxMUVTWDgvUHorLy8vbDVlVzZFU2JVMU5TWERSN3Y3Ky9MRXluTHk4dmMzTnptNXVhK0VDYmUzdDdrNU9UbzZPaGNYRnpPenM3UjBkS2dEeUgzOS9jQ0FRSGo0K1BhMnRxZERpQmdZR0NqRHlHd3NMREl5TWlIREJ1U0RSMjl2YjNZMTllYURSK2xEaUdvcUtoOGZIeHRiR3haV0Zpc3JLeDNlSGpBd01DMnRyYVJrWkowZEhSaVkyT2tvNlJtWm1henM3Tk1URXpFeE1TNnVyckRDaU83amk2SWg0aUNnb0pvYVdseGNYR1lsNWR2VnlkblVTZElSMGRnU3lLTWpJMmJtNXhWVkZSMlhDZFJVRkRBa3krTURCeWduNkM4Q0NFVUZCaDdZQ2hWUkNXekNCMUZOaUJDUVVBNU9UaTZBaGVBWkNtZmVpcCtDaGlzQUJNbElTQzBpU3l0Q1IyWWRTcXRoQ3lLYWlqdHo5UEpDU2lUY1NycytQaUZhQ25VYVhmNDV1bnE4dkkzTEJyanI3WDAvLzZtZnlyUFUyS09iaXB0Y0hEWmo1Z3ZMaTIvSFN6QkF4bk1QRTY1YXlzYkFnVzBBQkRKZTRYSEl5MVRQUlB0djhYbDdPMjhNa1BrbmFiSUtUM2NmNHJEU1ZqeTJ0MjhleTNCUVNxM0pEWnpOVGRuVUVxeUd5elBFQ2pneE1qSVlXN0JXeXpKbUM5eFV4YlZvcWlHSkN5NkxpZzJCUXFDWVJ1MlZDbVZIQ3FFTkRSb0N4YTRvVys4cW9PeWxsamk1ZXRTQ0JIWDBNQ2ZoVXpGdDVaOGFGK1hieG01bmk2RFRGTGEzK1ROd3FxZmoyK25jWGVvVUZ1bVBFa1E2KzBMOHNxYUFBQUFQM1JTVGxNQURoc3hGaEVMQVFNSE9DRlBQeVpZUnl0aERHbHhGbnNzcE4rUVhhalFMSlcwaExLL2ozeEs1MXJJNEVPcmJudklxOVR3MTczRDdZTFBxZkZqOXQ4cnVBc0pBQUI2TFVsRVFWUjQydFNZWFd2cTZCYkg5d3V6TytWd3JnUnBZWVBNUmJWN09yM1NsblpYdWk5dGIzcWpiTFNscHdSUjhTVXlLS0tnb1BVdGFlb0xKQm9RSTRLY0c3M3FoNUIrcnJQV2V2TEUyTTV3RHM3ZVoyYitwdEc4Wi8zV2Y2MG42WnMzMzE5YklJZmo3UTlPcDlQaDJuR3RhOGUxczBNekVpM2c5Mm96VGc2SEV3LytzSTJuZXZQMzFkYjJXNmNUb3ZLZzNQNjlrNU05dC92ekllbUk1RHM2T3JWMGhCTmJmM2lFKzdqZDdyMFRQOHpoOFBjZU9KSFQ0ZmdiOGRoeU9OK3g2UDBZeE9mUGJnenErUFB4OGZHK0Q3U1AwalN2QmhxUFlWSXRzWjhTVEdQVk8vWjZ2ZnY3WGpyRzV6dUV3NC9oUEx1N3V5ZW9qeDgvL3ZJTGVNanArSXQ1QmMzN0FaM3NjcjE3RHd3K3VUSCs0NFBqZmE5WGtpQXdUVlBIOUZWcnlzMGFxa21TWlpqV1JLdHJ0STlXZzhNQUVCSWFTNUp1R0RNZE5GT3E3WGI3L1B6ODU1OStRaTUrditmOU85ZU9BOHZvcjFCRTRBVXdnaHNSUVBaSnRRTUlSV3ZLR2tSTUFUZGxNL2ptdWw0dU14YU1HTmVMWlUzVlo3b3ltNTJkRmM4QXlqbVUxZTdlSGhiU08rZjJud2ZoTFVMd2ZNSmFnQ280T0RqUXhocmVMVG9Bb3BTSHkrVnlDRnFTN29jcnlYd3V5MFA1dGV5R01mY2RMdTlCTUJzT213aUU3Q0tSVjJaVkhhc0pTdkdRTlJlWDg4UFcvNjhzdGgwT2RBTmlPRDdZMTlEVG1GRzQ0MVc0R0lkZERNaC8weEQzV1E2WHk5ZUgwc2ZjUUlZeUM0N01BbVVJWkNUSjYvVWRmMll1Y2REdzg3MWhiQU1IcUFtMHdzRkJVNjZ0SlhVVkFlYlNpbjdBUGt5UG9JSDFlN0F1M0lrZnc3OXdZaHROTFRsdm1YMHhKTmhrSk9xNys5QnRBWW5MK1IxaGJIMXdVWGNBUHh4b2NIMXNDRU16bWJZMG1rRU1iTEdiZWlBVkNvVUhMdHZQTlQzK2p1aUVLeXIzTmp3bUVwVzFYUzhBSVkrNHZuMG53U0hqTFRqaTBPZURjUUZLWXNrVGhCWlkrWDh0Zml0Z3Jzei9wQUo4TW9YZkVvUEVXZG5zeEdqSXZIaVlUYUJ5RE4vUm50dURBL0MzOU1pUFRvOS9EMGpzMTJDUVFEdmNyelVBTzRPSE5RWXNPcVo2SGFhWG10Ui9SM1FFVFRaT2pFbmhwWDJZVjZobVZvTXpBWUV1NGpzODhidCsrRllrUGxDVDhNMTB0U2JmRCt3NW9lRHhZdysvWUl2ZURKZzBuVXhKM1RXOVdEVFhUUzFOVEZtQVZsQnNqbm1nbXpMZHloOVpZQTVsSXhsVjNYZm85cnUreGJQcmx0UGpQanJUMWViOW96MGJMd3hnbFVCOW5RQkNXRU13R3NGa0NuOTEyWXhXc3UyalY2d3NLbXRFVnBZak9uUnZacGRkV29NYXpwczFTYStlSHJwZFAvN1JYdkhPdjNlOEQ3VngvMWlnaTc0b2diWDR3Zk04L2xYc1BQRFhVZFZ0ZWJhU2JVWm9WcFRKMGs1bnlnNWZ1N0IxR2pzUmhNS0tlU2lEUS9aOVJ5ZWVQK0lPZElWUEh3OHpjQXQxdXB3dEkvWUsrSzBDNEg2bm0yY2M0VVp0elk1MU80M1BvY2JOQmZPSkhZZk9KVFlrOUNHNzlMb3pURmE4ampoYTNrLzRhSXpIRng2R21uRjI1Ti9aMnJ4dHVrOW50Y3owcFQ5ZlVaaStOQUhCS3p4ZzdPYVlSdzFOTTEvSlNCSVhQQzdCQTVOT0g0bit1R0FmM0pNT1FsWTFRalFrUU1Dblh1Y0o0TXpOdXl5c2lLeHFPbE9RcGJOZHo2YVBWeTczcWJxY2RFZGR4REd4R2orSHdPdGdEbUlRcHBpZkF1YmZHdmZOUjJkNGNEWm1zNW1pS0ZWVWc2bEk2aFE3cVBacWptdGhNKzFhaFdQZ1hXUm1HTHJPUUFFY2RCQTg1TndQSGlBems2blZhNmJUZFNTcnFnWWJUZXVQbXZmUTgyR2pkdkVQOTZrK1dZeTZML282cDJCYVljNHhBSVhCUGI2WElnQ1dlRVJnTUFnTUFjWE9nbDZwRHlxRFdxUWUrNExsZmgrMzJ1QlllR1lHY2hrVGxTWWlLZFFuTnBQWSs4cWFtZWZkWWVmMG41dFV5dGFubjZYdVd1c2pPNWdsTVdjYWpRQkQ0WkdjWUQ0Uzg1ZHVlTjF1RkZuVUhRb0drendqRVNBU3B0MHlDNUhpZVBySW92OFNHREpxRnh0VlBBZTNDbU9DTGI0KzZiTDAyRHhTdDZvYTduNDBVay9kcmcyTTRYUzM1ZWY1YWlpd3hnZU9BZXlRUVE3Y0RkZ0xPSVNWMFUyWHJ3bldLT1FXRTBTMWdSOWVPc3hBNWsvTERsVzJzY05SQWFFaTU0dEdHWE1pR1NpYkVTL2JpYTI1d2ZKb2tmRWUrVGN3eHM3dTJZTUpZL1ZZd0IzUm5ZSWZsckpKZ1pVRnRnV2wwZWkwKytod1RKK0JtV085a25vR3hVNGhzZmJBazg2dHdHSmt0Y0ZJc0tiQmZZRC80NW1oMzlwVVZPaVNqbVU1ZzJwSHhTZkRod3hhWkQ1YVdkb3lkRmM3LzdqQnZ5OTNkdnVEcDhYSTdJNE14QUkwSDAweUQvZERQa1NZL2RFd2xFYTcxU3UxK3NXcXdRWUJxaFVPWUtXaUtkNDUwUDl3WUN3bWltSTJLMlN6V2ZnaHhrbzlGTFVQQ0xsUlZWWUJTM1R1V2JYZEtzR092UllSZ1QxbVJKKzFrdUVnTThVYm5sUEptQ2k2OCtmSmJBTVliN1k4dTduWi9Ia0JMSmdaRUFTMDAzcGhBQ0RNY2RMOGo1elM2UFJiY092bGR0RzBBN01KTlkwT3Ivcnlxa3RhZlJJZ0FBRVNJaENGU2o2WlNnZWkwY0JWT3BudGxiRlZ0QmlXY3IvVG9aRE43amxHSHAxeUw0YmtrQmdpdzgxc096cWtNT2tpRDU3TitlSjVvV1kzZ2ZIR2MzZ1RyeEVOaHVMNWVUR3FQOHJzTFZtbC94N29CdldIZHI4bFZ2SkNySy9va0JYSlVJcHRDSnJTaW1OQ24rVytCMm5NQ2tLbGtrZFZRTEFRRHllQ1Y4RkVLbGtSSUNTUW1NMm5BaGRmUUYrRFloRUNOekRpVXJhU3IyU1pXMHlyS0xvRU56SFdHeTBSemlhSUplUUZ3SXBWaFNvS0pXbHlZWXBabkxPVUx1YUQwc1c1ZnlNWWQ1YzlhZklNRUFERTgvTjg4cmhrLzNFakZKTEJxcmRkN2dueFpGNXN0Ykh6ZFZnaVM3MlNJSWc5TkVJcEp1UkRpV0QwK3ZMaTV2YjI5dXZYMjV1Ym13c1F6bTVnR2VLK3ZiaU9CaE4zNFNSRUJaV1N2NHRlM3R6OG11enIrRURSMU1helRrc0kzU1h1UXBXc0dJc0JOR0pDZlFsS3NOTXF3UjNFY1Z1SnJRWWUyRjNBSXdCc21Pa3V6Qmk2YWprZDNoQkc3dGV3YUR6Q3FaNFF4YUNHVlRIR0hxV08wYUdVL3BJSW9jSmR4bHFRL3g3WVhNakdldjFPbzlQckY5dTliRDZYamtZaWtXZ2dtRTZFNHhpcnlHTHBnUXRpMkNTeVdCbmhSRHFkRGdhRE1FOG5VcWxFTUJDTkJPSXRSVkxoT1VMV2pIWXBud2hFcmlQQmNGNHdxMHBBYThHMXdDWnczVW95bHd2RmNRM3JJc0NEaG0zNDBsVzVQa2NjM1lGVVNnUXFtOEs0RXdXaExOVUJ4dlJlbzVFVEJ3WlYxUlhtQUFpbmNoY05oQVVvOW5nNEY0YnNZQWR0ektCbktKTFVFS0szLy9yeU5aSVRldjNHVEI5citJQUU3d25XUzhUallJbXYyV05Ed1o1VEVvVjhMb29sY25NZERRU3VVbUMzRGxTRHBKU0ZaRG9BalNRU3ZVb0JVYWd2RWxZY1dDS1Bub0RxQ3FaelNhd1lCRklxZDdCdFY2bXJHbU41c2xoTXBGWWxuMDF1QkdQTHRSdE9RbmNUVzRyYWJHb3FIeUFsRlZ4Ylp0MC9LK1Fpa1VROEh3K2xVcmtRdXkxWVd5bFZkYjFSYk9VdnYxeUdla1Y4L1MvVXU5aS9ucCtlbnY2OXBpZHczV0xlcmJPdXJJNk5ha3NJM2tESHVMaThqa0R0SlBHVWFJc0lBRXJmaGVMUWIrSjVybmd5aEVyaW1tUXFlSlZPc1lVS05KaDJGYm8zSDV2MXNhUzBSTUFVMzh3WkNFT0VHaFFoMiswR2RDVWNOaFJkVlpWZUxDdVNUekViZVZGSUJxT0JSQ2pQc3BVUHBhL1RZcmtsM0YxK2ljWWE2bUM2ZUkzZ2xaQUphVEd2TjZWKzVlcm02eGZzSnRSSkw5S2hkT0FxbUlwam00d0p5WEE0SEdJUWtnUWpCVVdHUlpoUDNzR1B1MVFPTjRlelFBUEhvRFlNNHpBSXd6MzNXajB4dEJHTWJZQVJFdG1ZMVMremN4YmJEYldtbHl2LzRkVk1mdHJLc2pnY3BWdEtTWkY2MDFJVzZVVkgzVktwZTlHTExHcmJHR05zUm84TVpoSmc0d0Zzd05nWU1EWUd4eFBHS1J3WmpCVGhDRUVpb2JDb2l0amtIN0N5cnpVa08yL3NOUkl0WmRIbm5IdmZpSjFVREtuek1DRmdlTzk5NzNlR2U4OWhKT0N4ak5nTHliUjkxT21acFF6QkgxWXdHUFNNZEEwTmphMkdYNUlhcEhzbUdiQjFESzJ2b1lRK1lwTEJIeTh0TGVGN3pvNUtPNkd1dGlFTXQwUmtkamNHc1JWdUJ0Sm5kSDdBNS9GTVRrN2lDMjF1YnRMamdadzBHZHJkblo0elF1U3hlVER1K0JiS0o2Q0ZOWXdxcktCSlF4cTJoMXB5ay9zL2hueVF3QXNadms3Q3dKMTVYandzdUcxejdORUVQZDN6eGV5dW9kc3o0SGE3WjVtQmtOMmVicnFIaWV5N0pUSjJsd0lMZnlKVnpKNWdhUUxWQnFZRVVERkd5a29ld0lDTTROMXZQbXhOQzhKb0M0VEt4UXk5RTRxWXpXak1nNUhXSnBxUHpHYndoVmJMQlRmRWF1Y0laYTQyWi9Ja21zNXNZdlZLSlE4RTJyVjVZK2luRmxieFAvejEzLzhOVHJ0WXBtS0ZUalpiTGhlejBRWDNiQkNmaHM5bURMajJEbmVkenRrQk8xb1FEYlJyZC9JYlNiN2tOSWdIZDRlenQ2L0NwVDJpd2RJd2hCL01sL0RjSWZKaUpud0xRUHhyWXhnM1JneWUwUFBpcTJmbFZWWk5sVFBUdmhGbVRxak1CRE1halFaUGJPY3dPam5XRmVnR0c0SDBGZHVFSzk1TFVZaUc3SmZNRk1DL2picy8zbTlsMWZxbi83aCttMDhYbnJPcUwzdklObGUyRHN2SnFDdG14OHFodXkyWVBGajFPTzFCTGxsSXNxRUIyMGdYNmhzVTdrd1hqejY4V1pMYm15Vkc1SXl0SEdpcHQ1MmlqWDIyOU1EcUhaQ251eUVOemE1bFRySXBTSXpQc2p1NEZDdVdDekZEOThSRTE5Z1FsQ1lDRXFMaTdQYTVkbmJzRkdNQ052ZDhadk5nYnh2Vzl1Q1BVQ2NlUWlXSVVsejQzK3hQTFMzaDcvM2x5YjkyNTExUktQYUlSUkYzUXRIUFMxdTQ1WnhKdTJLek5wczduZmFBTkkwa1YyQXhHelFFeHREYlNScGpuclhrRHRTQitXYy92K1hSUTAwRzJRZ1paUytiM0kxNWpFYTNDOHEyQWpEWjNuK0dPamtMYjIwQnNlem1ydHZRUGVLWjlYbWdmQWtFdWdOUXRvMk4wYW1HSmlaM0MydHp2dEFDcFBFeW5ITGYvd3BYN3JDZUxERVlVTWk2RnRZTy92bW9wWjJ1aDM5Ny9Ea1pMYUNYQ0V0a1ZpZUE1Uk1wVkhwaEhpSjhhTkpJQm9ITDdwNGJoVFJBc3FCU0V5OTB6R2xmaU9JRmx2YkQvaU5hNVBEVUFRWE1PMllVUzBxSE85R0ZXYnQ3T3YzOFpDK0IvUENOOE1PMy9sd3VzWFZRbUxZNW5YT3h3dXJhYmlZYUd3MEVFQVVhdXRQQUd1U016R2EyaUJpTzJNNGpicjF5WllDZndNOVhQOWVmUG14cE4vamhrOGZWNjg4blNRcHdXV0ZYaWJXMElCVlVTc3daazFCb3h1dytLQkM3blI1RGx4VDNiTUVRTFNmU3RPcWtySjlaVzNBVlpNdXRMRi9jN3F4R1hlaGZ6cUFyQTNySSsybUZSU2hJTzJjL2x3NHlrQ29NbnFBcmVYQ3dDblZNMUJhQThyNXIxRERwUmpGQXpnY25ydXhqU1NkMXB3aEdLWVdMaDUxazhxUjRYWXM4YlZFWlR4Ny84a3YxZWd0M2JDUmxZTE00TCt2czhUUGhjaHBTNjRBTnFtL25hR0JzZEc0aHVncnhNRlhhSjNyd1pJdUhlNGViSVlRMUJNOXlGSDNMaDJFWUZ5S2dwQzZEZmI1UTNzcGgrZi91RFI2VWJlRjRkK1l2Wm1LR29iYUpVYU52K3ZuSlNYS3puTjBCVDBwSHNRQ0M5VWVLT2hsc3ExemE3c012Y29JeXNvZWZyK3ZIeDVIV2xSR0pJSTZySWh2QkVXQ3dmbDVGR0R6QVFRRTg0UUdzVmpGQllHRVVteTlRck1CSHpMMkN2T05zTHpiV2RzT0dSaWVuMDV2WkxmOUxldXM3c1VqRG1QTGg3VkhpWkpxdDZqMXp3ZGhhSnJtS2E5WXNiZU9FMmY2MDFJNFFXanA4VzVpN3lXSHg2cnA2dk81d0hMY0c0eDdCaUJ4SEl0WDY5UlhXNDN1OHZaaW4va2RGTldnaTdJSHlMZ0N0YmJkb2FDVWhOQ1h6L25BeFBRQkZBbGJYM2VqekUwTmRSbnZNVmRoRWxVTk1JWUhUbGk3ZmlnOG50a0Y2SjZ0ODQ1TUZjdHdZeHpXTzJMY1Q3anpNOXNLeHMvT01qbkJ1djVMYVNsMWQxMnMxeHdiWXJXQWNyNit2ZzdnQXg5VTJUZVB3cVFwWm81ZEdqOWhkQzgwcy9KZlRZZnVDZTh6Z08xbE1ua2x4NnhlRVRrdTRTb0p0cHRJZkttMUx2V01HbGhvRHVBM3U1N2l3ZDZ2WUFoZTZyamxGdng5Q2ZmN3FHbEE0bG4rTnJ5emZIb2JEc2VGd3JCK2pQbGpEbmZzSk5jYWt0amNmWE9OREpCWE9oSGR3aENFQ3pFWml1MnMvb1JvL1VVenJKR2hrcDZUcTlyUG1XcVBwQm5tYnhDLzJLQzh2NnRYYWNqdytQTHl5dUhoYkdCR0FzYkd4REgvRzRhaFY2eGNYbDZnOUVGK2xzaTJOckJHT2xOZ1hUQWs4aE5hZ09KYVN4NjZQMk1yd1MrcFdqNlRnM0UrSnpUVXBhT1J6Nms2L1grcTFzazRybkJGYmowZVhseGNYMVZwdE1SNC9QejhmWkRBY2Q2Q001Y1dWZVB6WE9Qd3hCdVNTT2tZVnNXWEtQd3VITU13SFJCaVEvSTNaSEpxemtLWll3b3JIeTJPU09LM0VwdDVZOE1rcG12N2lDQWNmVE1CVFlmZU1RRlEzRnMvUFQwOVBMWmErd1R1QkVXRXdpQVpvYlhBNHZyaXhYcXRXa1FnR3B4UnZGaXVHRnduSXR0Z1l2UUVqckVDaEdyWEljUjhzU1lOLzlBOFB4TG13bkFUckVoRUtjandRSHVPd3Zyd3kyR2RwdDFyYkxjVGlMcFVCTUZhR2dVWGZPUnFHSWdCU3IxOWZRMkJOS0NhSTVPRkQwQWFESVNZK2tVUk9qU1RIVlNGSklyWE5aMG01eUZUQ0lFMXh0N2xFRFBVcWVjWWdDT0wxYTQxR080NDBCQmdiQ09QUlhTaGpCWVV4T05qWFo3RllyWEF1WUFKSWFuSWtEY1plV1k3aE5QQkRJSkJyTnJYRlF6TUhJWTRSVmlvSklYeEt1dUNIaU1HeEhEOUhDaWFUYVdwS013Nm1VQWJBV0g5Ni8wNlVJY0FBR3NpakhRek8wd2RucVJFVGdISjVGZVlkZU9ZeDZDMllFeFNlMHRSSEtBSlMwcGJQVHpNaTlGZjI4YmQ1OElYRVNneVlGbXFMS3lCYmkzVmNxOVVBQnpCVWhSckdjc3N3SGp6OFIyTmxFSTMyZHV2NHVHWnF5cVRSa2tvRzQ4U2tWaWNvcUpYTHEveVZPQjZodW1jK29oYVdYc0wzd084ckttTUpHaFVCOGVBSUNSQURnSUFVRU1JcE9jWHIxMTZ2dDZlbmg3SFFhaFV3TUxVdTMwWVpCQU9sSVljaFNNT0NOTWkwYUJxQ2Nub09YQ0RHTGlNWERDcjErc1UxWFBzbDJxdkxWOUtRQjg4Q1RPYmlVQjlUaDVCbktUNWMrdW1YTHk1a0FCd1FGTTRaZ0JjdnZQMW1yeGtnTUVFSWRzY3dtREtPRlRDR0ZUQ3NBZzVHQkhob05IZ1JQR3FSRDZFNmE5eXFaSFZNemwrMitrV2RXNjBxL0hKdEVlTTNKb2h4OEFTVEY2Mi92eDllWnJQWiswVVljTVczanhrM2xkRWNCaG00elpUSjFFTVg2bjJOQi91RWRrcDJqdGMxU0E4S0xnNU51bGs0aG1zZkZ6L0NhVDR5VjdSaURJRDdmc0ZOL3g1Ti8xNlAxdHZiMjluWmlTaFFGejJtN3dyajI1VEI5YUhSc0d1QmNON0R6SXRYMndsWHJ0ZmhMZWowN3p2QWREcmQrL2M2SFh4RmR3Zlc4WDRHckFQZTFESFRNVU5mQzZiajl3NTN6MS9FQVVpUUxKckFZRmNrd0NENmQ2a01xTHErRG9QaE1Ka1lEaSt5Nk84bkdNUUM3bTNtRXg3czA1ZHNSa1FpMFpERDZPOFhZSmliS3NONlJ6QnVLaU0rL00wd21ESVlqVjZTaDQ3MGdNWUYwTnc2dUlZVUxBUWtmeXlNRzhwWWlYK1RtM0FZNXBzd09BNFJ4aWYrRXY4ajl4SUdvN2UzT1F5V1VKVXdNSkNQTjRJUnVTTmxLR0ZnemZWN2xLR0NvUmUxSWRjQXgvRkpRb0V3Q01qdlVVWkRHT015R0xldk14NTlVUmxxR1BRa3Z1NG1qV0dvd2R3ZERJc0tSdVRwbjF1YUErVXd4SUpja1ZDNHJ4QVVLeFRuVnRGcHNOQ1lrdHhGRklkSWhFVlNuZVF3a2hqd0F3RVFBcDBlUC9UaXpiTzdsd0lGOHhCdmp4ZEtETk1VbFRqa0hWcmgrZkFsSzZHSUl3dEhxekR1UGZnN3dZaDhCUVlXNWxZMURJMENobGVDb2Vjd2V1VXdDQWNnWUhyUUNaR0NVT2kvRG9QVld5SU03WGVCUWNvNGpueGRHYUkyYnNEUWlEQjZ6Q3Bsd0dQdmtHY1cvcHFSd2laM0VNRXZrS1lBZytQd1VoNFJZR2dGRTFqZ1F2S09ZUENZMFJDR1JZU0JpMWRLTFBEU05sU0dtZFZkeXNDaFZ5dWpNUXk5RW9aYUdiUW0rU05nUFBpaU1pd3FaVFJ6azZrcG9RZzFONDhaL1A0RmhjaUVvVlBETUJPS1RyTmFHU1lWREswQW8vMzd4QXhJS0lzeU41RkNCbE1Hd1JBY1JZSWhCRkM0QTFFWnZZMWdLT3J2aGpBSVI2Y3NZdkFLUXhZemtJUkNHZTE4WVlKVnhtMWcvTkJJR1NzU2pEN0Uza0FaTWhnbU9ZeitKakJFVDVHcnBKa3lSQ2ZwYkFaREZqK1ptMWl3NHJvdGpIdjNtOFlNUm9PZHFsM0NvVWl0R2trWi8yZm1XbUxhU05Md2FKVTk3WDJQMFY3M2tqbk9hVlFHSElMQkROZ1p3d1pzajJPWXpZenlnSm9RWm5BQ3lTUTdtVmNlMGlRVENjMml5SkVQRXc0V0oxL2NXa3VXR3N0cUJiVzYvWkE4SURoazFkS3FMejVFMmdQUjdsK3ZkdHZ1TnNqWTJjMGxtSWE0NnF2di8vN3ZxeXBudENNWUZqTzg4NWFZZWpzSjZLVHRENFhDWFRNRzJzb2swV1daL09GOXdZeUVBSU51Q2s4M0xIa3pNeWdjZzN5dkp4WnJRVU9BTWV3TWhxVVhMY3hvdUN5M3h0b21vQnlOd0FEcnJBRjdtWHpZcFFOdE1DTmhZMGJJdnR2bEFFYVkxaTFsaHFkSk5JNWdCczBxUWtxOUhickpwSnRtT0hlVEZzMzRzRXRtL001eW9BbW5NckhERVd6MVhjMWx3b1A4bURNWWRrQ0dXbTNHbUFCalVqUVRnZ1pEWkhTeUZZeHdrMllFZWdlR0N6TWN3V2hycmtkcWhnV0hBeHJ6RFRmT2lURnNLeE03TTBhZFRGZTRJelArOU1jVE11TjQyYVNtYVh0ZFpST2VUbWltdDlkSlA3SkpsMkIwNkNhdDJZVHlvcUxydVlyTmRCVXJSYTB0bTR6OXI3UEppWmh4N0d5U3pTQTBVeG5nN2FTUVZUTVpWVC9RUmp0a2s2UHR1TmZGam5lZlRmckFqUFpzVXBFUVFxL05lcEtDb2FtUmlLUy9rdmZWQ3BUMTVQOVJOam1aWmh5UEdVRVZzSWcreEhnRndJaHB3QkowK0t0aDdGNlhpdThvbXhTT2wwMjZac2I3cDQrZFRiUUlUUDlDQ2h0UUorR0NEaSt1S1JnREdwSDl0WjVtazNHbmJGTEw1dFJzNlZqWnBHdG1OSVBSbWswQzlteFNJWmYyTG1Kc2tsSGtTY244aEhFOUVZdFYwWHFvejlsa3NxQkxzQmJ5Mm5HeXljbVlrVHdxbTlBL0ZJeXJHQzhSQWMyUkY5OWpaUmxLV1VWM0RFY0hPdHllVFk0RXd5V2JsQmZKRzg2WWlXTmtrNU16NCtoc29wSGhuTU1Ld2FJd1ExN2N3SFhBb3BCQlArQjRUN0xKdUVDanBiSEdTaEs3VGZyU09FNDJPYkZtSENPYlNHdzRSTHVLaUlGaGd2R0NyMy9CWm4relNaYmZyTjNHOFdOa2s5NHh3ejJieUdROGp4Vml5QS9vMko3aE5CQkRSMU83dU43WGJQS1p6TUM0QksxczhPaHMwbE5tdUdTVFBVcU5qVlVZUkptTzdRSUJBM0NwZ3BDZU9KdU1kY29tbkJsM01HZEd1SC9NNkpoTkJ2YXN2WEU2cEM5K3M4QkE2L1hZUVJYTnZvRUY2MjgyS1JGWGd5Nm5zQkxvWXpaeGFLM05ZR2lWdkp6TDZlVzh0aGZjbzJ5ZE9nZ1A1c0Yrd1plM2Z5MERGcTh4Vm9KOXppWUUvZG5uR0tmN2wwMk9CdU5BcjhJb1psRlV5c2hhc0NaZmdrSDU5RXFGTVdQdXBnOUZjLzhBNzlHYVRheldPdFNUYkZJZ3Jmd0tXRHgvUDdQSm1kTWRzNG1lc1gxS1lrYXY3UjFlOUFFYUdXb3pvdlR6Ti9jM1lZemh2cDZiRklwbEg1S0FGMHF5cjlua1RDZG03T1Y4VFo4WjhhbmE2dTY5RWZ1M0h2K1VnakV1SEN1YmVMdk1KcE5aU0VYcUxyd1BheVcxNGtHNW5PMUROam5USVp2c3lSRXg1K3NQSGx5Y2c3OXoycHFSK3ZuK3JiOWU0QThndDJFbE1XSFBKc085emliNm9wUjU5cEs4RCtoRkxhdEwwTlVrS2FPNVpaTVB1bWRHMGpXYmNHRVlXYnkzc2I2ZFN1SHRIKy9OeWROaDA5aDZlZmNKQitNNVZvenBmcCtiNks5MlNTUmM5bmkwckNyTlJtN2Qvd3FoeU91NDN5bWJ4THNGbzRObWhQeDdUQzltYm03U3oyVENjUERXMDI5TmYzZzZYVmVVUlFiR0E3QWE3WHVndzY3bkp0MWxFMU5SakxRLzV0RmtZblhlMUZQcmo0ajlTenRsazNqaWd4TnJSbnMyWWNTWWUwRStwcXJVNittbFJOS3NHemdOaVdBaGJiN20vU1NWN09tNVNTbWZCVDBvdG03Nm1lblZJSmpkSEs5TXBmN1c5OFVtNkhaek5sbm9GVFBhczRsT1ovc3RnY0pjV1FNN0hnajZsOUtHd2ZaQWVRMmhwM1g3dVVsaFp5ZXJxeGxWemNuWllzZHNzbE1xRm92NUV1c21jazR1RWpBS2VWVkNVVjgxVTNZOE45RzVKVmRXUW51Vk90aGVKd2ZhVTJaWVpVS3I1RXZTTEpKcmpZT0M0QUkvSytCMWNoTUhHdWNtcGJ3dW9RaVZYVjgxVnk0MnVmRjVxSGVFOGd5VUVtdmFlUXBHYVJGSkdVQmp2SXordytLcGxHcy9OL0hrNmFOSEdDZElJNGtyUnR3cG0vU2FHUXdNTXF3b2lMaXg1SGM2TjFHcEcwWG5VbWxSSlRzRUNtaUNoNzlkdVVuSHJlWnRhQlRwTDZoZWVrKzB5T1o4T2JuaUJ6Q291ZDlmSGN0TlNlWERSL1JKNUkybjdkd2t4eG9iVnFqTkdIREpKdDB6NDlRWjkyeEN4bnVmOE1MNVRoZlBUbWpENEZXeUE5WWMwSGxGbEhiN1BIMVdMVnAzdXZqMG9lQlhMU3pJVmxrYzBLRXdvU3V2VUZVejhUcXpjNWVNY091NUNXOXVkdzE3Tmhsb3RlUGRNNE9Ba1hZeFhXVEFYNFBUZHJuVHBYRVQ4a3dKMHFPQ2tqd1RwZTBGdUdRbWVlYmUzK05nOE9sL0F3OUJOWExNdlk1c1l3Vk1lNGxadS9zUlZES3drZVpiRjF0bXk3bUpVS2xiU3FoVE5qa2hNMXpPVFdDZEVZeDIyZTFPVjVXTjdWTzhRc0hRNlpUT2djYlVRNTVodHZ1RG9tOUNGSXdkdHZqb0JsQmhmcjdFcDNVTm9BYlJLRE52djRnTzY5Z0lqUE9ITjVSWTgrNjRMajQ3ZmR2c1pNZjd3b3dBS1ZHWW1ldWRMajYvODdoTzduU3hUVXIwTXl6OUlEU0dIVjRJMTR4UkFnYUwvTkdQNFNtNERVNGI5QXZHYXlDZ1BQOUVieHRZOFk4WEJCaDR5WFp1TWpFUnExb1o0TTYvK2dFRzF3eG5adWdVakJYWE8xMWlwYkFCZytWbGNCNklzVXo5cDBoNFcya0FRMER6QkRJNE5GZitpbFFKVkpFZ0VkcUNkeHMvSzE1ZXdXazdNMkxGaUlYRzVkMjQrN25KeVpqaGxrMnlGSXkxOWp0ZGcreEdnbGhmck1CWVZXdXRUZWE3K0RmUXVqSkdpRUUxQXFXd0FqVEo4K2xlcEZYaTVSdEZ4TkhVd1grS2w1c2NETkZhWlZSNUlORDRwajdObVZGcnl5YTlaWWJJSmhvZHZmdWRMZ3NNUFByWkFmdC9FWHpiR0ljb0ZsN1ZZbnRvYUo1VEFlVFRoTWJTVkNWZUwrZlFKNkM4SVhEaTRoZFRMV0JVcFdUSzRzYUd5YkFvNXdiOHJkbmtSQUxhcWhuVzU5UWtzanlOYzVQV08xMDJNRWI1aEs3QzRuSnIzUUFqSWFoQWRtY0N3QXdPeld4VGxSQmltSUFGcnlnaUwvSEd1UW5VNGF4czRBUCtxMU12bERVeURrM0tEU1I2VlNZMlpqaWNtOGhFRDlmYzduUjVjbnpMQitPSmltaXpNQU9lVGNRaWJvQks4SitjSXZKcFZRbnZKVU1DVTRDRzdQb0ord0x5NHJmZDZZcVZvNXFpV0d5OFNzLzFnbVZVTVpTV2M1T3VtZkhlcVE3WnhLOU5RZDlNdU43cFVwbnNmUXBnQ0MzOUdpc2lkQzFhYzB6djhDOWZNUG5rMEtEdlFHdTkzcDJxOVpBb1JrRXdhZ3NyVGRsRXlpU3c2ZEZtZUQ3RUpDSnBWVFZCMmwyUE5PUDNaem9kRlZUUnlKYlplcWRMaUVhaDRTSkhxMXdndDBXVkRBc3JjUTQ2QktmQzFDYkdRMDFWWXRpcUJCNU9UMEl2aVRLSXZ3TGFUQmF6VmpZcG9ISWRyM25ZQ3FEb0hEbllDK3UrQXdNdjljcU91ekJEZ0hFQWxXeTQzZWtTYkYrSGJvSXMwVE01TWZJTUhmUWx4Z3VjMjUvRDJ0dXFoUGFTWWE5c3ZhcVBRNW5vSEl6blVDVUZ0V3BsazRKY3c0YkhNNmhiSlJZTzUxRXVpWTNlQmJWTzJRUXFVVVdYdDVlZFAyOFM1c082QUxNUU5KamhrakUyTmlSek1MNEhObVNzUW9nM1Y4bUMxeXNPVVgrRW1qbDc5cXd3SktERXhtUWV5ZW02eUNhMWFaejJlR0txK0xjVVVNK3FaaWp4bnRueDkwNTEzQkFtM2ZYZVA1MnppY2FIRFZFdUxWSURkQUEvTDVNTTd3a3AwRXlyRUJSeWJzSmZqYVJvTDVHRmpRV0pBRERLamI2VEtLZ1NhS1lsb2NGMHpPTXArS3pkUmsyZE9UQkJNZDRSR0FGL0FKYi9TY2dwbTFpNnZnRzFYbXFBd1hlNmlrdy9vMzhEcUlwV0w2a0RNYkw4aU9FeDdTV0NDVC9BejVITkhVbHNrbUFEK29xY3BnY3lvNFVDeVNiaG1HZXdiTDJSbVluQVkyTzUzWTczQXd4NmJsTGJSK2YvUGVDUVRTcVNpR2xZbVNoeC9md1l1aU5qQmgvME5WaitjTmFhWUx4aHhSSEFGUFo2aFlDOHhFb013T0FJZndUZUxWbVVwSnFpK0NHYkZQTFpJcnZUVldTdForUTcvSEEvb3E4b1NtTGczWURCVHRRcW42QkxiOXZsVXhNZDhDNnNVV3lVei9BakFjWndsYXJncGVkaytiTU1xanVnSGw1TFBxRktqRVpmdmM3TVdvbXo1aWxSRE5XWE5hR2pBRE1BelZ5RjNPbXFzWGVkZXJ6OTlDb3FyeXBLMmltYkpQcVJUZGk1ODhGZkVKSmJzMGxOR0l0N1FJelF4R2dqcGpBd0tCbWlGOEE0S1lQZUxOdXQyY1RHL1B5OEFKRld5WHcyYXJYblZlWmF5VGYrRHI4V1VDTnlVakdDUkRMbzl0bmJtTmpxUXA4L2ZEWlhCYjFRVEtkemt4UFk4VCtmVHFjNzN1a0tIODZneFZ4K3o4YU1ZRkhuT25aMW14QmpZbFNJeHZQL2tuZCtzVTNjZHdBZms0QnBVcVZLU0R6c1lROVRwYjF0ajN1TTQzODBzVk03MlpLMEpMQVFicXZiUWtORUJpV0lTU3V3UDhDb3I0eUdiVFExVFVKWHhDSXMzSnlVV0lzQ2dsUFA0aFExQWU0S1NUbHBPZXVDWC93d21RY3E3ZnY5M2ZseXR1L3M4L21jVnRzaDhrK0pmZmU1Ny8vZjkvczdGWWE2Wms0dUNuTFdPZDN0VXRTY25vVVBEM2Y1YjZYMzZoRldUTmV0azVENXJzLzNMSFpuTWxkSTBFWEMyNi8rZlQrdGFlUDVsdDN6WDJlSHNVNXZ0bTdpV0RKMkFvd2E4eVpkei9lMDlNM2NlZkJsdjFvUS9yTC8va1BOUExaZ2hiUWJpK1BhZFZ3ZWppQ01lVXpiOXArQmxEeGZES3YyOW1CWnAraElpWno0bG1jTzZkOUJmREtIZjdXMzdTVDgyYlBGdmtWUFZtc0hhbC9jZysvVmQwamZYbkhmKzQreXc5a2g4NTR1NXpDK3E4T3c3dWtLNTdCRyszQnA3c25uRHg0OHVIVS9yUy9Bdm90VmU5Skp6NnJMS0cvZHVJTFdFMC83OENtc2VYbjlmbXI1a09ZQU9uMkxMVXZhZ3ZXTjRiVmJNMm5OWk93OWZqWWNtaU9nZmc3UnlPU0ZtYjZsN2l4cGdBSEJpQ3d2N3ZzbHJtMzJ0TUU3NzMzOS9LbkpES2hJcjBWUFYwT1NVYnVuYXlYM3U4UGtqanljV1p5QmU2eVp3UDBnRjZBazZsakI4cDFYaU40OFc3NjFpTENPNGlKc3RwZlVnNG1xdndyMjgwNUx1ck9ZeFV6ZVMrOWVTaGZyT204c2thLzczcnd3ZWUzaW1YUjZiaTJqTlFNaGpmWm5meno3NGJXTGw4K2MrZURVaDNmSm10WjBkNy9iMVhHVURDMkZyOWJHMUx2MitNd3ZYdFkwVmp0ZWVROVhIZk5oYmNUQzg4Vi9UdTRqRmVHV1BTMDlYLzNwTHA1eE4yR2hGY1kvL2RkOFMzbzUrM0h4QmZhazd6elplTG0rTnF5c256L3cwUi9POSt4ZStqcWZLZW9JeVUwNjg5bE1CbDRSUHhoUW1QWjB1V0V6cXZaMGRVL25McDdiYjBDeC96aTJJZ3pudWplR2IwNDhPdkQzMzc5emVGZDYvdDVqdkh2WmFZKzZ3T2lqNW5ZZjZzRnJUUytEQzFqRXpjWjcrdmIvNmtsT3ExeWRmbU9YM3U3UjB6WXoveHdzQXRwTzQ3ckp5SlhCM3NoMExwZWJIalhVeHQxZE4xRmgxSjQzNlJ6SloyNzg1ZkxwZzRkLy9WWmZ5OEVMWjFFc010Tmh3N3hKYkNTWHplaEwxTm5jQ1gydGxmSjk4ZkhicjdXOWQ2OHpEejZUZW42ODdiVzNqMExrT3Z3NllmSG1wKzhlT1BEbjk4Kzk4MnJQcnNOSFAzajJEN1FJM1RHbjh5YURnei80a2NNNHc4UzFXc3pDaitZemszZi8rcHNESDEyYnZFSFdvck1qcldXejhLTXFqa3cyUDMwaVl1enA4aC9UdGxjR0ZoU1YxYjUrckZlRVFBa205WDJZNGMrdmREcWZOM0VNQStNTTIxTUZuYjNUcXVwcTErdnhHbWJob3hzOVhaNXd1Q3RhUG0vU21zY09pNXpheHBUTDRnc2NXOVJEOFJGUTA2RWN2bm8ybTgrTmhodVpOM0V1R1R1dEpjTmtGajQ4Y2l5WHkrZEJjYWRIR3AyRjl3ZDV2ZEZWclFnTkRBUklEMU5JNzlEb2NESnZNampxSE1aTE50U2tORGZ4aHNQZS9zWm40WDE2b0ZZc2dyZ3pDejg0K0RPSE1MYVd3ckNjTitreVdUZHBkQlorUmk5elJHek1tOWllaFc5TU11ek9tK0RSNmQ0cy9PY2J4VUJYWitFYnNSbFdhbEk1YitMS0xQd0dESzNLQXduclVPMTVrM2I3cy9CdTJJek5ub1duNW5VdGNYY1czcmxrYksyRXNWbXo4SXQ2QWMvZFdYaFhKYVBXTEh5L083UHdsRm9NdXpBOFBGTGZMSHl0ZVJNM2JNYW16OElUeVdpN0FWcGlZOTZramxuNFJpVmpFL2JwcXBnMzhaR3F4MEhVa29wNWswQWpzL0ROOENiTzkrbXlPMjh5bjM0WmZVbTN5N1B3emlWanErMEkxTGpsb2RkcW42NUErU3k4cjhxSXhlcnpjNmR4dmJYNnZFbnBYbmFlNXVZbUw5bk1UYm9xZDlBdGw0eDY1MDE4bUx6bC9NR2dtV3hFRFNNbkcxcytsa2RkcnVZbWRVbUdEbU9pSkROcFlKOHVTSU43amEzMFFDSmdWQmFDQWpmVG5aaVlpQXlVd2JETVRWeVNqQ3F6OEVhRFViYjFJN0Z3RG1iaGpjTkl1amNKVkZvT1ZwWmwxaWdaVGN4TnBtM2xKa1VXWFY3dkNwemNpZ29qNHBtSWtMM0FZM1hsSnBTdmZESkxoUkhYU01RUkJBc0h2S1lzS2h6SEtmTEFoRUV5dnVIY1JBOCsrMldGV3lCbmgzTGhXU0czVGFYUmdSS05JQmdtYUM0WmpIb1FFQXh1dDR5YkxqTUVCZ04vR2dqRTQ5aStJNHFLSW5HQ0pFZmpySkpNSmVIZ1pIZ3pNNXZ4VGVRbVd2NE9MTGdVT1JRNTRnRVU1TGFKTXRZZElQNWtqZlpUMnpUWjd6TUVHbVJEVU1vNGM2TFArZklpSERJTE1pRnlTUUd1dnlDSUFJTXJKT0V0a2trRjBGZUVYZDlRYnFLRkdkNFZKWlhpRklWTExjaGcwMFE4YVhMZm92RW8zRkhBQXBmRjhqeVB1MHpqdGZOdzZTQUtCQUpQRGxIa2VleWdoZ1BFQXI4SEdFd0lDTkIwVWxEWWVJZVlwQVdPa3poZ0hKVzVwTUsyZzN3b3JCRkdNeUxRYmJiRGNSVkc2eWNnR0lvTVprTlI1SWtKT0ZOQ0JtbkU0UzVLOElVWVluaTRqaURvQUMvQndVbVN5UHR3ejNGZUVyUkRaQmhLbEFSTzlNSHZDaExQQUF2QUtzQi9Bb05PY2hMb2ljTEdZdkFXTW5nVGdDRWJZRFFsTjlsYUo0d3VnTEdnZU1IVGdUK0pSRVRRRmpBZHNnSVhFU1VpWFNod1BDUFR0QVF3R0pGT0ZPQmZBaTdYQnpCRXVnRGZ3QTlvZ01GTDhKM0FNenlISHhsZUtOQWNYRDhuZHFCa29HWndLQ1V4V1VqS3NSaEt4b0FaakZaVEdGc2RWY2UzbGVRbXVza29aV0ZNV1Q4Qk5WRld5R2I4Y0dKS2lnTmxpY0M1MGh6YkVaYzVtaTRrbFJBdjZEQkEzQVc2UU9QTlJ4aUNSQTdlcDhKSVNDQTlDY0FYRkFHR3dBa2dMS3FhSkZHQUFBWlJFeGxVS0NXVDU1bG9oODVqSXh6dlJnTTZOTkp3MEhYRjhJUVR3NE1zRERCMEdtQkFGMEJQaUhlZDhJRDlFSkZMdTFMZzVBNlFESlIwUVpSMUdFQUJiSUpRVUJWRFNBaXEzdkJFTWhJQ3lJZ28wUWlEbDhqbEM2Qm04WUFtR1pxYUZBQlNNcVd3cW10dEhvd3l5VEFhVUJNWXJkaVUwS3BhVVBDdXFzM2daRWpoOFRPUkRFRVN1WUlFdGtHRGdSQ1lWWVJDWUJSb09CSTBwNnFKSUJFNkNBUHRKeDRnRWtvQTFVUkMzNnJJcWpjQmEwS1VwQWpEb0NsbE1GeXdHVVkxK1cxbE9LNExCajV5b3F0L1JWbEExNHFPZjBCSndYa3FpcURhREdBaXNXRDlRRHFNTUJncGtkQmdDT0Fqd0Urb2tpSHdva0RUQXNLSWd3RkYvNEh1RkNTRFJnQkpnQVl3UkxEUTRIRWp0bUc0SkJtMVlCRGg2Tzlhd1pnUXZNbEFaQUxFSkpsS0VkOGFBeGh3WVNHV0EyTmdvU2E2elVBWUNZSDNvK0VvRU1sUVBRMXhyUUh3TFBBMUJuWWtHR2ZiMi9FUlNBTTZqUDdOa0F6ZG0vUmEyZ3lNUWVIanlrby94dU53aGhCMXBRUTg3UmpZRElEQnh1R2FkUmdKdElvMEdFcStLQmtjWGlaeHFRa2FmVW1Dd0FpQlpLQnZKZll6SUVQd0JYRXRHOVVlVTRBdEdzV25JSG1hVjgvWVpydlNwY3BGcTU2K3ErVmdEOURBZ3lVUktLdEljREY0WFlKSVlBaEFJN0hoV29zMkErWEVENkxBTTM2Unc5K0ZDSlNYTVFCbDJRQW1lMndVUGtlTFdhc093MlBRRXEvN01IYThXQThNdzd4ZU1ZV1BvRFBCWEkya2FaaGJNU0ZJTFVRSUxpSG9Fc0YzYUVFWGhVRVhoNjVFZGEwVVJxSStCbjVINWhFR21CYk1UT0lJQXovSHNieWpMcmFTS21nOU1IN3FLTTc0WHIwd1dpdkxmaVNKVjJ1Z21ITkNOSzQrd2tkOWVnT3Z4dU5hYXNKci8wZ0JVTnVFQ0lBRTFmemR1RzVTUklGcUVpMkQ0YWtPWTlBaGpPL3NOTUFZdElKaFNFMWFUV3VnRVgwSmljQUl4WXRaSzJQSVVpbDhITkFxUS82VFRBMStyQ2F0VE5VYWFNa3F2S2M4VStzeXEzUTVnN0hkbG1TMEdueHJIUVhoc3Mzc3FJMm5GVmp1dWVNS0RNZVNVYWVhV0VpR3JiSmYyYU4vS21FRUhFbUc2emJqV0owR3RDN0pLRnMzc1liaDFsSkJnelpqczJCb1NKekRHR2dxakIwT09uY2NxMGw5KzNSRm5mZDBPWVN4NVVWWFlFUy9UVEJHSGF2SkM0M0RHSWpZWGpleDJQYlJvbk9uQmd5djI1S3hyUUtHeGJxSjVTTTlCdXkwTVptc205alltaXBxM2Naa0tobEhHaldnVlNYai93ekdsaGVxcjV0MFd2ZDBlWnowZE5VUEkxcXJEN1F5enZoaHc1SmhWaEN1MXNaa0tobzIycGdha3d3N2JVd3UySXovSVJqTmtZd3FQVjFlaTU2dUdqRE1uVWxWTmFuZTA3VjVrdUZpVDVjZHoycmU3V2NqemloZlVXdStaRmpEc0ZJVFV4aFUwMkU0VnBPU09BTXJ3a09XTnNNV0RLMjhVNm9tMVNYRFh4Mkd0WnA0M1ZhVExhN0JVRzJHYlJoKy83Y1BSb1ZrT0ZZVFp6Q0NOV0RFTE5xbHEvYUJPbFNUN1dXU1liRytXSlNOZXRSRWY3eHhzVjNKV04zeCt5MGxJeG90aFdIUG0zU1gySXlmdUNJWnJzTlFxOExhSThCSkJaUmhpcy85YmhhTVVZY3d0dThvRDhlSHFzQXdWUk9QaFRjeFBQaWF3b2VpKzBMUkdKbktpRVJEZnZJRGZSdjJxakJpbXljWlpnYlV2RVc0bG1TVUIxMEVSakRvUTRtSWRRNnRyNit2clQzRll3Mk85WkZlRDBvSUZRb0dLMXhydFBTb0NxUFZSY2xvSmd5MG9OUXFFNGl0aE5jQnc2VkxZOWZIeHFZK214MGJHeDkvK21odGZTZ2NDVkNybEQvVUNBeDNiY2FQSzJBY3NZWmhhSm91cmpGYWVoTzhSaENManQ3MXRVZGoxMi9lSGgrYi9lZlVwZGxVYW56cTVzTE5xZG1wUzQrT0hlbFlYZlVGeTlXa2xFU3hQWGdUYk1hMjd6Y05SZ2pVb0d0ay9lbjQyUGpVN1p1ejQ3TzNyMSs2K3JmYk42OWUvUzh4NXhNU1Y1TEg4WVVjc3RtcnNNekFzbnNZMkdFRGU1aGxkMkhDSG1MOGswUGIycTB0TFlPUU9PdC8wWUNLWXhJMWgyQVdnampweTFUeFdJck9TcjBXVW9VODM2djRyQ0RPU3hIQ1FqeTB6SGl3YVpYR3Z1akY0d2dhOWxmZHJkMXFPOXUyTGxzS0RYcnhmZnI3Ky82K3Yrb3FxV3ZiVmdSK3RKdCtWS2xycFFRWTkrOFhPUVY2MWNyNDFSZm53d2hlQWdhVVNIV2diaWRCbEdKRWNVV3BFSVFTZ3dtTUNSVjJKT3B4bTZGRU91eXZhcSs5VWhpWFVNWVhGMUpHWmNGZVY5SFp4SDhFbzMyajRXR0NTU201aTVTanBFUlFIZzduM09PdXBGUXlKTGpMYlpSNDFMRFJmbngwUEJBNEhUL3pqdkgvVlVZQmpHQnhaWndMQTV4eklyMHJiRSthUkVuUHNsM2I5ZlRwaElnRjN3NFgyTUFVTE1UekJJaGpZYVBLVjFQVVFFRnZoVER1L0UrVlVYRTVHQVZsY2dKR2JYdGdKSTBWdHptZHhhN25lQUNEVzFHOVV2Q2RpbnJZSU1nd2laZnlrSkd1cTJrL3Qwd3VEZ09VVVZHZU1xNFZoeEUrQjBaaG1SU2NTc2pEQ0FBTGYrMUc5M0NDdWd6YUtaWGNzamhVaXlUTWk2UXlQRUFoRnNVVVk4WWRHeG1VSkVZVzJtdjkyVEk1dlhKbDBsQUFvL1cvS3FNOEdMOHVFVVpsaVRBeUJscGQ1WCtRd0ZRaXd5QWdDKzR5aENrWXAydWxvcEZvOWpDUGl6RDBXYTBRNW5HU0dQZUJiOVJjRFl5dmYvdUhNcFh4K1dkcC9URjhPVERPN1NhZ2kxMENBRENSdHVlNUZJRkJTQnRqTzVLREVVbWxPRFlSajZZOEF3RXRnUkpocUJSL01SaUJQSXd6S2FNQVJ2Z1l4cU9kY21GVVhQdnNwMkl3bWtzb2sySXdZUG1xRjhJSnBHeGlFaGVhaHkycE5FeDQrdzNzYVE2WlUxMnBxRzNNR25ZMFpTbmxRcjFJbVc3ZUtLYU00MjdTVU13eTlPWDg0Q2xsUFByNjQ1L0tobkhySUgyMU1LcXE2dElRdWFFMm1OWUZBV05RUkFFTUZNMWFCcnlBaXhpejFJcGF0cks1cmhRYnB4dHJxd05Gc3ZpRllld2MvUG4zRmVYbGpHdTN2dnZwNGNPSG1UM1FDOEk0NlJsSGQ1RjgxZDFwcEJCMFZKZEoyMUdHaktRaTBFeVVTVEl3dEdGWU5pUFk0S0FMaEd5TGdtd0VTYnowdDE4WVJ2QUVqUENJUGkxOStQekx2NVhiVFc0OTF6UmVabUdjM2VvNmplTTBqTnUzVDhLbzJRZ01Kd3dDbVVwNUZPd1RHb25MSllWME5XdDRubVBwVHNLVmJSTUQyNDdMQ09GUkQzSTZwbWkzN2tWdHpTbTdLQWFqMEQ0YmM1ZXk5RllYL05YQVl2encrZFROOG1EOEVzcmt5ZFIzaHpzdlgxNEd4djFqR0g3ZlFsMEN4bEtYQzgraVNBcWxwTEFac3pneU1XUU5EcG1ESzREQnNDRmR5Z1MxbzFHUFFkdGhOQjNjOEpYZ0djVmhOTmRsaExGeitIVDAyYzFMS09QcE4vOENHc2N3Sm9wODJGcFN6dEEwZkw2WkhlZ2M4TGhPeEtHSTZJN2lRZVNNV0xaUTNMT0ZVRkp4cnBoQUpsTE10VFdNaU9QQ1RNc1N3MFZoZEpjQ0l4bE82czlha3dmUFJxZkxWWWIyak9kUHBwNDlPZmo0Q0hDVXBJd2lnVHhmSmxXMXc3dE1Dc2s5d1IwS0l4a2hSUEtJanVGV0pBS1RPNGpDbFlnd2htZE5lSkhFMXBiS0dhV1FSTHQ5dnVMQ09BOUc1dCsyQnBOMThOVThNUmMrWEpuczc1aWN1b3huUEgvNmJQcGJLSlZ4MEVadUQ3UjhHQUZ3VDRLcHg3R3dHS0lnQklTa2xjbmdxUWpGTHN4cEVwdFlFc00wTVRRZDVtbEw1Y0FDMGQwSC9xcUx3MGdHa3hrTFRhNXZiUS9zRDR4K1d6YU1pZ3lNYjU1TlRrNGRmQVFySGg0NXRTTjh0bEIremtCclhsUkMzREpOYWd0RFJGd1lUcFdBNGQzSndJZ29qTGpEbVdFaWxnbGlCSUlwendSU1RqRE0rZlJodzBieENmNFlSbXZoMGljeEs1T1Z5V1F5T0QrZlhGc1pIUm9iNkpoK1BQWGxieXArY2IwTUdEYysvK3MvTll6SDB4MlRVQ3M3NCtQalI3ZDhMd3lqdTl0ZjNRQXpDVlNCelJWMm80NGdUQWlDbUpPS09JN2xZbVJITFlrTnBPQVh1cm5DY0pMTllSWVhNTzFEMXJnUURGakpaR3Nsa0FpdXJxMHN0KzN2ai9WM2pKWVBvK0ozZi95SGh2SHQ0K21CdG83dGc0OWhmZU5rSWg4MGlsam8rVEJxTnVyU1JMcktobHBBQWg0ZjZTMGRHRW9pamg1Z0RXYWxPSUlzWmt2RUJQUVQ0dW5na2Jsb3dCbENPQkYrVWVQLzJUSTVwWXpNam5BeXFWR0U0bnVkYlFPWGcvSEpYd0RHbElZeDJ0SGZQN3E5Y3BnY21adWJDSmZxR2JsL1Q1VTk0MWF6OFNDaHVDdVU3cHp3dGd2TWJPNmlXYXozZEtCbHdFelBBSmF0QVNHSzZIRStUem5VTUNURHd6TyttdEpodENZclkzUHpyYXRiN3pZN1czcERQVU5qYlFOWEFlUHg1UFQwNk1EUS9sREg5c3JXeDJSNER0Wjg2VEJ5UjBGckZuWVNYdFJ4YkdxWThManc1ak9sRkpvbG5sTGM4aVJCbE9nTlVGZkFQSUtrM3UzSkRTc1dETFZDb3AxZ3JhOUVHSTJ4Mk54Y1RJdGllN01udmhRZjdPeThRaGhhR1FOaiszdjdIZHRiYSt0MXpmUGgrZVlDRm5rY3JXZU9QK2JLeE8rZjJVRmdsaWtQK2dXbGxPbkdDdW8zbFNPWjYzbkNOT0ZIUXJsNmZOUFo4NGdGTEVkUklXbTZ1YW9FR1BDaWI5akdXcE9yV3l2TExVdUxTMzB0b1o2cmd3SEM2T2pvSHhob0d4dnE3Qnpybjk1ZVdWdXRtOHZvNHp3WUJiMjFJWHQycHlad0o0MjQ1VmdleEFZcVhBWXhRck9BOFJYeWhSTFN3QzZERkNhQWpCTEhOWkpkZWtOVXBrZE93Z2dVZ1hHbk1mYmhRMFlVVysrV04zdjY2dXZqZmZkYVFrQkR3K2kvQkl3YkdnYjRaMFlZd0tJTmFQVHN4ZU9EYmN2dmdNZDZzbTVlQTVtZnJ5d0JoczhmVEdQR0tJeG8wQ3lrSWxSbHRHRVM3bGt3aUREQ1hFRUlaQXFxQklleHJSQ0dBMkdNbkFzanQrc1hnL1VoRnJ1enZycTJCZVV4dUxUNC9XSjlWMjl2NzVYQXFEZ0JBMUNNRFkwTkRRMTFoZ0JJNXliNHg5cDZFbERNeDg1Vnh1MzhRYVphZi9NdXhqQm5VSXpna1lsK2JrcHRGMFBxU2xrZVRDbFNCdzhHK1FKRDJNcXpzRFFNRjF3MU1WSjl2akpBR0JwRzQvdlZ0VGZ2bG52dUxpNHUzVzNxNit2cjZycDNiekFMWSt3U01LNGZ3ZENXMForRG9WbDBoZ2IzOXZZR1EyT2J5eHJJYWpLWUtabTVHRUE1ZVM0MmU0Y3greGZYQmlaMnRWVUlhaHA2QnhRa1lCb3NFbUZJUkMwRmVRc2dZV0k3SGpHZzhVWlBDRU0zWDBrU0R4WjhaemU2R21abVhyMzZBRXRMNHUwS0ZNZnJlMDFMd0dLcHZ1OE1qSTdIVXpldkRNYVladEhaMDlrRFBPS0xpNHZ4MENaVURBQ0JtbW1NYVpGa1ZtUEJKY1k4ak9GZHBXQTJGUWJZaEtJTW1hYUpQRWhiaHFLR0hZMVFFenhFY2c3SlUya1kwUUpwT05wVkV6c0ZNTUE5OVczQVY2OW1Zak8zNzcvL1lYWHQ3WnNmdHpkZjMvMGUxdUpTZlZOVFg5T1Z3cmp4eWFkSFpaSlhob2JSMHhNS3RiU0VXZ2E3K3VMeGVHOVBUaUxycmJxanpXa2NkL0twS3dlakdtQklLVnlIRThqYXJzMk1XUXg5UmRqRU5HWk5PNVZ5SVdSSVUzZGRwcnpUeXJDaGluYUg4ekF5S0Y3Qm1tbDQvOE8vMzc3Umd1aTcrOVhpNGxkL3Yxc1BxMGt2amFNTGFBeENPK25Kd3BqTXdyaGVqakkrelNtajR4Z0drTWpDQ0FHTTNudngrQktzZUZmTGF3RHlidVUvdkoxZGF4dlpHY2R6NXcvUVQ5QlBNdEFiU1JjVkJRVTFrcEJOS2piZVJOUVZOdTBha3VKQTJHUUp3WW02NEJsbWwwRTR6S0RTR2Nvd00rNTQ4dExNRGlGNzBiSUoyVGJRNWlKSUxSZ0NKWkJLMUtnWC9UOW4za2NqMlpidEhyK1FpMkJiUC8zTzgzYU9yVWRNRWpENWs3K0lDLzArTWpQakYrOVZTVkpOS3FIUWcxbU81TWhpWDdRUlNrWFJIZlRReDV1bTBCY1JZajBYelFwMWI0TWd3Wm9lU0wzLzJZTnZHUUMySG40S0NxVEQ4OWUwTXdxMTBqNlUySzhWUWhSRXcxY2pDZVAyb2pDVzhtQmNZU1RJakV2cnRLNWRneDdZbzFoUFZxOHdKTy9lL1pXWS9PMEYrNzJ4aHo5aWYwUGl3Y05mdlVmSHdic20xVlE4YnhsUTN4TVUzckdSU3RDNkRrelY3SG1pcUhxT2FqQUdPdjFXdmM1U3E0b1MvZjJ2Ly9EZzA1LzgrTVdMNzcrUE1PeTllZHg1OXF5S3JWRmtUakF0QUNPcFJoNk1wYk14NDhwVm40UVA0OXExbFpVVnFOaXVWRjdodlZEQWJsMTlBMDJZSjk4UWt4ZUljWGdtdi8zZDcvOHBBQU9DZ2lUamVVYTFxZWs5RitXNHB6cGFGeFpvdkdPYXFpSUtsRTdRbnFFVXhmKzBDWWJGbzYzLyswL3AxWTU5Q0MvMzloNC9ycGM2UmF4T3FWNnYxMXF0QWx2bGNrS05GSXpMcUxyT3dvek5MSXoxOVlDRkQ0TjlhbGZLVDZBSXlRcGIyK3Q3ak1ucjU4Ly84dWpSdTI4QTVqMHFDRWxEUjg3enRtdFptdVVZaG9wb3Fucm1ZSURzaVRTQ0hoNTlxNEVIYnlESVFpVEJvMGhxOGVwUS9NK2ZYNFBDeTcwM2J4N1hHMVYva1JLbGVnMG9XakdLbUVYYWpBU00wNWlSQXlQWUk0RVovbXF2d3N4S3VkQ3ExZmVmaGF0VGFqMStzN2YzOG8vLytLK0Z4c3h3TFhTa21tN2JCZ1VQVmJVTjZrMU1kTzgweFVCSnFwcGRHN3ZGc0NHR3FtcTBZMnhKR2tvN2h4eTN2RXdmeTRTaENTV3c2cVJGRmtaQ2pTU014V1BHaGZ5WTRXY1N3dUN2RUVhYjN0cGdVY0hPTGJSYXRWcXRYdC9IVDl2eFhlNTA2djlHYWFGWXFDalFocG1JQXJiRml6eDZFVTlpSTBCa1cxSHA5L3VpWmVEQld3aWE2UFlOU05QckdySTBkTFplY1Z5MTJxVFZhRFRZbHl3eEhQaFdyZG94ekRoRnpMaVFiNGFmVjdNdzJqNlFBRWFaZUJBUk1LR05qUkJYcFJjcVVTVlJzWFRka214ZFYyVWJWWWNrMkhxWGFnMVVZaDdhVlZGUmtHb2syVUcvSWlpMlp0c2FRaWphVm43b2ZQNk1xeGI5MVFsV29FWnNobytqNHI5TmJaTXp5Q2IzTTJaY3ZSaUVpeEJIdUVmYVBveEtna1dML0tBZnVWTnNjdHNqK3dEVlpSZFBlYmRyMkpxc3VnZ0dXcmRuV3FoR0pjdVNBUUVsdVNTS2RGOUZVV1EwTEdoalhWZFNoc0pvYmJuYUtFWXI4cUtlTktOUW1HSEdsWTJOYzRvWkRNYktTaHBHWkVhd1VVSVlvRkduemRMazFpYnFVRUJFTkdSREp3QzhoSkJCc3dza1V3UUxRYVVqRldySjRBY3ZvV2lYSlZWekRWVzJCT1ZBdW5tUlM3QmdjcFE2Q1ROYWNTNkoxY2pBK1BuMndqQ1dqZ3RqSlcxR0pXVkdDS1BCWGJzcml6eFBNS2plMW1RWlZRWVY1WWliNElHWUtTSFgwRHpEa2xHSXlLWXVDNnBuR0RKaXFYUGdmRjNoaXNXanpNaUVqRmt3Zm5EaHJNeUl0Z2x3c1BkWWpkVjRteVROS1Brd1NwK1BobzV0ZGczSm92bW1ia3U4S0FveVpWUEowMVFKUGIxaDBiYlJkVk9WM1M3YUZFbVFEY1B0RHZTRDBmVjZGa2JhakNoOGxpdWhIUXpHQ3ZYd3A5OG1TM05oQU1LSzcwVWNOQkw1SkRBakNCcjR5WXZWNWF1VEE2b29OUS9iaENZV3VtbWdYelZkaDZlcHArT3FnaU9qYyswT2VxWm45elJKUXRtdTBWOWVHdWpEeVlkR0JLTkRiemxtSkdDVTQvZ1p3RUEyT1llWWtZR1JNU01mQmlYWUJsZmYvYWpUZ1NIOWhTYlhaRWVIbm9rbXhKWHBhTUJ4WllXYVdWNURMd0pJa3NLT2thak8wRFg1RnJmY25HRkdMY2NNdjloSXd6Z0xNKzVQd1NBYUlZeDRtMFJtQk5tRTRhaUZadURuNTRxYms3R0p4OGJ1SFhpbTVzbDBDZGJWTlVmemVOUWRncUxhamlqZ2s0QjZYYUVNbzFPVDBuUHRtNXRSWHAxdFJoUkFBek5Zb3hhMThKZmpPbVB4bURFSHhzcDB6R2pQQ0tBRW8vcmtMcDBZd2dXVEhqTWRuUWwwZXNJTGhtbklTQ0NDaVo0TUNWVUNIYVd2U0liTzVobTlzZnJacXdTTUdXWkVGVmM1VkNRMXo3aDhxa1p0NldRd2NtTUdZeEhBYUZTNVQwYnM4ZlZNbVpJSWJGRDlxYkNId29OdXRlbGQ2czlFQ2NVSXlqQW5tQXZyS3ZKcW9zakltbEZQd1NpSE1JSnRraGdJbno1bUpHZWdXUmp6WWthOFRRSVlpQm9mN25wam1tS1ppSm5VeWROSW1DYWpqajVnQmJwbk9RNktkcW5iMDlDMXliS05ZRHJReDZPdFdxckl5REVqRGhubGhCam5Zc1pzR01sdGtqR2pFS2tSd1dnZVRnNmcvVUMzTFRveGNGVFZVZGxrMUJ5ZzhCQUVHVzBiT2pocVhneTZIVW1IQytqemQ1QkswbUpNbVpFSFkrWTJPWG5NV0RveGpCd3owakFhWFBYZXlFQWVNVzNiOHl3TEgreXpaN3U5UVJmZGlPcWF0a0hEWWN0RWJrSEhvcUk3TVViYkhOZk1NNlAwZnpYanErUzVDUTJFNTIrVDloRm1BTWFUTFhuY2MybHVRMHJRb282VmpZQzdydTNZbW9XTzFkQU1MRS9sNlZScE9McU42Tm1ZQ2hrenpFakV6eUMxbmtYTVdEbzVqQ1BOYUZhNUsxL1pZN29XekRzMCtMTnBRWXh1Y0cxY282TnBWemMxdzZXYkt5SS9IRXE3Nk4yYkdUT0NwaFZmZXNxTVNzYU1NNEdSWThaR09OQUk1enIrbWphalBNT01ScE1yYmt4a20ycE9DeVdINmJwc3lPbmZla1JWU3J1RWhSUWtXeFZCUXhTbG5jTW0xNHhoZEpKbTFJOHlvNTBMWTdHWWtZU3hkaU9lN3FSaEpFSm9KWWFSVEs0QmpDWmdMQmUzMGIyaUUrUFJucXU4VEtNczNiUnB6bUZwUFlQM2RMQkFGMCsvV0NBTW55cDNMaTl6WEhXR0dWTXhJMFpCWmxSbXdGaHNuakcxVGViRHlERWpCUU5tTkRsdWYzdkMwMlBsWlZsVVpJTUtMVHFFZFpCTUVDWjRyYWM1S0VNa1ZPYmZpY3B2TmxDc1ZWTXc1c1dNU2lhYm5CV01PVEhESDNVZHl3eFdqaWZNd0FQak9tdGZLaElOTER4QlJNdXVxMzNCUWkzT1M0SWllYUpLOTZSNU9td1QrMjlwOE1sUU5LYk1LQjFoUnVXY1kwWWl0ODR6bzFMSlpKT0VHUVJqdWJpMjg3YmZQOUJOMUZlV1J0V21hdlg3amlFOWxVeGdRRzJ1U0QxMytOM28xdFZxQUdNNlpwUm0xaG1GNENTcFhRbGdCUGN6VHBOTkx1VEdqSGt3bUJtc0lKNW5CcjMwOGVyZFh5cUMwWFVVM3RaN3NNR1QrMzJVbkU5NWdvRXlTemd3bmJkZlhPOVF2RGlKR1RHTXBCbFRNTTR5WmhDTWxYbG1SREJxVVE4Zm0wRTBtczNOTDM4cnVtTlpSZTNwaUs1TFUxQkhVZ1JMbExzRDNiSEdCNk03TjVyRXJab3lvNU11UUlPdU5Ubk9LQmZtbUhGdjBXM2ltM0h2Zm5DTEtWMkNKc3hZalhGTW01R0MwWXhnY0Z6cDh0Wk5UeDRPeDkyQkp1dXU1Tms4anlncXE1bytIb3J5eDhuOXd5TG5zOGczZzlTSTY0d0VqVUxDakd3QXZYZTZtSEVNR0t2UjRjbVVHZkhjTDIwR2V6WDRHN3NUdWlQc2FwNnJJYlU2a3FkcnN1MGFnamlhM0Q1cytDODVXRTJhMGNtWVVjK2JkQ1hOT0NNWUYrYVpjZkZTdGlzNXNSbWcwYWhkdlg4SHNlUEFHby9ITGdvd2JUeTJIT250Rjd1YjdVNGpmRDN4SERNNlljOWFyNWV5SjJyUmtVRnV6RmdZeGh3ejF2TmhaTXlJVHRiOGs1TkcyZ3oyUUo5c1hMKzdNNWw4eExMcDAyVHlyNjE3bXg4YWlSY1RuNDRaaVpLTEhTOUdJYlFRc1NpRU1TT1krcDFyekRpR0dTMC91UVp6UHdhRG1kRk13R0M3WmYvd2srdWZiZTN1N0h5OWRYdjd4cXRHK2pYbVo1dFJTbTJVTEl5bzVzcURzVmcyMmIxMU93MGpPbTFkei9Sb2lYbEduaGswQlowMkk5Z3VwUnA3Sml1RlZyM1lUS05JbXBHTUdDR1B0Qm54T285c2Npd1k3ZkF0TE1lbnpaZ0hnNTJ0VC8vektET3lNTmozS3hUT0pXYUVaa1RiWkMwSHhveVFNZE9NdU9vNjlxcG16U2o2SCtFK0tkVVR5Zlc4elppQ3dXNW9YRndQVW1zc0JqME5NOHdJRHd0WXA3WVlqTWFzR2FoZmFNUnF0TTR6WnVUQ3VKU0EwUTYxb0k5S201M2VaTXc0QXhoSk14Sm5yU3k5MXFJQitiUVpaNWxOZkJqQm5ZUlVvYkVlSGNBbkFrWm03SmVKR1F2RHFHYk42TVNsUm14RzRUaG0vUENVTVNPNnVoUEJDRTdpMTlQWEVUS244SkVhQzhCWW5ndWpFOGZRVW1CR3NFdit4OXU1OUNhT1pYRzhkNmw5cldiWmk5N1ZkNmlrVkFrUXFzaURGQk1nNUtGTUJZalZKWlFzcHFWQm1rVkxzeDFyZWx1clllRUZDeVFXSGlGajJiSmtnU1dueE5PV2tKQzk0QVAwUjVoejd2VVRUS29DSktTZVVhVVMvL0kvcjN2UFBmZjd5dmg1VFdYOEFBd21BQ1AxY3NxbytNcWdWdUpMNDNGbHJOVFRoVEQ4SXhaQkdHNUdIcFpHT3F5TTY3bmQxblZneEpjckkvZkR5dmpIMzM5ZW96WlpoT0htb0c1NTRnVVVOK05LT1owN29SMDF2MUo3YW16MVlFUVlTbUsrMys5N3lsZ2RSdEJuTE1BSTdCYzRBWVY1dEhObmJSaFJocEo0S1dYQVI3eit5My8rNngzTENzRW8weTdodTJEclk3Q25LeFhxejNDM0NsYUZNWStpNGh2S0VtVTR1eVp6alR0cndFQmx1REErTDRGQjAxRDR3UlNwb1R3VGpNQWE2Rnh3alZhR3QxRVFEV09WUTg4THlyaHlUNXhRT3psZGFCSU81aG1MTzJycktTTy9xQXgvRVRSQ0dXNXBzZ2xsNEd5cUlBd3Z0bnJ4aEVvakNNTnJCSTNlYTEwWlJxRlFpRlNHMytFV29ReDNvWXZ1T3p1aGRXVVlyNWZBdUY4S3cxVkdiRlBLT0krRU1hK00zRkpsUk1CNHN4bGx1Q2V6cURTY2h2cEFmQzI2VG1OK3J6WHhMTXFJTDhDNERzVVMxMHlDTUZiM0dWUVp0TjNQODZCQk93bTVEWnB2TUkvdHRhNEFnd2JXRUl6S284cVloM0Y3ZDdvUm4vSFRLakRTait5MUxzQTRYd1ZHMEdjc1YwWnFzekMyWG9WaGVBY1lnM2JpOWRTN3BySzRWZUR2cUsxaEp2bUlacFVnak91Z012ek9SMm9tNVkxRmt4QU0vd1Rqbi8zK3JYTU1oOVlvUVR0SkwvUm5oR3VUek5zZnJWc1hsVkVKTFB3RllTRDd3Skxmb3pCVzhobS8vQkVKQTJuYzM1emM5dnNNeU5EZlR3ckRpSzBGNHhFekNiVWtoQStjWEMrRlVWM2JaL3p5eDllZ3ovQ2R4dW05TkpPcWZWSHNNN2QzZDM2UlVsd3NUOXh0ZUEvR2szQzRNSHd6cWNUbjkwMnk4NGR2ZkNOQkZnNk1xeTlmUHEvaE03WUN5bkJqNnhVOUQ5K3ZQaGlHclpMcEZIalV1bCtrVGZYQjhpVGx0WUw2YmJFcnczQnIrRW9vRXcvazRuNVhMRmJOem9GbkF1UFVnVUZHUnF6aE15SmhvRElBeHJUUm1CQWUxZkl0dy9UcGdkbzVHS0hWbmVkUVJpNFhkSitwVk9BOGdhZU1DQmhQOXhtZU12NGRna0ZvQUl4Sm8vSFg1b2NwbmM5UXhwUHhJbk1iUEpvMXA0eEVFTVlQWjZCUkJYd2dsZ1EyVFVJSHNoaXlTMEFxa3dBTTRqUGVyS2NNRDhaVkdFWVR4MmMwUGsxQklLQVF5YXFlTXNGVVkwNFpQb3luZUZBSGhuTmUwVjBkZDFqRVpibmk2WUowTUhrdzZERjQ0akkyQWlOQ0daNEhwVEJ3N0E0bDBrU0ZxSmJJaFBPdWFHV3NBR04rT1lPODRFL0VURndiQ1IzSElqWnljUkhJdWRaWHh0ZWxNTUJuTkQ5UkhQajYwRHdhekZycHVST01rY3A0dXMvSUY1eURySjR5VUJhWmJNOHljeFVuK1F5ZStXWWNYVkJoNEVGT1A3UytJVDVqYXhWbGZQMW5CSXpxL1ovM013T256TGhEbVloQXBzdGg1TmFFa2ZkZ1VDT0o1ek9aaEtrcVl6NGh1MjA3bElSSXhqYlFqYTB3akM5QlpXeXRwQXlFc1pob2xHKyt6Qjdzd2ZTRGZ5RlFzK2txZzRsV0J0MTV6cStuRE1keFZ2S1pkay9vNkFwZmtkMjJIU2U5UVJncEo1SVFJM0VTME9yVldqQmV6Y0VJbDJvM1Y1YWtHbUFsSDQ1d0VGRVRZWWdNVTR5QU1iZHprbGxER2M1R1dyemRHMnVkdW00VEdEU1dwSmxZUzI0eE41WjFrMnFKcEVaRFdaeVE1ZUNRTWw2dm1vRkd3Y0MxdnhQTXRrNGVwdUF0UGh6aE5FRklPMmF0UjJCVUhCaUZWV0NFbFZISnRDVmxYNi9yZFFGZ1hCTmxRS29sdGhnZXA5N1lENnAxSVRMVVJrNDlHRmRyd1loVWhsK2RsRS82dHdSR2Mycll4cVFaZ2hIc2ZvemFVOHM4YldrbnJJeDRoaGYyOVlQOUdvSGhLQ01OTENSaGdOUGJ1SWt0aWVrNVpWeGQvZnJaaDdHMW9qTEl4a2tvNjZxNk1PNElqTWJrd2JMd095S0p3ZWFkVkdDek5hU01wMnlxUmNGSUFBejdrc0l3NHhsWlR1QW5rbHZXZURBaFUzOGFqUjNiNm91RUJja3kzS0wxdDlWaHZGb0d3MU5HR1dHQUpGUkc3cDlhVnRWWitVdkZydDNENmJHb3VyV3dBV1YwOVAzOU9pZVlpVGdZeUhVc203dTJCRWlLdWVQanMrTXpyakY5S0xjdWJ0RjliZ2dHVmNidkN6Q3FIb3dUQndaODVpS1VKMFZhdDZhY0VUeGtDTTc2UG1NZVJpTGh3a0F6TWEyWnhDZXlMVmxTemhydWZaZzdYTk9BRFBEQ1o3RWhaU3lIVWFZd1BnR01HNFNCdFVtUklaT0lUay91R0JFblptV0RQcU95WWpRaHMxUUtia3NHZmpDQmNWbmIxbXpiR05pU0xHY3RtMnR3WkRaV0U5U3hBMm85eFM4akRPUHo4eW1qN0N2anBrVVhOWXJwZmhvSG1hbGpMRmJNZEpidThOQVNudnFMd21MMzQrTzFHa1dSa1F0NWttNVZjbTNUSENyN2RUTFZyMWJYZFExZzhNSzBBUWF5TTUxTXBqaFhyekVWckJhelFSaGJqOEFnZlc1QlpkemlnaGZvSW1YaERNUUpmRkVEUTVqeExUa09TUkdCa2ZFSDVzQTMrd21yb09jWktNY1MrY3g1SmwrcFFBNCtWaFN0czMrQUYwTnQxN1oxemdBWU0zQ2RvSXVwUFp2WjArYlJUbU5IaVlEeDI3cDV4bmRoTkQwWWQybnhaS1pNUUtwNkEwZVc0U0JLeUpmaldXU1JOVTJ6M1c0bjhsUVcrVVM3WFFrL05IaUd6TnlpZWFITjk2U2hPb2FYT3V5MTg1bjRlVnNkMU91MTJnRzlKZXZnRW1EMFpCNk1CSUlxaExWVVN6S21qWjNHa1NFOUo0elA4ekRLODhvbzl2dXpRYlBCN1RqaldvSEhSTEN1WlZ6MWswMFZIMmdJajNUK05wOHo0Um1IRWp4ZWdicUdRZ0llRzE1bXUxTHdTRlRhdmFHZ2FOK1NPTHp1Y0tRTXpVTCszQngzOUZycHdMMHk3QUJnV0xJS3dqam16bXdlL0JTakRoQUdGQWNNeWNVeEdkOWNOUG5YNHpCY1pkemRpa1hKQVA5Rko5TWY0NlJTanJzMHBKd2N6MVV5dk5MQjRXdmZCUDV0SHBTdWpYQVFtekJzaytlRzl3Z2F2aFQzUGNEQ0hBcmFLTG43a1MzVldIaXIxVVpDci9EV0hJLzBtbnY5RDg3TjI3YjVtSUFzR2dNMUxjZGFNZmdpanI0SDQ2ZG5ndUVwNDZKbDJkUEdFUjFicTlOeGgvQzdNY3ZLY1lpR0duemg5YnF1OFpCTGYrdlc0YTNiWmJVeFR4NWJHYkZkOHZxYnBwcFVHKzJoMXNYUmIxMldMUjBlZ2poMC9VRGd6OXVnRERBVHFveU9wdGdQa21rWitoa2tGellQV1doTTVCVUtRM3c1R0tGb2NnOHdpa1Uwa3VZUmlmT29EZTc0M1JuaU1IcWdEVkJHclZZNkxOV1YzbENyMWRuZFpISjNGd0N3Z29uZmJQaERjbS92ZjN2d250SFlKRERNOFc2ZC9LdmRqNGQweG5aSkg2azVDb05JbzFZemhudzZDNFl4MFRFTmZ5akdSSUJ4YnplZkZ3YlpldjQxRXNZbkIwWWYvOW80MmtGZFRHeFZGUWFjam9OQjlVdWJ6OGdPak1PYU5sYllMa3V1elVyaXMyc3FQd1Jac0N5OWR4TGYwM05nSk90czE1dnlpRERxQndaZlVSWE5Wa2I3d0lPRHBDc2h3My85ME5FeGxLaGlMQVVwWDltQkVUU1Q2Z3ZCY0pYUkZ5MjcyU0JCZmpDMnhEUS9NOTV4N3k2M09mMVNoY0Rvd1BnNDBwSmQwQVRyM0R3SWxpSm9YWGJQZjNYWk1YRWJiWVNSQk1laUdkcW9VOExiV1d1MXpyRFNreVNlNWhuMXVzREU1WVJzS1pjSUF3ckZXQnBnM0JBWXh2UDVqRVVZNVFWbGlET2pDY3JndUNQaHR0WEt5dURKZEc1Nys1SUQwNGlmdXpEd05yV1ByQWNENzFVRGlleTV5a0FZU2c4UGNMYkJURWJLR0ljYjlvYkt0enJlbWxZcmphL2prS1gwRU1ZbHFVM2tuR3daN3dERzhRQmhwTUZuVUJnUVdrK1dLbVBEMFFTa0VWYUdLR0pjUGRwcGNvT1pMSXRaK0tsMk9BNWhnS243TUVyb0taTHd5MjZTM0NRSVlCem55VG93TkFsZEtIaFZRWUpZaTVsSmpoZEttRnJVYTRLWmh6eWw1eXFEd0pDMGQ1d0hReFF0akNaVDIyb1ZYeDZHN3pOVTlKODdXRCszV3VsVVdpVGZzdTNMN1ZyTlpqSytNdGlPSmdpQzV0OVh5aWJmYTVCVnZxZmlZTm5SRUdHMGV4THZaMlREVWFsR0hwK1BaK0tac0RLa0FZR0Jac0trV3d3SnJkT0hxdmhTTUc0V2ZZYm93amdUK0phWVRvT2JSODhHTUxickJwOHhIUmdsTUFPcG5ZUEFtV1NkT3lhN2U0ckVtME50cit2QVVFbHd6ZFA4Njd5UWE3ZXpRNjFVcDNXcUI4TlhCb0hCVFZTRUlaOUMwblhVbU14T3hRdkN3bGtCcFRCKzN6aU02a0xWQ2pCdVBSalRoeE1DUTVTTEVQTnc5cmcra0R3WWJGMGplUlhHVTZLTDNlNTdSY3JUdklJbE1MNk5DMTdpQlpucWVBeENVa2FIYzhvNDhKV2huWEgvcCsxOFh0TmEwemcrdTg1K05uUC9nRHQvdzkybEtYaU5FMko3cXlQUnhGcHhqSTNPRWRHRmdvSXBKeDQ3cDZJbFRvVkJWN3B3NFVMSWhjT0lFVVZHakpCSWpMOUFDTHB3TzVtQmR0TjJjNS9uUFQ4OEhtMlNhc2QyMFJZYXdpZmY1OWY3UHUvelFHaDlmb21Id1RWTWRrNkxXTUk3SldXSU1CTDBxZ2ZDOThBNCtKb3lBRVlGWWRoSzJ1azFENlBYM1JKZ1BNdmwrbWRtS0QvTVZ5MENBN3hIcTByQ2g2Wk1rZzBKaHNFenJFS3EydDRoWTVUSjJra0ZqSUxvUVBmNXBHdGNxVlhVamRGcDhmUm1ndCtTM0Vya01GYVp0djBWR0lMTFVQaU1YZDZCWXZWOGVRakswQUlNZGZYNjRzbGpoTkhRbkJFWU83bGN1NHVsSzBpamZxN2lZWlNGbkxNUElIN2VsbUJBcHRyYnhsVjBtSXJuQ0F5Rm1aQ1RMaU1mV3ZmNWROdzFIZVR6cC9CSFoybDNJYzJJUzhyNGJoa29md1o2ZUxDUVoyQm8zWno1REZ2SkpzSm9RdWJJSytOOEIzS3FGMWk0bnBVaGpHQXcyZTZMVHJJdGh6RnN0TjVoTmk2TzFuNm1VSWJnTTdhSWF5cGlZYmcvYUV3dkJ6Z052amdKZFRvU2pOQ0IvakJFL1g5Z2hKWXB3N3VMU2RjdkNFT01KcmFTYmlyQUdFa3dDcXE2RWthdkswVU1nQ0dhaWFtL2pkRVhjcEtkWmh1S3VpYnU0SnhYUnI0dzRkQk1YTlBySXRiSmtJU09idkw1VGN5L0tpNExmNWxHQ25ncjVFaHJ3bmowNDVFRXc2NDg2VHFjanlZQW8rTWo2WGdSODR3U0tvTVVEYnpQRU0za1dXRm5Ec2JQa0lJdWhRSHV0QUJadStvY2FsVk12UHF0QlFjS2Y1dHdIa090Vm9KQ0RRK0NOemR4NmpzeDFISEp4VjhVZ0REMERvbzlDWWZjQUlNSnIrb3pIdDBKZzQ4bUkwa1pPS3QvT2lxZWJrSUpmK21xUWY1VHFlRlJwY0tCRnBvVGJnWUQ4aTdNc1piQTRPcnZvRXhUbmJmckRlNU1ZOWlvTG9SV3ZDcG9kWFdtSWFmVzlrZEZpQ2Zrem1UenRKakhpd0lMZjgzcWRYa1BmT0dqTjZ6UEhZaUxNRlk3OWp1Um1jbmNWWUdZam85bXlzQVNmZ0I1TVB4a0JsVnR6YVl1a2RTUXdHaFZheEtNTXFkUXhqd013V2RVZTZnTDFYbjlTa09PUWJ1OW5LaU1taGhOSHVkZTFxZlZmbjhNNFRSL0laeU01NHY1UWJWVGNRcFhTRTZIM3M2Y3ZJa0dRMVFnSGxrZEJwakpTVW9KUStZeTlKM2RTN0lCaDRmaGRaWU9HNlBpTC9zZzA4SFVWcXFWdVBKKy9na21YUmV6cEl1SFlSWmdiQytIMFREc05iYlBlZWZxd1dOQWc2a1AvMXRRaGdUajZjc256ZXZyRVo2QlZnZlBpOEpuTkttNjFCMG4wTkE3dEVaM09NeEdrK2x3d0wwbWpEL2NEZU93QThuZXpWOU9NZlVGTTluMWRsempTUkV5RGJDVVFhTTZucFpIRjg4QlJxN3dzbndtMWlZS1pXeC9CUWFVckFSR3UwR2VoS01IeVluUnBPWWg5eVprM3cwZWRXRXBwS3RPcmtmNyt6ZWo2MEZqWENrNW5EaFB6V1d4QnROdjA1bWpaSmF4dSszeFNHUjFuNEVPTkNYekdlNzVXL2pEUSsvdXVERVozRUJSaERDOFhtZW5BbmxYRVE5MzhqZlgxNWdrN3dPTVF1RzZxM2tvRENUd1Y0QlI1bUdvK2pnOUFxclVWemtwendBWXcwYnpBcFdCSnZnWS9YV2x3azB2NjZTL1RGZnBrTllNcDBVZEN2L2puMy9MeG82T1V2NEFnUkVMLzdDNk11Wmd5SlRoRS9xbGQzMjQ3ZVZ5NnVzZ2pGMVg1UUFiMzU3dm8xdEhiNFl3bmx6azhVcFVEc05ndmxjWkJJWktsV3Mxcm9aUXdUY0xPU2tEcldscUdraGdjbVF2Vk80QzRuYXRaQ3RWbk54NFBPWXNGY2h4RUliREczTDdvK2wwTk1nY0g2ZjhjWUFSajhUWUgxYjNHWGZET05UL3I0THJiNnhqdllYc0xuRG9TaUh3cWVEUzkza1V1QS9vNGpFWTlUZkJBR1dZaUpsc3E5N3Q5T3JsU1ErU3JpWXUvZUdWb2RtcURjdE52RERJNVovZ2tUTkc4Z3F1aklEZmFyNVJ4ZUhhdFlkUDBvdzlTQ0VNTm1FbnlsZ1hobitwejVDOU9MSGdEYSt3eDZHakkwMlJlV2s1RWhoMWE2cEZNLzhhRE5XQ21iU2hhdTIyU2VXaUFodzd1T2VtMTJxK1FtVk1yZ0FHU0dNOGVZcnJaSExONjhtVXE5aEkzMDVIMitGZjNPQ3RyMjQza29adjMwOEhtT09qVklxTzJ3T1JvSitIc1VwUGwxd1pnVVZsNlBsWEZsNUh4K1VWWWJncXBWQmpNT0liQThqeW0xRjlxcTV0SVl5bmNoZ3Y1REJlS0dCQWFJVXlqcFF1TytRWU5OY3VnOHZFVFZDRHFzZWdNVzF0YWNhTmNoMzdVcXFjd3lhODNCUStwSjNMb1hOR2t1OVBrbEhhenJ4SnN2NWdBSUtKQ0dPbDNzY2ZrM2ZBMElzYmNNVE5ML2l3MCtubzhEZU1OemQ0Yy9LeTJib2NlMm9lY20rU0E3dC9WZGhXd3BnemszTVJ4bG0vVjhCRVE2V0NRZzBJVnJ1OWk2ZWdrSHBWWThCbTJGcE5NK1E0VHFlcDFXcEd0WFlPaG91WWlTTnc4dm9vbWZMYkV5ZFJKbUtuMW9YeFU1cVlTWUtjZ1M1L2ZqTmJkc0x2d1lFOFZOdlJqNmY5OHFRK3FKY2I0NkVOKzNnMTByM0puK3NTakhOTVFSVXc4QWp3WjRCaHhzTnhLTk55VUtsZDVPb2NCTmNtTHYvcFFqVkNwakI1eUpRdThuaVJWNGJMcFpNcncrV3luN3hPMjYxME1FNHp3VENEMFFSaC9IRlZuM0V2REd5YUlqQkVaZUEzZ3EzVGFqMzQ5dXFZYzRCUE14bU5KazF0MkNlWGFLOTZSQmxtZ0ZFbkI1K0Y4NTRJbzlIR2cxQWV4c1lHMTYvamZkck9UcnRWdnRveWM5MXV0WHJGRFkxaUE3MkhiQWt6MmNSM1dDSUxVUmt1S3YzNmlBN1NBV3VFVGlYWmtBekdTclhKRWhnTHJ6bDM1NVFoOU5KcnlUNGdvVUVEZTNjMEhqVlg3WFp4SlZCM0tNRG9JNXplZHJzdUtRTnh0WHF0RmprRDNmQmNnVnVBVDc5Nmh0czh6S1JSbzdZMW0wZ2xIMWVtbTlFUWxVRmwzcngrbldaOFBpYjk1ajBib3RaWEJpdURzZkRxV1Q5RGdlbXZWNFFCTkd5a085Vm9uSFc0bVl4bjhCa096endHN05GNHNjZFY4WU5YMFFLTUlmd1ZiNS9GZjlEZy9pQ09HNTd0NGRCeEFsZFkvc05QcEpwTkVSRmZic3FWNGJTelIrK1BzNVRESGsxR000azF6ZVFSRHlORzJ2MWtyemtmQUVOcXB0ZEtQY0llczlpVllWQk1JVExQZGE2WWwzUm9tR1VqZGpUenlwakJVQ3BEVHlYb01Cc0xIQVNpYVRZVy94NCtneFY2SCtkZlpzbmVMOHBoZUMyS2FRbmErWWxNZklmYkEzdmNEUGhMTmlSV0kwZUIwaERuRGkwb2c4Qnc2SzFVeUV2RjZJRGRuODNTQW96c1dqNERZWUNkQkFLQndQeDBBSEdLeHNKS29HVXc1cVpHUExUaGIvNFIwakpobUpiNkRLRlZXbXVKeE4wTUc0N2JZNWtNWDZpSk1CNnRvQTBCQm5hckJDTUJoWjJRM1I3NmI0Q3hvSXg3Y0tBeXpMTkhTQjUrOXBMb01XUVRxUmFWUVNaRk9Ld3Ntd2huMlVROGxrblJFYnRjR1N2QStMMW9KcEZFbUpFL0xKaFZhaElNZmp5OVl0emgzV1p5bnphVXlsQUtReHlQb0Y0MEUvaWhPQ2s2bW1FU2RKWm1tR3c2U3NjRGM4cFlvVFpKWmxFWmZpYjg1VGJBWHowcjVxc0lJMFZFR2hieWZVakRkM1JhV1Z1czUxdVZZZGd3S0pTaDBXam1Zb2swTjBNR2czOWJvYlZRMldTS1RqRGhETTNReWIrL1RWRnJLdU4zUDZVQkJrT25icjk4dUVVUGFsOGVUK1pnT0dSejNIVHJLTVB3ZFo5aFVnU1RPUmhrUDRIYUVvZ2VzOEVFbllGYUxYWDg5dCtzbFZyYloyUlpPaEhHY1owcEVNWjhQQkdIbDgxZ3lBYkdMaXJESlBRSWIzMmptWWhQc2p5ZXU1UXhYNlk1TEM2THp4OWxZMHc0R3MxbVQ2TGhHQlN0MzBFWk5OakloMzk5dUkwUVpWQzRBOXduajY2NGxOSzdESVpDR2VKNEtqTHVVR2dUTnR3bkRINlFuY0pNVERPWGdjOHJ4SmMzTW1VUW54SEpzckZna003UUNUK0RLT0xmUVJsaHY1OEZhWHk1L1JpaDVMY0ZNenZ4ZXIwUFVzWnNPb0RZUVA0Z0dBcyt3eVFvZzlmR2NtVllISllJWmhjaGlvRU1Jd0x4TVBJOWxJRTFQRXNHMjM2MFVwUVY3MklvcVpGSnpMc1Vxd2VGZ0tKVWh2UXlTeFRHUTJIc0xVWVQvSm9lK0VvYW0zcXBNaXpPZURhZGliaXRibXNrRlFXUktLTEpDc3JBYUlJRk1NRDQ5ZGRidDV0eWY2SSszbjcyZlFyeDd3cjBRdDRsWDB1cE0rTGJQSTFSTFl5bW4va01FY2JlV2pBSTF5M00yczBnRWZQR25sRzdKQUcxN01Zeko1bTR6NXFBa2pXYU9zb0Uxb2ttandEZ240Z3lHT1lXN2VURHJkMGQvMHg5L3M5L2IzMmZ4TnVDMllaakFZYkRwY1BaRGZ4VEthMWlET2JXS2o1alNXakZoWDE3SGwwb0VBbUVkQjZUYmZiaVd5ZUR3V2I4djNGMlBxR0o1RmtjVDZjN25XUjZacmFIdnN5eWMxa1dwdWNQdTMwWUdMcG5sNjFqekdVdVNsQkRFZ3F4Z2hvTFNRZ0tLZERFUkczYktLMGRyWlRHZ0ppaURBbzJVYkFiVWlBWmN0bERrYnUzT214ZHJKSktKV0QxWmQrdk5Fa3ZEWlB1K1YwU2dxU3FQdlY5My9kK1pmM2VqM1FuODV1Ym1XeDJKK3AwL3VFNlkzeDhZbnhrNHR1ZjRrRlVaNkFnZVNjbkFyaDJMc3ZkOCs1S3ozVzlEN2gxZVdpaTZPVnhxOGMyYTNiNkM0WDRWbjhhdlNCdUxMSDRvUEhPNzNyRy9BY3dybnJLRE5ad0dwK1o3cThWUXM4Mzl2YVdNa2s3ZHVNWm9CRmpjZStDZTVsTWVna1hrY2hrMHB1eFVEb1lDUHpodWNuNHhNVEV5TVNUVEFIQkNCc0dtZ29FU0xsMXJnQU1xa2NRUTJWQUpybWV1bHJkSG9kMUxicXoydWwwZHRMeEpONnpvWlVWSnZzSExabG1yaXJ1MjVWaExKMmZuNE41bXRGL2U4Wms3MUZPcUNrdk9xd0FnK05laEJkOWppdGxVS29MOUhpMkNEZUdJRHlPQlR5Y2owYlRtNkdzZitnWmYvMTYvRk9WZ1ZoTWpvLzg0enRRUmpqaHo3NkRzVVU2dlJwSXBLdDBrNnE2NGhxbUUySUYyY1pnTEU0dCtKZE9lVUVVR1lFN1hNcUVTUXNvMXdFVHpKdmxONlliRnIvVGMyZm0vV0ZNK3dlNy9qZzgrRllwOUdLWDR3UlJhalpiclpiQWI0ZE4wd1lMczNsUjY2ckhVOGNHRFBlQ1pkbnFUWlNpMlhnaGY2Mk1wNDhtUGgzRzVPVGtCTURJSWhnb25aeS8wd0plNTVZbUE0dHVWMUZVcTlGcXhrcHAya3B2Q01OdG5vcnZjNHdraVVBREJ0MTVGUXVGZG9LMnVXbjdOWTFCZi9VWjBQdjhiUTBTcm42YjY3bW1mTE1ZbGMyRU1wc1hxeDJhWnBBa09JN25XRm9TK1hYY1lVY3dqbjhsdWczZFE2anFnZ2V0Y3JDNHJkNUlNSjhQRjBJN2hVRTVIbno2NkJPVmdXUXhPWGwvY3ZMN0h4RU1xRmtpb0F3NVJUcEpYRWN3emk5ckdtRjFVZml5UlFVdVBiU3lHSVo1d2ZtOExsNmU1RmdPN1dqT0NEeVB6bmhwellZTisyQUNpaG1mQjNlbXd1R3dQd1h1WjNxdk96M0tOajcwbUdMSzQzWTdZR2JpczZKWFRKSXBmenFkTW1OWVlwZEQvdzhGQjhPd0xNZno5WEs1bm1zSjI2WGxHZFQ5L2MyeHFyUjFWVlprNG13UkxYWjJXd09wU0RRRGNmTGJFTVkvdi9uRXhEbytZQUhqODE5K0NnT014Rm9rS01zQXc0c1BZQ2p0YzFudHVYUlpwL1JHVzE4K1d3QVVGcXVkS093THRhcHhqdWkwT1FGdEtpaXdNUkt6R3d0d1VOaFBrNFZYZTd1VkNsdXA3TVhpcnB0Ry9EWXlBQldkTjVCY2k4U3owWlFQTTYxRTl6YVdOdmEzMmZwcFpnWERTaHdqc2lBNGxnZklhQy9vZ3lKWEwvTzBXQXhSR0NydzNrd0JERTFyWHlxcTJZT1dMa0pLaWFRS29mVlFQaDgweXZIVXMzK2hOZjRmRDJQSTRzN1kyTmdYUXhncE5DSkpLRUFEbW5LdUtGMUFvL2JJN3FXaTZZMmE1bjV6M0hNRERCOFpvc1VtQ3lqWUhNUHhBMTN3akZDSno0R0xRbEVBZDl1WkJwbm5JSTVFdE5OZ1p6MktYK2tpc3JweEVic3dScWR6dU9QQmJQRTlqcUZSdkFuY2FnQTd5L0RTQ1lpTnIzTTBiWmduVXl6Q3dUanBZSWZFekE2THJ1bHF0eUhMalhZWHhZa0J3eG5NaDBMNWJEUWROQjd1Sko0OUh2bDRZY0RucmxqY3UzZnZzeWZmb1RCSlJOYU1sN3FjcEJPRWNYNnV5Q3F1NHoxVnVRUWE1MjBkVjFYS0RRZjNrYkdpeE5UTGRicDJkSUNFRENqZ1pBVnVQV0NDUUprMlliYXRIZVN2VXJOYXJUWmJseExZYkNqd3F3R0RqUEc4TUFnQ3VNei9WaExZNGpxSG9ERjBUaXJ1aHJGK2pCZGJOSTlRdDA1b3VyTzB0TSs4TGRiTG5GZ0ZaVXlaZGFXdDZCcTZVWnBPV1EwWWtGOUxzYzFDY2kyZVRTQVlxY2lmSDQ5OHREQlFGcm5TeGIzUjBidlhNTGFNcDZDa0U5SUpXS2lpOXltWFJZZVNRNUdWY3pnRFJiTkFrUHJ3VEZFRUdQemJCbDFaVDJkZVZIZ2dBZHBnTXg1czJnNGxRbUtiRTQrYW9KbzZESTUrMjJpTDNIN0NqcXJKZUVlVWpMMDZHWENjcXNqczRNU2UwQlNNRHg0VStTam15Wi95WXFQSkFXc3B0NUgxVW1TK0loYnJkVmFzUmduTVJzbnR5NGFzZGJ1YWFuRmJsbEY3R2ZqcERVS0FVQ1NjUFBwR0xmSHZwM2NCeHNSSDBiaGhBY0lZZmZEZ3krOS9OT1lta2JYaDgzR25EdHdCaG9ZVGZUQnRWZXZLU2xkREN0RXRaOGd6T2t5T0wvUE5ockNmNnZYSWNLZ0QxeTBjOEljbER3WW1zUGFjRjVzNVEva3NoSHVkeXgzVmdFYmNoMkcrVFY1c0g0RWRvUENpRWFNVXZzc1hjMXk1ek9kRWR0K1ArZkRDSHR1cTBRZ0cvU3JWVDhaakVDNWx2aWhjcER6emR0QXN1SmtNN2trZHYxbTRnaEZJK0oxV1l0QjlLTGtWL3VHYlVYUjlJUCtSMitxdWNhTzhBT3MwZFBIZ3k2OGVmUDV6YWFDTXErZmpKSldVSWJYS0d0NG5WbnBuUUFNZHZ3MkdTaDFicDl6SkMwRml5M1htaEgwZXNNOWdKcnl3eW5MQTV6UkRZWE9ZNVJYb29zcHp1V3JycU5hazRUckxYT3Qxazk5RDZTWnp5alNQZ0NUNjQ5c2FVOW4wRXFFS0N4OC9aWTZZL2VBQ3FNY1UzbUNiQi9VNkkrV2VGd292S215UkJXRTAyWkRWNXJPQm02dTZrZlYxeWpQb3dnUXduRnVCRmN2ZzlXQm5jaTM0N09zeHlKTG9sdDhtanYrUEVXQng5NnVIdjZBU05KSzYvckxBbUtoQlNkNGxld0NqcDZMYm9jZ2FsQi9xc1hYQnZKam1SSVlEaDZmcHBWRGNueVQ3Sy81MXZuNFkybkpnbU1OZkVkbzVqcWxLQXZoRzdXVU4yUXVvU0dKWFNXeVd6RlE0NmVVSk1wbFdXNnhrcUhtVE9WbzVrQ0J5eEU3QmpabDgyRncvelVvQWd6NnFzbkFFcEs0NkxUSjdRWjk5eWdIRmhhcWhzNEhUVVQxbTQrMDJxd1VQT0NrQ05TeERNQ0xCdjQrTzM0R1NZY0xBY1h2WitUNkx1M2NmUHZrNWFDem12RkVHVE5iMHBJYVVZYUhRMFZGNXJoS3FScDFaTFI3N1ZneDh2bDduV1lIbjlqc1g2VklrRXMvc0ZIQ0h6NFI1WTZ6WTV2aW1SSyt1ditqUXpkZU5JcnIwazlmaWFSWllRVjVtWDc2bTYyWDJkWTNiSk5IdVVJSGZjbUt1eUFnaDNHUjRqcTlrd0dDYlJRZ21TTndjSkZ0aE85dWZ0WG5NaStZM1VHRW9LSXJsQVF6MDV1TUtoZHFzR1RDU3FkUVAzNDdlSDN0MC8vNzQ1TWZBbUJ3RXlaREZaMTg4L05QZlN1Z0x4cldicjVGSVk1ODlBaVpxUGRVb1J5SFhhcTRlQlJXT3hXMTJKRjlCUWdCLzVBZXBsYStzeDcwdXNBdTdDZk52RjVzSEhIZkVia2Q2Z2Z3dUw3MThlUUFsQ2RlNEZGWWo2RDIyL0dHelhhMlhtWnAwNkVjVGwvbCtsaGFLT1VaSTkyY1JqTmxqQTBhWlp4bk8rUGQwVXhKMjB5NWpvZ1l6TkYwRzFjSU4wdDBlai92cS9lQkJXei9TRzBDenRNY1B4dTZOM2JsdmlHUDhGc080WWpHQUFTd2VQdnpMajBGL01ESE1Kb09sV1FZTkJBTkhhUVJaaUVhY0RXY25EZ2RSV2dKdi9FOFpGUVJ3OTZBbWo0VjdtQW55YXVHdzJXSTRWcUpEL3lQc1hFSWFTYmM0em0yN2NhWmJwNTIrTmk2YXUyb1l1bW51bmFhbm1VWFBvcFltR3pjSmtoaFVncWprWVpBRVNTQkMzb25teVZUTW95cXZTekJGbFJpSXhFQkdtRUN3Y1RPTDRON1Z6YVkyTXpkNHU0WGUzWE8rcXJ4c2V5YUNpS3ZrbC84NTUzL085OVgzV1NsbHp3NkY4K2NUS0kyMVNsMFVRbGhlZmQ3aVRRTlN3czB4a3lCZFhLOTgxVUZsSkdVWVdvQUJ0S0MrUVBDdzJLWnhPMlhEa2hKYitGOE04RzRnaTE0YnJ6YzJWd2VuN2NqUFYralhuVTdYaSsvdTNidDMvOEhmTVZLUXh1UmZCTWtZaSttWnFabW5yOUYzQlVlVVllay9aYUcyWFgvNEFOSUVIaCt1ZTZ2b1FUZTEydDY2TCtjcENCY2dqaGJhWjRnWGMxbWpvTGFWT2I3ZVJHRmY1ZVpCQjl1TzkzejM1QVJkVS9PVWZ3OXhzaEpQWlcrYUFLTlI4UVlrR0M0Smh0dWlHQ2pqREpYQmNSMjhNUHRxbnc1ZVVrb3k2UHJGOXNmdklJdmZyL0dVQnR3UjJ6OTZDR0RzNG8zdzl2S1BMeDg4UWhxeU5MNnNqVnVGNUJzU0pETlRVN1BQWDRWeHdDUHZwUi9idmJPaDdsbXYvL3UvNnc4UUtMMGVtcHg1VmR5ZHRzMnJnM2tQMCtMQk9FTmhoSytRQ2MxVGlsOXB2bDduVzV6STdxbHdVVVNuMzROSU9RZmZjSHpTaWRqQWx5T01PaGFMaWpsT1lGejZaQmhiTW93OEtxUEdWUnNjTDVRT2NuYTlWckV0cjVvc0dLR1YxdXhlcTFYRHc4b0d6MWNBQzE4Ky84OXBzQXYzN3Y4VmpjbCs4aVFKUXhJR3dKaDYvUGpKczFmNWROZ0hOT1RwdUtYLy9JM05abEQzZXJZUGYreWlRRlpCR1p0R0c4UUlrNHh2cjZ4Wm9rbG9ZQ3NjaUxyVDVRdEJKYVdsK1dxZHIvRlFLSjBLekFoVUFpcmxTZmJ3c0hqUzJYRXNVU3NCQ1VaV3JPeklNT3hYbmVJSWpNczBnY0hlVkx3NWUyTDkwK1gyc201SjNxcGlraS9mR1p6UDFjOFpHOGdpNGN1SDNuNDMvZWdiSW8wSGNxRGNIU21UbndXSkpBeUFNZmNtUktkeHhTRGdHSWNoVDNkMjlaQTZEUWFTTU5RSmN3M0NJbUkzd3Zlc0tlOWt6cHZzNGVGRmtlVlM2OVJ5aUs5WHdTU2RkemxQZ0V4MkZ1eWx6Z25rZ094cHh4elFVcFRUazhFd3lZNHBBeE9vQkdOWjE1TmhpTm4zTnRMUktMU0RmVHNtMHdKNXhOZTBPZ29EY094YUhNNm9MMDJIZm53NThlMjNFbzIveVFYMkRoaVRja2ZTRDVLQk1BREc0NmR2a2trNmhON0w2WUNPK3ZhVEJXb05tUWhqSWRObzFhNVNDMlROTSs0QVdDNXRZcWZUQnVOUTQwV1JjVkVyNWFQemFnWmRRcVBsTmkyak50YjhmUFdNUDJUYmtqSVNNb3l4bkRFR0k0UTVBMDBYd2xDdURjNitWUFczUEpwdUtRT2Z1b0UyMkpXbWsrbDMweE1UQU9PUkpBM1pia3orR1l5aE1HUVlrRFRTN3IxUW5vaGpuWno4T0FyRG9ER1NHU2hhSE5XcVpZOW5PK2dBOW5PK2VEREg4Q2R0OU5PTkd6NjNEWTFKNVFiWXRNNVBXY0c5UlVZNytWaEQ1R3FnakgwOWFDbHhRR0JBRkpTY2cycFN6SEJTQWxVUzA0WGxocXNlTTNSY3ZiWTBzb1kwd3FJUFEyTTBxbTBXUnlCaEQ0ZjIzT2tYM3orY0lEUUdPZlRyTzUybzdEMWxGbjFoRUJoUFp1ZGVoNU1IZmpxTk9FQWNVcFFNWVF6MlFNS1BhanNJZGJXR1RvTXY3WmhqWE9hMGlUQ2FWZDdkbzdaU3JIZ0tZY05WMit5Rk96Ni9USzJFcjhRaTE4cFUrUlMwcmlzSW85NnFjZlV6d1U1R1hKWmtoZ3lKU0duZHBwYnNIN3NON0ZQUFJmN0luTFl0aml0amNPOE0yUkNBTTlrTnZTTVJ0THZ5OUY2RS91SGRTeG1HbkVQdmhrRlFmRFdTUGNkaGdEUkNTYk9IRHFYejRMOFM2M3BTckc3QmtNenY1cG90eldIYmppV1ZZelBOZGpXTHRxcGFiUUdNWGw3by9ydUNIZjdwYVpFdjVHM1VTazQ0TC9KOHNja25jUjFFZ25ISXRSc1hkQS8rc2VpS1ZicGNsdVhwSHJqUFJjWFdBZGVzQU53YXoyWTdQS2huU2J2MkJXWGdNYTJhWFVjaWFuZVZRM1RFNjArLy9mN2g5RU9FY1VzYVgwM2VxUXU1Yng5RWlRVGp5Wk81NXorRVUrWWRQOEVCQnN4aDJaVXM2RzFsYUl5YnlpMlBQTlhoV3gwMms0RnFjdGc2Ym9zdFdybEliUlU2N1hZV1IzWHQweTUzNVErRnpHeVZiVlZFMW90S0lEN2pGRHFiWmp0NzVmWTU3ZWtJZTh6V01pS2YzdFpSaWsxWGhHT3hOVU8zbitsMlNuSHFDOHJBc21JMTZCMkJxQ3VjVDlNcGN5RVZmdnY5MU1UMHc0Y0RHQU5wM0lZeDVqMC9nekU3Ty9jbTdFcVZkbEp1eElIQmd1cVFxOG1JTXZDWGNqTjhCYmFUekhWYTBwQ3lsbTJMSE9PakZKUTJ4M1JQcS9qVnN0V1RHeGJudVpWempxOTMrWndHWWVpVG5BZ3VySmF0QWlLbUVPTTd4U3pmS29xQ2o5SkJCeC81clh1R1BUNkhJOVp1aHQ2Z3RQTjNLZ08wQVIxYXd1Y3E1ME8wMitPTmVjSS92WnVhbWU3REdIb040a09IZ1RJNVlqR0dLV01rVEFERzAyZHZuRDUvTEJieEozT1lTVjMyUk54aVUwdlBFNnRIbEtIUkxLZzJraGU4aklMTUtyTm5UYkYxa1ROUTI5Q1pwc0JtMVRuczByT05lck54Zkp3bC9RVjh5Zmo2TlgvUi9RL2FiZTY0VWNHeEI3U2wvRm1YQmRjQnl0QzRXMksxaXg0Y2xmY2JFelpSd3hOeis4b3dtVlR6cXMyTnJYZ2k2Z3VYMHpsNnp5ekUvRDc3dTM4QmkrbXhwREdhUTJVZS9ZVHhPWXd4R3ErQ2RyYzNWa0FjSUk0eTR0alMyN0N3YXRSRFpXaXNScE0yUUNlVDdyMlBWekZFMHVsMHUxMU9jTzh1NjVTZzlXQUJ2dnQybHNSOU5nT3ZMRnNSK1lKTEpRMUNIYVdPV0sxZ01jYk9BeVRBOFN5Z2NsMVN1TnBTQnNsQnEzUDE4YU0vNlQ0SVdiU0t0VEVZWk4xLzA3aEIvR2E0bkUvbmtxbWRHRk5JMm45Q0ZqTW9qSWtKb294QmRiMEZZM0lJUTBvWmQ4Q1luZnZIcTBTUUxqQ3hIWStFSTB5U2g5Nm1sbUdRWW9JcmE2dWIrSTQwdTNGZmFNL01rTTl6VkNnYmw1ZHhIWW1hdDhkYTV6K2ZuTE04Q1gyZUs5WkZUc2ozOTM1ZXBobitwbDBoZWFGMjBZTFUwT2gyaE53Q3BWTW9kWlN6ZEhIaFRZVmNBYjBhcnpYVURzOGJsOWZUNExmVnRoV0krbHdTQ24vRUt3amVrTlArYm5acVJvb1NZcnR1d1JpV2xENkxyMlZoeURCdVMyUHUyUnU3czV5S0NZelpJNlVPTWpVUE9DQmNyS3ZTWEVtK3ExTkYzdUhscXNFU3Q2ZHBkNUlPeDFjVkNyS010RXpOKzd4ODUrYjBwRjF2bkowMXpzVnVoemU3VFAzVkFwMEphS0NXSUVTeVhVa2RIcGQxa2NLakhpbGJPUlIyN0dwVVdyS2FyMUJxMTRZSDBjTmZDeVkxTVZqMkFZcUNjTVM0ZmZIODg2ZFR0MkRjUnhnRDQvV25NTzZReGl6UXlDZGNTUy9EeEx3SEEzWDRvaGd1dXhzR2VibVZiTkVndTZXWEZPQXdsVmI5dXVYVEVueEtlYlYxZVVVWmpBaXNlRk90NG4zT1lqSEx2STlxUjliUlBvVVBZdGxNc1pqcGtpaTZpdVJ3UnFiRC9Wd0tyVW1sSkJlNkx1TEJka3F5Y1Z6ZSs3aGdNb0xWUk51TkpEQnRwdlpMd3BHd2t3dkczejVIWFJBV3c5SjZGNHpKeWM5Z0VKL1JwekUxa0FabzQvV0xhQ0w5UGlZSUpmT0JIK1dCK3hWOGVPc2M2a050SFZ4b01kaXRNcTlkd25jOVBBWVRuSlBDa0M4Y1FTNGhLNFRDZTVkMWZNVlZaNDBtOTJPTUlEQXhzeWNVTkNnV3lVZkhCeXFVT3BERDZFWnBBZ05lODV0cXpCTjJuOHNGTE5LQVlpOVNZSTZPWW43WGV2VFZzeWVQcHo2TGtqdGd5Q3dHRS9GQm5JeEpRNmJ4OU5sekVFYzA1Q25CT3kzczc4bUZsb1NMTTc0RjVzT2d0aHJKQlNmOWl4aEJJTXIvZDNjMkwyMXVXeGcvMXEvRWo2ckI0RUFjT1Fsa2NDV1dPeEh1SFo0NmNhS0lzUlFKb2tHTlVwUVFRU0htd3hpVGFDQnFRSklnT0t2L3c1MlYvajFuZW1kM3JiVy8xbjQvWXRQVG5sUHV5bWxQdFpxNmYzbWVaNi85dnZ0OVkyQVFEWWlIUHk0cmplSkQ3cUhjYUdhT1ZqODZOeVQ4NS93VXRKNHB3WFArZC9zajN1Vk83WlZHR0dMUGp0Z3VCNEMyVjdkUUVwZllYUUVJNFk5YzZ1Ymw1ZVdwM0N6VjNzMy9JelNtV0VoaHVHRVFEVDhZRmcydERZalJoVWkybEcxVW54NEJSK3ErZkVmeVFIMEFEK2pVejA5MlFTRmJiRk1YYmV2aXlsaCtUMGtKUzRiYnd6L2VDOVd2dSsvemFHNzRLRzY4dnZ4SlNJSnQ5ZHYrZmZWZzR5U3hnN01vZ0JBazBCK2R4OCtnaXZ0VzdXd3BpaFlaVXk3Und1Z0Zoa2lOZmc1RE9HVm1kbTZoV1RyTHRuSm95SnZVUGZSaExjR0QwaFFQQzZKRTF2WVBWdVU3YlB4dWJYRVRHNWsrcm91OThiUTFvY3NHSHI1VkJUY2tpUFA0eUdON1pSVkNRcHdrcTJVS1l2cTRRbEdrNFNmNytuS1R1OHFjVmFMejRkREV4Smd4aVJKR3J6Q2MwaEJPZ2VTWWp5MFdTb1dyWXVxR2ZGMEZ1N1NNWGZCWUtiMEZIYWdFdXBBdDNOUVVGNXIrcEc2aUxuZmZzRzBZcnAwWjdGMnk1SjVSdkxiZzAyWWNvaks1ZFF3TDg4UWhYbzJvVUZUYVFPSWlsd0lTTHkrUHFZdG1KZ09xbUEwakNhZEpHSXlnTDR3aENjTnBGQ3MzWnNJemMzUFJadjJzMEx3Z3Q5eDAwdmZsQytoTUJaQmFpVTVTSTVSVE1jM3NKL0dld25GMkgzWTJSQTlSQ0l1b2ZTcHl1elR1VkFBMUpPbGRHTmIyZG9uRkxla0NVTFNGSmpvM2dPTHpUZld1WGE5bkl3dUFZc0toaXluQlltQmd3TzR6dkdBUURha05BY05vWTBKckE3d3lGN3ZDemZXdGNocmtBZkdSRnJOTG0rU2hyOVhCWTJJSlVTZTdHd2VybUtZZmVucXZWa3hQM0wrV3hET0VSMkJCNlBLU0szRVF5TUV4QXNGakZkazJicjlJNCt6eDllVXhEYUtvbHlwUlFERWRVaXdtcFM2TVNiUkx1c0tRczZ0TlEybEQ0Z0N2ek0zSElzQy9WbW1VMDA4d0VUNCs1YSsvME1xbFVvQnBZT2ZvZkc4aktkNkJCa1NOTnpZNVZHY1o5amFPdDNDUEtGNmhKQk5SYjVuRk4yWDlJQ1pqU01ldGZUb0poTGRFT1QxRnVvbTlnKzFOaVhNOXZwRzRMV1d4NWE3bVVSS2dpWFN4VmNuVXNoRXd5QXlTWUxwd3NVQmhlTUlJQnNYbUZDME5Nb3J0Rkk1akJ0UUJVUnJOMXV1bFFsdndlRVFlMUtzRERsakdKZU5xRzhyNisvZytaUDVacVZTREtyR0x2T2dNREYzREF6UHlpbmo3czVYVnJiWGRjN29uREVWQ0xRTlZ3OHZrZHM3MzQzaVFnOTRIZkhQbDVMYldiaFR2VTArUGdrU3EySGlHK1hocE1RWlpFWnBnc21EWnlWaElHTUdnVXhtYUJzRVlZTEZCTkRRT204YmN3c0xkY3gydnRyL0M3SUpHNlRNa1NLN1l1S3JVTHMrVHk4WVI4VFc2ZHJCT1BIQndnb3FPbHIwMWJPSlhrbmhUbVBNandGQ25MNFd2TE9CK3B3enVBN2lGem01ck93Nk54ZTRSU0FKQjVKL0FHd1FpZHdmL0p0Z0RTTXpQaE1PaDBJUUhDOHNqaWtVZzZLVU1Kd3pTUnIrMGlrNk9DWU9Ed21NaEdzbldMM0ViWFF0ZkpWVEl6Vk8rV3I2N2VzNUExNFJUeXRiVzJnbTZ1eVNTSDZ0Q3Z4ZGt1M2FTM0k0dnYvK3dlYkJMTi95QS9vbjZCbWdjZE1GSEZmcUdUS0hTYkdFdlFjNTRBWDlDTjl4b1oydWx6UE5pZEFIOGdWSEJaVEZ1TE9MUWhSQ0dnV0Ywd1dFd0dsT0dodHNyVWgvUmR1YjBDSThyVlZxZ0VOeXY5UmxNMHhGZENLMWhxQ09DYW1LMW0rMDJqWTk2dGN2VHhNWW1YbWZ6Zm1YM0VQS3dJUHJJWnZNS3F0VnFOYUR1b0M0dWl1V0hYRFdkNm1DdkxrQjAwZzkzcmVkc3BuUlp5elNKUkJoV1VhR1FiUkhKZ3VjRk40ay9ERXNhaklZV2h5ZU8rWVZZNVBuMEpMbTZrYmpNTmh2RjNIV2VUSU9OU0NlVnJ1YStQSlRMeGVKRjhRSUtCb1lEYkxXdXhOb1hBbVlQQWdPK2w0NU5BWVFXRGg4R1g0VGhmOG5sN3F2VjYzUXEzOEdnaGhuajYxZkVjSTFyWnhBRXFMSmVlSTdFZ0FTaUNJVnNGSUtGTXkrTVN3SUJGcUFjaHBTR29zRzBJWEZNdW5Cd2ZjVGVMWlVTRVArSm5iTWFUSGQzeFlkcU9vOERJQ2lQTnpkUG5VNG5uMCtsMDlmVmF2VStCMnNUNEhOSDJnRUhVTGZRdU1PWEg0WVBvMC9sWWZ4UE4yQThlZ2JTQXMxYXVZc1dVSUFNb2Z0dUxTMUdZMElUSVh3NDAwSzBGL1k4MGhVR28wR3pxeTBPb3FFbldRdkh0TUl4Q3p3SVNDUzdzNU1RdDlHN0ZlZHVSTjZyZXNSTWdYcDZrbWhTcWZRMUZMejQxMmtCZ0FoZzlueldFRjZrSzY3TERYRGt5UUZtN1I2c1U0MGtvTFJCSkFyTlF2ZGFPaTlZZkFhOCt3d2ZHbVpXa2NraGNZUUVEbTBYb1E5MFRDeTYrRnc2UGQ4NDJGNyt0TDEvY25pTHMwMjVtdW9JbWJ5WTRlRURmK3RTRkQvNTlQMERKSEpwNStRZ1RwZFdiSy9WbHlLb2lEa2dRVUZob2JBdDR1RVIyWEQ1d0RBelNwK0Y0NDBsanZGeG5xU0tSOWp3VUVnV0FFaTdkTG03TFhhSmZ6ZzRnbGZ4Q2t6dzVaN3NyMTk5VWVaUDhtUFNUaWVQY1lPdGZ2TVpraVd4dHJuK2NYMzVlUC84OWwvdkFNVGM3S3pDUUNCWWx5VlY0YktJbmxPSGhyeGhhQnJ5RUEvaGNNNHFVMHdjSEFmbklZR1FZd1FSY00xUzdlUjQrOE8vMTVkWDE4N3BSQjhkZk1Gd3VNTXdoWXpFUkczUXJFRVRScGsrQlZIU2tLc2R2S29XR3E1RDJwVlZFbnBBWjJCSmQwd3pFaVlzbEVNc0ZvTnVGc1BEWnYvME1INW8wNUE0QmoxeHNJbkZnMGVZS1lSY014K0wvZlBkdS9aU3BvYWJybkVKZDRZTlZRbWJEbXk4U25RWWRTT1pQTjZGWnV2czdFejhwU3BxT1o0WEZ5T1JhRFNHR0VBUHN3S0RrWVJsRDkxYVNCSm1hZVppRVRBc3JKUE9BYXNSSFZMWllkWnRhbDZ4Mnc3bUYwUEVjbzMwRFdRSmhrazBHb2tzTGk0dXRiUFpwVXkyVUQrRHhqS3h0cnFNNjlOUEt4dTRWL01VYUJTeVM5Q1dhQVFMa0ExekloMVVUWWN0Y3poSVNIK0lzTkNyMUVHNUlCa0ttbTZMeThJTnhFSEQzWFM0c3RRV2lDRXlJMlV5T3lPTWcxTEJuZ1JxQVNzR1ZZNWVBSndsVVhMME1Id2FQeFFob0pKZ05RWVhDWmtVNDNxeEx2ekJIV0wxV2tIZm5UdE9kVWdhZlZvYnJPc3dFNjNnd1IwamlNaFpSc3RFeXlVczdTTXpoV3FlNktpYW8vSGpReEdRTXNCbjQySEpyTUUwWVZKVCs4TnVMdm9zV1h3YkRKTWNLa24xTVIvaVlicFNDWVFwUkxsRy9lZzBEQU5rUm5sSTBLRVB3dUlEVjAzTC82YW43VW5ES1FndENZYUNpY0xaYVBVTXd4SUhuMWxzZVFBUWNveU9rQW1iQ0RXRlRpenFseGx5MlA1TU9Hd2hDRTJMMXRMNGdvZUVBS0duajM0V0ZiWkJiSXYwQk1ORWgrQXhhUG9PenNOTU1Fb2lrNVpJaUlvRXcvWFN2VUtxdFE2SmJ6WlBOaWIxb0RNQ1g0NFJtNFRMSDdybk5Mb0k5Z2lENFhDMlljb3UvZjFhSWN3enlqVk1Kb0xLaEJwY3Q1cFEvNXZRK2Nnb2FEMllqSkFjMVB6QlVaaUcwOFhpVlJqRERoaVNoclB2RUYzNnFJNFBRMlJjRWhFempXSXlaalBoY0t5SFZ4a0dITU9rN1F3TGhHa3JPQW9IaTBDWEN3dXNSalFZY05QZ002MmVYSVJBTkpJUmZKQnF4eVVVTmR1b2g0RWpIbG81WTJMWTVxR0hQNGJmYmpQUWdoaFJGTVRrWVpLQ3RWaW0remFITDJpQTNXRllQRHh3Y0xjSUhnd0k0cEE5Q0hlTk1jNms1dkpxVFhJUlRQS1FCQXFLd3dqWGc1YkVLQ2VoUTVPekNBWlkrVjl5WWk5VExMY0UzZXF3QktKblhKMGlrZ2lUQ2VxRXRPTEE0MTNqVGdiakkzWStNQktqbzA0U0EzNGtIQ3k2WHFuSFlUaHdtTlpqY05ETXRpN0hXRWhNdUlvSjJJRGhkSVNieHBrSlhBQWNHS2FZTlRRRjkvVGh3Y0ZpOGRyMUpnNGNIcE50bjhIaE1veURpTW5XL2hHcnhpV2NjZGZvaFJFc0JFd0tpb0t5eHR0UkM0VWpNNGRjSFpaZHIxK3pONnlXTHY0NFpHZkt1akhMTVNaV0paUitxM0IwSS83VmIvMlpBSEF0S0FxMk5kNG80em9pMDRPRVdwY052NllMSHFWdWlYaE10bGFFcU5kbjFNbkVJWk1lYXFwZklYQkRNSW93VFNZL2NxTlJlSkVZN3YzK0dhd0N6aVd0cXptMWdEQWlCZ21PU1hIQllickhMcEZOR1R0b0NEWUl5eGlhQkFzS0c4VDNEUCsxeXhvZHg5R0g3QVFaR0hBaGNZZUpWb3I4NDF2K01GL3c5dTJVV3dnOEtHMXIyS3B3NWNTUGd1QksxcUFIRFphb25BbW40dEFKakJJZm8rNlgvZTJvL0ZzMWZBc0FoMkN2TzN3WEg0RWZwd2kvYWNhZEhvYUluMDVHZTYwM2ZoekU4dys2T2t4MjdqVFl3NlR4WjJFRVBMcFRBdEpIUDZFSEZScU1jM0NPb2JvKzRTNkx1QWNKeHlRNi9KTmcrRGJzZHFMMmVRakZIby92UUY4YnU5TVZqclMwTTVQUElMLzk4UEtZWER5QnVMVFNOK2pMeFQzd0xpRG91UlFBYnhMc2NQZFBKT0VOdzkyMSt6Sng2MFZZcW12MXVjcCtjcmNnREF5YUFIOGFqTmNUSk5nVml6ZWNydVg1RE01L0tPRHN0ZFhwb0IvYVcvVFdwUWE5eXgrSUE0MkwxamR3Y0M4Ni9pb0MzbzRKK0ZVUGNQenI5ZEZ6REg4UERHZXo3Zy9GbDBqdys4b1h4SGV1T1g1bWlBeC9xMEIrRElsaGZQd0s0L2VHMGMwNHZiTUpCSDJmU092eDE0UGg0WnZYTXVWN3l2dWYrTzBYTGZmUDlpZkorQTViZitMWGhmR05SMFYrQUl6L2l4cnVvZjdxbisxL0NFNU9wN1A4SzNRQUFBQUFTVVZPUks1Q1lJST0iLz48L2c+PC9nPjwvc3ZnPjwhLS1yb3RhdGlvbkNlbnRlcjoxNC4wMjM1NjkwNzU3MDYzNDg6MTkuNTMwMjg5MzY1MDYxNjktLT4=";
  const util_menu_icon = "data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIxNDAuMTc2IiBoZWlnaHQ9IjE0MC4xNzYiIHZpZXdCb3g9IjAsMCwxNDAuMTc2LDE0MC4xNzYiPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0yNDkuOTEyLC0xMDkuOTEyKSI+PGcgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIj48cGF0aCBkPSJNMjUyLjkxMiwxODBjMCwtMzcuMDUyIDMwLjAzNiwtNjcuMDg4IDY3LjA4OCwtNjcuMDg4YzM3LjA1MiwwIDY3LjA4OCwzMC4wMzYgNjcuMDg4LDY3LjA4OGMwLDM3LjA1MiAtMzAuMDM2LDY3LjA4OCAtNjcuMDg4LDY3LjA4OGMtMzcuMDUyLDAgLTY3LjA4OCwtMzAuMDM2IC02Ny4wODgsLTY3LjA4OCIgZmlsbD0iI2Y1NTQ0MiIgc3Ryb2tlPSIjYjgzNTI3IiBzdHJva2Utd2lkdGg9IjYiLz48aW1hZ2UgeD0iOTY5LjcwNjc0IiB5PSI0MzIuNDgwMTciIHRyYW5zZm9ybT0ic2NhbGUoMC4yODk5MywwLjI4OTkzKSIgd2lkdGg9IjI2OCIgaGVpZ2h0PSI0MDIiIHhsaW5rOmhyZWY9ImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBUXdBQUFHU0NBTUFBQUFoUGcrU0FBQURBRkJNVkVWSGNFd0dBd1FLQmdZREF3TUVBUU1LQWdJRkFnSjNkM2NEQkFNRUJBVUJBQUFJQWdJQUFBQUdBZ0lBQUFBQUFBQURBUUVBQUFBQUFBRGIzdDRBQUFBQUFRQnlPVDhFQkFTK3ZyNm9xS2h2RUJzUUVCRE96czRlSGg1bER4dUtpb3BpRVJ1NXVibFVFUnc5T3p0Z0VCbVdscFoyZG5acWFtcUdoWVZISWlXenM3TjJkbmJjM055TGk0by9GUnBMSVNWTFMwdFpFQmxpWVdLUWtKQ1BqNCtibTV0N2VucUJEeDIwdExPbHBhVnJiR3ltcGFham82T0FFUjI1dWJuLy8vKzRFQ1d5RUNTM0VDWEpFaW5JRWluQ0VTZkdFaWp0N2UzNCtmbjE5Zlc5RVNiRUVpaXRFQ1BCRVNmczdPeTdFQ2EvRVNld0VDU3pFQ1RxNnVyZzRPQ3FEeUw5L3Y2bkR5TGk0dUx4OGZIejgvUDYrdnExRVNYOC9QeisvLy9sNWVXNkVTYlUxTlNYRFI3djcrL0xFeW5MeTh2YzNOem01dWErRUNiZTN0N2s1T1RvNk9oY1hGek96czdSMGRLZ0R5SDM5L2NDQVFIajQrUGEydHFkRGlCZ1lHQ2pEeUd3c0xESXlNaUhEQnVTRFIyOXZiM1kxOWVhRFIrbERpR29xS2g4Zkh4dGJHeFpXRmlzckt4M2VIakF3TUMydHJhUmtaSjBkSFJpWTJPa282Um1abWF6czdOTVRFekV4TVM2dXJyRENpTzdqaTZJaDRpQ2dvSm9hV2x4Y1hHWWw1ZHZWeWRuVVNkSVIwZGdTeUtNakkyYm01eFZWRlIyWENkUlVGREFreStNREJ5Z242QzhDQ0VVRkJoN1lDaFZSQ1d6Q0IxRk5pQkNRVUE1T1RpNkFoZUFaQ21mZWlwK0NoaXNBQk1sSVNDMGlTeXRDUjJZZFNxdGhDeUthaWp0ejlQSkNTaVRjU3JzK1BpRmFDblVhWGY0NXVucTh2STNMQnJqcjdYMC8vNm1meXJQVTJLT2JpcHRjSERaajVndkxpMi9IU3pCQXhuTVBFNjVheXNiQWdXMEFCREplNFhISXkxVFBSUHR2OFhsN08yOE1rUGtuYWJJS1QzY2Y0ckRTVmp5MnQyOGV5M0JRU3EzSkRaek5UZG5VRXF5R3l6UEVDamd4TWpJWVc3Qld5ekptQzl4VXhiVm9xaUdKQ3k2TGlnMkJRcUNZUnUyVkNtVkhDcUVORFJvQ3hhNG9XKzhxb095bGxqaTVldFNDQkhYME1DZmhVekZ0NVo4YUYrWGJ4bTVuaTZEVEZMYTMrVE53cXFmajIrbmNYZW9VRnVtUEVrUTYrMEw4c3FhQUFBQVAzUlNUbE1BRGhzeEZoRUxBUU1IT0NGUFB5WllSeXRoREdseEZuc3NwTitRWGFqUUxKVzBoTEsvajN4SzUxckk0RU9yYm52SXE5VHcxNzNEN1lMUHFmRmo5dDhydUFzSkFBQjZMVWxFUVZSNDJ0U1lYV3ZxNkJiSDl3dXpPK1Z3cmdScFlZUE1SYlY3T3IzU2xuWlh1aTl0YjNxamJMU2xwd1JSOFNVeUtLS2dvUFV0YWVvTEpCb1FJNEtjRzczcWg1QityclBXZXZMRTJNNXdEczdlWjJiK3B0RzhaLzNXZjYwbjZaczMzMTliSUlmajdROU9wOVBoMm5HdGE4ZTFzME16RWkzZzkyb3pUZzZIRXcvK3NJMm5ldlAzMWRiMlc2Y1RvdktnM1A2OWs1TTl0L3Z6SWVtSTVEczZPclYwaEJOYmYzaUUrN2pkN3IwVFA4emg4UGNlT0pIVDRmZ2I4ZGh5T04reDZQMFl4T2ZQYmd6cStQUHg4ZkcrRDdTUDBqU3ZCaHFQWVZJdHNaOFNUR1BWTy9aNnZmdjdYanJHNXp1RXc0L2hQTHU3dXllb2p4OC8vdklMZU1qcCtJdDVCYzM3QVozc2NyMTdEd3crdVRIKzQ0UGpmYTlYa2lBd1RWUEg5RlZyeXMwYXFrbVNaWmpXUkt0cnRJOVdnOE1BRUJJYVM1SnVHRE1kTkZPcTdYYjcvUHo4NTU5K1FpNSt2K2Y5TzllT0E4dm9yMUJFNEFVd2doc1JRUFpKdFFNSVJXdktHa1JNQVRkbE0vam11bDR1TXhhTUdOZUxaVTNWWjdveW01MmRGYzhBeWptVTFlN2VIaGJTTytmMm53ZmhMVUx3Zk1KYWdDbzRPRGpReGhyZUxUb0FvcFNIeStWeUNGcVM3b2NyeVh3dXkwUDV0ZXlHTWZjZEx1OUJNQnNPbXdpRTdDS1JWMlpWSGFzSlN2R1FOUmVYODhQVy82OHN0aDBPZEFOaU9EN1kxOURUbUZHNDQxVzRHSWRkRE1oLzB4RDNXUTZYeTllSDBzZmNRSVl5QzQ3TUFtVUlaQ1RKNi9VZGYyWXVjZER3ODcxaGJBTUhxQW0wd3NGQlU2NnRKWFVWQWViU2luN0FQa3lQb0lIMWU3QXUzSWtmdzc5d1lodE5MVGx2bVgweEpOaGtKT3E3KzlCdEFZbkwrUjFoYkgxd1VYY0FQeHhvY0gxc0NFTXptYlkwbWtFTWJMR2JlaUFWQ29VSEx0dlBOVDMranVpRUt5cjNOandtRXBXMVhTOEFJWSs0dm4wbndTSGpMVGppME9lRGNRRktZc2tUaEJaWStYOHRmaXRncnN6L3BBSjhNb1hmRW9QRVdkbnN4R2pJdkhpWVRhQnlETi9SbnR1REEvQzM5TWlQVG85L0QwanMxMkNRUUR2Y3J6VUFPNE9ITlFZc09xWjZIYWFYbXRSL1IzUUVUVFpPakVuaHBYMllWNmhtVm9NekFZRXU0anM4OGJ0KytGWWtQbENUOE0xMHRTYmZEK3c1b2VEeFl3Ky9ZSXZlREpnMG5VeEozVFc5V0RUWFRTMU5URm1BVmxCc2pubWdtekxkeWg5WllBNWxJeGxWM1hmbzlydSt4YlBybHRQalBqclQxZWI5b3owYkx3eGdsVUI5blFCQ1dFTXdHc0ZrQ245MTJZeFdzdTJqVjZ3c0ttdEVWcFlqT25SdlpwZGRXb01henBzMVNhK2VIcnBkUC83Ulh2SE92M2U4RDdWeC8xaWdpNzRvZ2JYNHdmTTgvbFhzUFBEWFVkVnRlYmFTYlVab1ZwVEowazVueWc1ZnU3QjFHanNSaE1LS2VTaURRL1o5UnllZVArSU9kSVZQSHc4emNBdDF1cHd0SS9ZSytLMEM0SDZubTJjYzRVWnR6WTUxTzQzUG9jYk5CZk9KSFlmT0pUWWs5Q0c3OUxvelRGYThqamhhM2svNGFJekhGeDZHbW5GMjVOL1oycnh0dWs5bnRjejBwVDlmVVppK05BSEJLenhnN09hWVJ3MU5NMS9KU0JJWFBDN0JBNU5PSDRuK3VHQWYzSk1PUWxZMVFqUWtRTUNuWHVjSjRNek51eXlzaUt4cU9sT1FwYk5kejZhUFZ5NzNxYnFjZEVkZHhER3hHaitId090Z0RtSVFwcGlmQXViZkd2Zk5SMmQ0Y0RabXM1bWlLRlZVZzZsSTZoUTdxUFpxam10aE0rMWFoV1BnWFdSbUdMck9RQUVjZEJBODVOd1BIaUF6azZuVmE2YlRkU1NycWdZYlRldVBtdmZRODJHamR2RVA5NmsrV1l5NkwvbzZwMkJhWWM0eEFJWEJQYjZYSWdDV2VFUmdNQWdNQWNYT2dsNnBEeXFEV3FRZSs0TGxmaCszMnVCWWVHWUdjaGtUbFNZaUtkUW5OcFBZKzhxYW1lZmRZZWYwbjV0VXl0YW5uNlh1V3Vzak81Z2xNV2NhalFCRDRaR2NZRDRTODVkdWVOMXVGRm5VSFFvR2t6d2pFU0FTcHQweUM1SGllUHJJb3Y4U0dESnFGeHRWUEFlM0NtT0NMYjQrNmJMMDJEeFN0Nm9hN240MFVrL2RyZzJNNFhTMzVlZjVhaWl3eGdlT0FleVFRUTdjRGRnTE9JU1YwVTJYcnduV0tPUVdFMFMxZ1I5ZU9zeEE1ay9MRGxXMnNjTlJBYUVpNTR0R0dYTWlHU2liRVMvYmlhMjV3Zkpva2ZFZStUY3d4czd1MllNSlkvVll3QjNSbllJZmxySkpnWlVGdGdXbDBlaTArK2h3VEorQm1XTzlrbm9HeFU0aHNmYkFrODZ0d0dKa3RjRklzS2JCZllELzQ1bWgzOXBVVk9pU2ptVTVnMnBIeFNmRGh3eGFaRDVhV2RveWRGYzcvN2pCdnk5M2R2dURwOFhJN0k0TXhBSTBIMDB5RC9kRFBrU1kvZEV3bEVhNzFTdTErc1dxd1FZQnFoVU9ZS1dpS2Q0NTBQOXdZQ3dtaW1JMksyU3pXZmdoeGtvOUZMVVBDTGxSVlZZQlMzVHVXYlhkS3NHT3ZSWVJnVDFtUkorMWt1RWdNOFVibmxQSm1DaTY4K2ZKYkFNWWI3WTh1N25aL0hrQkxKZ1pFQVMwMDNwaEFDRE1jZEw4ajV6UzZQUmJjT3ZsZHRHMEE3TUpOWTBPci9yeXFrdGFmUklnQUFFU0loQ0ZTajZaU2dlaTBjQlZPcG50bGJGVnRCaVdjci9Ub1pETjdqbEdIcDF5TDRia2tCZ2l3ODFzT3pxa01Pa2lENTdOK2VKNW9XWTNnZkhHYzNnVHJ4RU5odUw1ZVRHcVA4cnNMVm1sL3g3b0J2V0hkcjhsVnZKQ3JLL29rQlhKVUlwdENKclNpbU5DbitXK0Iybk1Da0tsa2tkVlFMQVFEeWVDVjhGRUtsa1JJQ1NRbU0ybkFoZGZRRitEWWhFQ056RGlVcmFTcjJTWlcweXJLTG9FTnpIV0d5MFJ6aWFJSmVRRndJcFZoU29LSldseVlZcFpuTE9VTHVhRDBzVzVmeU1ZZDVjOWFmSU1FQURFOC9OODhyaGsvM0VqRkpMQnFyZGQ3Z254WkY1c3RiSHpkVmdpUzcyU0lJZzlORUlwSnVSRGlXRDArdkxpNXZiMjl1dlgyNXVibXdzUXptNWdHZUsrdmJpT0JoTjM0U1JFQlpXU3Y0dGUzdHo4bXV6citFRFIxTWF6VGtzSTNTWHVRcFdzR0lzQk5HSkNmUWxLc05NcXdSM0VjVnVKclFZZTJGM0FJd0JzbU9rdXpCaTZhamtkM2hCRzd0ZXdhRHpDcVo0UXhhQ0dWVEhHSHFXTzBhR1UvcElJb2NKZHhscVEveDdZWE1qR2V2MU9vOVByRjl1OWJENlhqa1lpa1dnZ21FNkU0eGlyeUdMcGdRdGkyQ1N5V0JuaFJEcWREZ2FETUU4blVxbEVNQkNOQk9JdFJWTGhPVUxXakhZcG53aEVyaVBCY0Y0d3EwcEFhOEcxd0NadzNVb3lsd3ZGY1EzcklzQ0RobTM0MGxXNVBrY2MzWUZVU2dRcW04SzRFd1doTE5VQnh2UmVvNUVUQndaVjFSWG1BQWluY2hjTmhBVW85bmc0RjRic1lBZHR6S0JuS0pMVUVLSzMvL3J5TlpJVGV2M0dUQjlyK0lBRTd3bldTOFRqWUltdjJXTkR3WjVURW9WOExvb2xjbk1kRFFTdVVtQzNEbFNEcEpTRlpEb0FqU1FTdlVvQlVhZ3ZFbFljV0NLUG5vRHFDcVp6U2F3WUJGSXFkN0J0VjZtckdtTjVzbGhNcEZZbG4wMXVCR1BMdFJ0T1FuY1RXNHJhYkdvcUh5QWxGVnhiWnQwL0srUWlrVVE4SHcrbFVya1F1eTFZV3lsVmRiMVJiT1V2djF5R2VrVjgvUy9VdTlpL25wK2VudjY5cGlkdzNXTGVyYk91ckk2TmFrc0kza0RIdUxpOGprRHRKUEdVYUlzSUFFcmZoZUxRYitKNXJuZ3loRXJpbW1RcWVKVk9zWVVLTkpoMkZibzNINXYxc2FTMFJNQVUzOHdaQ0VPRUdoUWgyKzBHZENVY05oUmRWWlZlTEN1U1R6RWJlVkZJQnFPQlJDalBzcFVQcGEvVFlya2wzRjEraWNZYTZtQzZlSTNnbFpBSmFUR3ZONlYrNWVybTZ4ZnNKdFJKTDlLaGRPQXFtSXBqbTR3SnlYQTRIR0lRa2dRakJVV0dSWmhQM3NHUHUxUU9ONGV6UUFQSG9EWU00ekFJd3ozM1dqMHh0QkdNYllBUkV0bVkxUyt6Y3hiYkRiV21seXYvNGRWTWZ0cktzamdjcFZ0S1NaRjYwMUlXNlVWSDNWS3BlOUdMTEdyYkdHTnNSbzhNWmhKZzR3RnN3TmdZTURZR3h4UEdLUndaakJUaENFRWlvYkNvaXRqa0g3Q3lyelVrTzIvc05SSXRaZEhubkh2ZmlKMVVES256TUNGZ2VPOTk3M2VHZTg5aEpPQ3hqTmdMeWJSOTFPbVpwUXpCSDFZd0dQU01kQTBOamEyR1g1SWFwSHNtR2JCMURLMnZvWVErWXBMQkh5OHRMZUY3em81S082R3V0aUVNdDBSa2RqY0dzUlZ1QnRKbmRIN0E1L0ZNVGs3aUMyMXVidExqZ1p3MEdkcmRuWjR6UXVTeGVURHUrQmJLSjZDRk5Zd3FyS0JKUXhxMmgxcHlrL3MvaG55UXdBc1p2azdDd0oxNVhqd3N1RzF6N05FRVBkM3p4ZXl1b2RzejRIYTdaNW1Ca04yZWJycUhpZXk3SlRKMmx3SUxmeUpWeko1Z2FRTFZCcVlFVURGR3lrb2V3SUNNNE4xdlBteE5DOEpvQzRUS3hReTlFNHFZeldqTWc1SFdKcHFQekdid2hWYkxCVGZFYXVjSVphNDJaL0lrbXM1c1l2VktKUThFMnJWNVkraW5GbGJ4UC96MTMvOE5UcnRZcG1LRlRqWmJMaGV6MFFYM2JCQ2ZoczltRExqMkRuZWR6dGtCTzFvUURiUnJkL0liU2I3a05JZ0hkNGV6dDYvQ3BUMml3ZEl3aEIvTWwvRGNJZkppSm53TFFQeHJZeGczUmd5ZTBQUGlxMmZsVlZaTmxUUFR2aEZtVHFqTUJETWFqUVpQYk9jd09qbldGZWdHRzRIMEZkdUVLOTVMVVlpRzdKZk1GTUMvamJzLzNtOWwxZnFuLzdoK20wOFhuck9xTDN2SU5sZTJEc3ZKcUN0bXg4cWh1eTJZUEZqMU9PMUJMbGxJc3FFQjIwZ1g2aHNVN2t3WGp6NjhXWkxibXlWRzVJeXRIR2lwdDUyaWpYMjI5TURxSFpDbnV5RU56YTVsVHJJcFNJelBzanU0RkN1V0N6RkQ5OFJFMTlnUWxDWUNFcUxpN1BhNWRuYnNGR01DTnZkOFp2TmdieHZXOXVDUFVDY2VRaVdJVWx6NDMreFBMUzNoNy8zbHliOTI1MTFSS1BhSVJSRjNRdEhQUzF1NDVaeEp1Mkt6TnBzN25mYUFOSTBrVjJBeEd6UUV4dERiU1Jwam5yWGtEdFNCK1djL3YrWFJRMDBHMlFnWlpTK2IzSTE1akVhM0M4cTJBakRaM24rR09qa0xiMjBCc2V6bXJ0dlFQZUtaOVhtZ2ZBa0V1Z05RdG8yTjBhbUdKaVozQzJ0enZ0QUNwUEV5bkhMZi93cFg3ckNlTERFWVVNaTZGdFlPL3Ztb3BaMnVoMzk3L0RrWkxhQ1hDRXRrVmllQTVSTXBWSHBoSGlKOGFOSklCb0hMN3A0YmhUUkFzcUJTRXk5MHpHbGZpT0lGbHZiRC9pTmE1UERVQVFYTU8yWVVTMHFITzlHRldidDdPdjM4WkMrQi9QQ044TU8zL2x3dXNYVlFtTFk1blhPeHd1cmFiaVlhR3cwRUVBVWF1dFBBR3VTTXpHYTJpQmlPMk00amJyMXlaWUNmd005WFA5ZWZQbXhwTi9qaGs4ZlY2ODhuU1Fwd1dXRlhpYlcwSUJWVVNzd1prMUJveHV3K0tCQzduUjVEbHhUM2JNRVFMU2ZTdE9xa3JKOVpXM0FWWk11dExGL2M3cXhHWGVoZnpxQXJBM3JJKzJtRlJTaElPMmMvbHc0eWtDb01ucUFyZVhDd0NuVk0xQmFBOHI1cjFERHBSakZBemdjbnJ1eGpTU2QxcHdoR0tZV0xoNTFrOHFSNFhZczhiVkVaVHg3LzhrdjFlZ3QzYkNSbFlMTTRMK3ZzOFRQaGNocFM2NEFOcW0vbmFHQnNkRzRodWdyeE1GWGFKM3J3Wkl1SGU0ZWJJWVExQk05eUZIM0xoMkVZRnlLZ3BDNkRmYjVRM3NwaCtmL3VEUjZVYmVGNGQrWXZabUtHb2JhSlVhTnYrdm5KU1hLem5OMEJUMHBIc1FDQzlVZUtPaGxzcTF6YTdzTXZjb0l5c29lZnIrdkh4NUhXbFJHSklJNnJJaHZCRVdDd2ZsNUZHRHpBUVFFODRRR3NWakZCWUdFVW15OVFyTUJIekwyQ3ZPTnNMemJXZHNPR1JpZW4wNXZaTGY5TGV1czdzVWpEbVBMaDdWSGlaSnF0NmoxendkaGFKcm1LYTlZc2JlT0UyZjYwMUk0UVdqcDhXNWk3eVdIeDZycDZ2TzV3SExjRzR4N0JpQnhISXRYNjlSWFc0M3U4dlppbi9rZEZOV2dpN0lIeUxnQ3RiYmRvYUNVaE5DWHovbkF4UFFCRkFsYlgzZWp6RTBOZFJudk1WZGhFbFVOTUlZSFRsaTdmaWc4bnRrRjZKNnQ4NDVNRmN0d1l4eldPMkxjVDdqek05c0t4cy9PTWpuQnV2NUxhU2wxZDEyczF4d2JZcldBY3I2K3ZnN2dBeDlVMlRlUHdxUXBabzVkR2o5aGRDODBzL0pmVFlmdUNlOHpnTzFsTW5rbHg2eGVFVGt1NFNvSnRwdElmS20xTHZXTUdsaG9EdUEzdTU3aXdkNnZZQWhlNnJqbEZ2eDlDZmY3cUdsQTRsbitOcnl6ZkhvYkRzZUZ3ckIralBsakRuZnNKTmNha3RqY2ZYT05ESkJYT2hIZHdoQ0VDekVaaXUycy9vUm8vVVV6ckpHaGtwNlRxOXJQbVdxUHBCbm1ieEMvMktDOHY2dFhhY2p3K1BMeXl1SGhiR0JHQXNiR3hESC9HNGFoVjZ4Y1hsNmc5RUYrbHNpMk5yQkdPbE5nWFRBazhoTmFnT0phU3g2NlAyTXJ3UytwV2o2VGczRStKelRVcGFPUno2azYvWCtxMXNrNHJuQkZiajBlWGx4Y1gxVnB0TVI0L1B6OGZaREFjZDZDTTVjV1ZlUHpYT1B3eEJ1U1NPa1lWc1dYS1B3dUhNTXdIUkJpUS9JM1pISnF6a0taWXdvckh5Mk9TT0szRXB0NVk4TWtwbXY3aUNBY2ZUTUJUWWZlTVFGUTNGcy9QVDA5UExaYSt3VHVCRVdFd2lBWm9iWEE0dnJpeFhxdFdrUWdHcHhSdkZpdUdGd25JdHRnWXZRRWpyRUNoR3JYSWNSOHNTWU4vOUE4UHhMbXduQVRyRWhFS2Nqd1FIdU93dnJ3eTJHZHB0MXJiTGNUaUxwVUJNRmFHZ1VYZk9ScUdJZ0JTcjE5ZlEyQk5LQ2FJNU9GRDBBYURJU1kra1VST2pTVEhWU0ZKSXJYTlowbTV5RlRDSUUxeHQ3bEVEUFVxZWNZZ0NPTDFhNDFHTzQ0MEJCZ2JDT1BSWFNoakJZVXhPTmpYWjdGWXJYQXVZQUpJYW5Ja0RjWmVXWTdoTlBCRElKQnJOclhGUXpNSElZNFJWaW9KSVh4S3V1Q0hpTUd4SEQ5SENpYVRhV3BLTXc2bVVBYkFXSDk2LzA2VUljQUFHc2lqSFF6TzB3ZG5xUkVUZ0hKNUZlWWRlT1l4NkMyWUV4U2UwdFJIS0FKUzBwYlBUek1pOUZmMjhiZDU4SVhFU2d5WUZtcUxLeUJiaTNWY3E5VUFCekJVaFJyR2Nzc3dIano4UjJObEVJMzJkdXY0dUdacXlxVFJra29HNDhTa1ZpY29xSlhMcS95Vk9CNmh1bWMrb2hhV1hzTDN3TzhyS21NSkdoVUI4ZUFJQ1JBRGdJQVVFTUlwT2NYcjExNnZ0NmVuaDdIUWFoVXdNTFV1MzBZWkJBT2xJWWNoU01PQ05NaTBhQnFDY25vT1hDREdMaU1YRENyMStzVTFYUHNsMnF2TFY5S1FCODhDVE9iaVVCOVRoNUJuS1Q1Yyt1bVhMeTVrQUJ3UUZNNFpnQmN2dlAxbXJ4a2dNRUVJZHNjd21ES09GVENHRlRDc0FnNUdCSGhvTkhnUlBHcVJENkU2YTl5cVpIVk16bCsyK2tXZFc2MHEvSEp0RWVNM0pvaHg4QVNURjYyL3Z4OWVaclBaKzBVWWNNVzNqeGszbGRFY0JobTR6WlRKMUVNWDZuMk5CL3VFZGtwMmp0YzFTQThLTGc1TnVsazRobXNmRnovQ2FUNHlWN1JpRElEN2ZzRk4veDVOLzE2UDF0dmIyOW5aaVNoUUZ6Mm03d3JqMjVUQjlhSFJzR3VCY043RHpJdFgyd2xYcnRmaExlajA3enZBZERyZCsvYzZIWHhGZHdmVzhYNEdyQVBlMURIVE1VTmZDNmJqOXc1M3oxL0VBVWlRTEpyQVlGY2t3Q0Q2ZDZrTXFMcStEb1BoTUprWURpK3k2TzhuR01RQzdtM21FeDdzMDVkc1JrUWkwWkRENk84WFlKaWJLc042UnpCdUtpTSsvTTB3bURJWWpWNlNoNDcwZ01ZRjBOdzZ1SVlVTEFRa2Z5eU1HOHBZaVgrVG0zQVk1cHN3T0E0UnhpZitFdjhqOXhJR283ZTNPUXlXVUpVd01KQ1BONElSdVNObEtHRmd6ZlY3bEtHQ29SZTFJZGNBeC9GSlFvRXdDTWp2VVVaREdPTXlHTGV2TXg1OVVSbHFHUFFrdnU0bWpXR293ZHdkRElzS1J1VHBuMXVhQStVd3hJSmNrVkM0cnhBVUt4VG5WdEZwc05DWWt0eEZGSWRJaEVWU25lUXdraGp3QXdFUUFwMGVQL1RpemJPN2x3SUY4eEJ2anhkS0ROTVVsVGprSFZyaCtmQWxLNkdJSXd0SHF6RHVQZmc3d1loOEJRWVc1bFkxREkwQ2hsZUNvZWN3ZXVVd0NBY2dZSHJRQ1pHQ1VPaS9Eb1BWV3lJTTdYZUJRY280am54ZEdhSTJic0RRaURCNnpDcGx3R1B2a0djVy9wcVJ3aVozRU1FdmtLWUFnK1B3VWg0UllHZ0ZFMWpnUXZLT1lQQ1kwUkNHUllTQmkxZEtMUERTTmxTR21kVmR5c0NoVnl1ak1ReTlFb1phR2JRbStTTmdQUGlpTWl3cVpUUnprNmtwb1FnMU40OFovUDRGaGNpRW9WUERNQk9LVHJOYUdTWVZESzBBby8zN3hBeElLSXN5TjVGQ0JsTUd3UkFjUllJaEJGQzRBMUVadlkxZ0tPcnZoakFJUjZjc1l2QUtReFl6a0lSQ0dlMThZWUpWeG0xZy9OQklHU3NTakQ3RTNrQVpNaGdtT1l6K0pqQkVUNUdycEpreVJDZnBiQVpERmorWm0xaXc0cm90akh2M204WU1Sb09kcWwzQ29VaXRHa2taLzJmbVdtTGFTTkx3YUpVOTdYMlAwVjcza2puT2FWUUdISUxCRE5nWnd3WnNqMk9Zell6eWdKb1FabkFDeVNRN21WY2UwaVFUQ2MyaXlKRVBFdzRXSjEvY1drdVdHc3RxQmJXNi9aQThJRGhrMWRLcUx6NUUyZ1BSN2wrdmR0dnVOc2pZMmMwbG1JYTQ2cXZ2Ly83dnF5cG50Q01ZRmpPODg1YVllanNKNktUdEQ0WENYVE1HMnNvazBXV1ovT0Y5d1l5RUFJTnVDazgzTEhrek15Z2NnM3l2SnhaclFVT0FNZXdNaHFVWExjeG91Q3kzeHRvbW9CeU53QURyckFGN21YellwUU50TUNOaFkwYkl2dHZsQUVhWTFpMWxocWRKTkk1Z0JzMHFRa3E5SGJySnBKdG1PSGVURnMzNHNFdG0vTTV5b0Ftbk1ySERFV3oxWGMxbHdvUDhtRE1ZZGtDR1dtM0dtQUJqVWpRVGdnWkRaSFN5Rll4d2syWUVlZ2VHQ3pNY3dXaHJya2RxaGdXSEF4cnpEVGZPaVRGc0t4TTdNMGFkVEZlNEl6UCs5TWNUTXVONDJhU21hWHRkWlJPZVRtaW10OWRKUDdKSmwyQjA2Q2F0MllUeW9xTHJ1WXJOZEJVclJhMHRtNHo5cjdQSmlaaHg3R3lTelNBMFV4bmc3YVNRVlRNWlZUL1FSanRrazZQdHVOZkZqbmVmVGZyQWpQWnNVcEVRUXEvTmVwS0NvYW1SaUtTL2t2ZlZDcFQxNVA5Uk5qbVpaaHlQR1VFVnNJZyt4SGdGd0locHdCSjArS3RoN0Y2WGl1OG9teFNPbDAyNlpzYjdwNCtkVGJRSVRQOUNDaHRRSitHQ0RpK3VLUmdER3BIOXRaNW1rM0duYkZMTDV0UnM2VmpacEd0bU5JUFJtazBDOW14U0laZjJMbUpza2xIa1NjbjhoSEU5RVl0VjBYcW96OWxrc3FCTHNCYnkybkd5eWNtWWtUd3FtOUEvRkl5ckdDOFJBYzJSRjk5alpSbEtXVVYzREVjSE90eWVUWTRFd3lXYmxCZkpHODZZaVdOa2s1TXo0K2hzb3BIaG5NTUt3YUl3UTE3Y3dIWEFvcEJCUCtCNFQ3TEp1RUNqcGJIR1NoSzdUZnJTT0U0Mk9iRm1IQ09iU0d3NFJMdUtpSUZoZ3ZHQ3IzL0Jabit6U1piZnJOM0c4V05razk0eHd6MmJ5R1E4anhWaXlBL28ySjdoTkJCRFIxTzd1TjdYYlBLWnpNQzRCSzFzOE9oczBsTm11R1NUUFVxTmpWVVlSSm1PN1FJQkEzQ3BncENlT0p1TWRjb21uQmwzTUdkR3VIL002SmhOQnZhc3ZYRTZwQzkrczhCQTYvWFlRUlhOdm9FRjYyODJLUkZYZ3k2bnNCTG9Zelp4YUszTllHaVZ2SnpMNmVXOHRoZmNvMnlkT2dnUDVzRit3WmUzZnkwREZxOHhWb0o5emlZRS9kbm5HS2Y3bDAyT0J1TkFyOElvWmxGVXlzaGFzQ1pmZ2tINTlFcUZNV1B1cGc5RmMvOEE3OUdhVGF6V090U1RiRklncmZ3S1dEeC9QN1BKbWRNZHM0bWVzWDFLWWthdjdSMWU5QUVhR1dvem92VHpOL2MzWVl6aHZwNmJGSXBsSDVLQUYwcXlyOW5rVENkbTdPVjhUWjhaOGFuYTZ1NjlFZnUzSHYrVWdqRXVIQ3ViZUx2TUpwTlpTRVhxTHJ3UGF5VzE0a0c1bk8xRE5qblRJWnZzeVJFeDUrc1BIbHljZzc5ejJwcVIrdm4rcmI5ZTRBOGd0MkVsTVdIUEpzTzl6aWI2b3BSNTlwSzhEK2hGTGF0TDBOVWtLYU81WlpNUHVtZEcwaldiY0dFWVdieTNzYjZkU3VIdEgrL055ZE5oMDloNmVmY0pCK001Vm96cGZwK2I2SzkyU1NSYzluaTByQ3JOUm03ZC93cWh5T3U0M3ltYnhMc0ZvNE5taFB4N1RDOW1ibTdTejJUQ2NQRFcwMjlOZjNnNlhWZVVSUWJHQTdBYTdYdWd3NjduSnQxbEUxTlJqTFEvNXRGa1luWGUxRlByajRqOVN6dGxrM2ppZ3hOclJuczJZY1NZZTBFK3BxclU2K21sUk5Lc0d6Z05pV0FoYmI3bS9TU1Y3T201U1NtZkJUMG90bTc2bWVuVklKamRISzlNcGY3Vzk4VW02SFp6Tmxub0ZUUGFzNGxPWi9zdGdjSmNXUU03SGdqNmw5S0d3ZlpBZVEyaHAzWDd1VWxoWnllcnF4bFZ6Y25aWXNkc3NsTXFGb3Y1RXVzbWNrNHVFakFLZVZWQ1VWODFVM1k4TjlHNUpWZFdRbnVWT3RoZUp3ZmFVMlpZWlVLcjVFdlNMSkpyallPQzRBSS9LK0IxY2hNSEd1Y21wYnd1b1FpVlhWODFWeTQydWZGNXFIZUU4Z3lVRW12YWVRcEdhUkZKR1VCanZJeit3K0twbEdzL04vSGs2YU5IR0NkSUk0a3JSdHdwbS9TYUdRd01NcXdvaUxpeDVIYzZOMUdwRzBYblVtbFJKVHNFQ21pQ2g3OWR1VW5IcmVadGFCVHBMNmhlZWsrMHlPWjhPYm5pQnpDb3VkOWZIY3ROU2VYRFIvUko1STJuN2R3a3h4b2JWcWpOR0hESkp0MHo0OVFaOTJ4Q3hudWY4TUw1VGhmUFRtakQ0Rld5QTlZYzBIbEZsSGI3UEgxV0xWcDN1dmowb2VCWExTeklWbGtjMEtFd29TdXZVRlV6OFRxemM1ZU1jT3U1Q1c5dWR3MTdOaGxvdGVQZE00T0FrWFl4WFdUQVg0UFRkcm5UcFhFVDhrd0owcU9Da2p3VHBlMEZ1R1FtZWViZTMrTmc4T2wvQXc5Qk5YTE12WTVzWXdWTWU0bFp1L3NSVkRLd2tlWmJGMXRteTdtSlVLbGJTcWhUTmpraE0xek9UV0NkRVl4MjJlMU9WNVdON1ZPOFFzSFE2WlRPZ2NiVVE1NWh0dnVEb205Q0ZJd2R0dmpvQmxCaGZyN0VwM1VOb0FiUktETnZ2NGdPNjlnSWpQT0hONVJZOCs2NExqNDdmZHZzWk1mN3dvd0FLVkdZbWV1ZExqNi84N2hPN25TeFRVcjBNeXo5SURTR0hWNEkxNHhSQWdhTC9OR1A0U200RFU0YjlBdkdheUNnUFA5RWJ4dFk4WThYQkJoNHlYWnVNakVScTFvWjRNNi8rZ0VHMXd4blp1Z1VqQlhYTzExaXBiQUJnK1ZsY0I2SXNVejlwMGg0VzJrQVEwRHpCREk0TkZmK2lsUUpWSkVnRWRxQ2R4cy9LMTVld1drN00yTEZpSVhHNWQyNCs3bkp5WmpobGsyeUZJeTE5anRkZyt4R2dsaGZyTUJZVld1dFRlYTcrRGZRdWpKR2lFRTFBcVd3QWpUSjgrbGVwRlhpNVJ0RnhOSFV3WCtLbDVzY0RORmFaVlI1SU5ENHBqN05tVkZyeXlhOVpZYklKaG9kdmZ1ZExnc01QUHJaQWZ0L0VYemJHSWNvRmw3VlludG9hSjVUQWVUVGhNYlNWQ1ZlTCtmUUo2QzhJWERpNGhkVExXQlVwV1RLNHNhR3liQW81d2I4cmRua1JBTGFxaG5XNTlRa3NqeU5jNVBXTzEwMk1FYjVoSzdDNG5KcjNRQWpJYWhBZG1jQ3dBd096V3hUbFJCaW1JQUZyeWdpTC9IR3VRblU0YXhzNEFQK3ExTXZsRFV5RGszS0RTUjZWU1kyWmppY204aEVEOWZjN25SNWNuekxCK09KaW1pek1BT2VUY1FpYm9CSzhKK2NJdkpwVlFudkpVTUNVNENHN1BvSit3THk0cmZkNllxVm81cWlXR3k4U3MvMWdtVlVNWlNXYzVPdW1mSGVxUTdaeEs5TlFkOU11TjdwVXBuc2ZRcGdDQzM5R2lzaWRDMWFjMHp2OEM5Zk1QbmswS0R2UUd1OTNwMnE5WkFvUmtFd2Fnc3JUZGxFeWlTdzZkRm1lRDdFSkNKcFZUVkIybDJQTk9QM1p6b2RGVlRSeUpiWmVxZExpRWFoNFNKSHExd2d0MFdWREFzcmNRNDZCS2ZDMUNiR1EwMVZZdGlxQkI1T1QwSXZpVEtJdndMYVRCYXpWallwb0hJZHIzbllDcURvSERuWUMrdStBd012OWNxT3V6QkRnSEVBbFd5NDNla1NiRitIYm9JczBUTTVNZklNSGZRbHhndWMyNS9EMnR1cWhQYVNZYTlzdmFxUFE1bm9ISXpuVUNVRnRXcGxrNEpjdzRiSE02aGJKUllPNTFFdWlZM2VCYlZPMlFRcVVVV1h0NWVkUDI4UzVzTzZBTE1RTkpqaGtqRTJOaVJ6TUw0SE5tU3NRb2czVjhtQzF5c09VWCtFbWpsNzlxd3dKS0RFeG1RZXllbTZ5Q2ExYVp6MmVHS3ErTGNVVU0rcVppanhudG54OTA1MTNCQW0zZlhlUDUyemljYUhEVkV1TFZJRGRBQS9MNU1NN3drcDBFeXJFQlJ5YnNKZmphUm9MNUdGalFXSkFEREtqYjZUS0tnU2FLWWxvY0Ywek9NcCtLemRSazJkT1RCQk1kNFJHQUYvQUpiL1NjZ3BtMWk2dmdHMVhtcUF3WGU2aWt3L28zOERxSXBXTDZrRE1iTDhpT0V4N1NXQ0NUL0F6NUhOSFVsc2ttQUQrb3FjcGdjeW80VUN5U2JobUdld2JMMlJtWW5BWTJPNTNZNzNBd3g2YmxMYlIrZi9QZUNRVFNxU2lHbFltU2h4L2Z3WXVpTmpCaC8wTlZqK2NOYWFZTHhoeFJIQUZQWjZoWUM4eEVvTXdPQUlmd1RlTFZtVXBKcWkrQ0diRlBMWklydlRWV1N0WitRNy9IQS9vcThvU21MZzNZREJUdFFxbjZCTGI5dmxVeE1kOEM2c1VXeVV6L0FqQWNad2xhcmdwZWRrK2JNTXFqdWdIbDVMUHFGS2pFWmZ2YzdNV29tejVpbFJETldYTmFHakFETUF6VnlGM09tcXNYZWRlcno5OUNvcXJ5cEsyaW1iSlBxUlRkaTU4OEZmRUpKYnMwbE5HSXQ3UUl6UXhHZ2pwakF3S0JtaUY4QTRLWVBlTE51dDJjVEcvUHk4QUpGV3lYdzJhclhuVmVaYXlUZitEcjhXVUNOeVVqR0NSRExvOXRuYm1OanFRcDgvZkRaWEJiMVFUS2R6a3hQWThUK2ZUcWM3M3VrS0g4Nmd4VngrejhhTVlGSG5PbloxbXhCallsU0l4dlAva25kK3NVM2Nkd0FmazRCcFVxVktTRHpzWVE5VHBiMXRqM3VNNDM4MHNWTTcyWkswSkxBUWJxdmJRa05FQmlXSVNTdXdQOENvcjR5R2JUUTFUVUpYeENJczNKeVVXSXNDZ2xQUDRoUTFBZTRLU1RscE9ldUNYL3d3bVFjcTdmdjkzZmx5dHUvczgvbWNWdHNoOGsrSmZmZTU3Ly9mOS9zN0ZZYTZaazR1Q25MV09kM3RVdFNjbm9VUEQzZjViNlgzNmhGV1ROZXRrNUQ1cnMvM0xIWm5NbGRJMEVYQzI2LytmVCt0YWVQNWx0M3pYMmVIc1U1dnRtN2lXREoyQW93YTh5WmR6L2UwOU0zY2VmQmx2MW9RL3JMLy9rUE5QTFpnaGJRYmkrUGFkVndlamlDTWVVemI5cCtCbER4ZkRLdjI5bUJacCtoSWlaejRsbWNPNmQ5QmZES0hmN1czN1NUODJiUEZ2a1ZQVm1zSGFsL2NnKy9WZDBqZlhuSGYrNCt5dzlraDg1NHU1ekMrcThPdzd1a0s1N0JHKzNCcDdzbm5EeDQ4dUhVL3JTL0F2b3RWZTlKSno2ckxLRy9kdUlMV0UwLzc4Q21zZVhuOWZtcjVrT1lBT24yTExVdmFndldONGJWYk0ybk5aT3c5ZmpZY21pT2dmZzdSeU9TRm1iNmw3aXhwZ0FIQmlDd3Y3dnNscm0zMnRNRTc3MzM5L0tuSkRLaElyMFZQVjBPU1VidW5heVgzdThQa2pqeWNXWnlCZTZ5WndQMGdGNkFrNmxqQjhwMVhpTjQ4Vzc2MWlMQ080aUpzdHBmVWc0bXF2d3IyODA1THVyT1l4VXplUys5ZVNoZnJPbThza2EvNzNyd3dlZTNpbVhSNmJpMmpOUU1oamZabmZ6ejc0YldMbDgrYytlRFVoM2ZKbXRaMGQ3L2IxWEdVREMyRnI5YkcxTHYyK013dlh0WTBWanRlZVE5WEhmTmhiY1RDODhWL1R1NGpGZUdXUFMwOVgvM3BMcDV4TjJHaEZjWS8vZGQ4UzNvNSszSHhCZmFrN3p6WmVMbStOcXlzbnovdzBSL085K3hlK2pxZktlb0l5VTA2ODlsTUJsNFJQeGhRbVBaMHVXRXpxdlowZFUvbkxwN2JiMEN4L3ppMklnem51amVHYjA0OE92RDMzNzl6ZUZkNi90NWp2SHZaYVkrNndPaWo1bllmNnNGclRTK0RDMWpFemNaNyt2Yi82a2xPcTF5ZGZtT1gzdTdSMHpZei94d3NBdHBPNDdySnlKWEIzc2gwTHBlYkhqWFV4dDFkTjFGaDFKNDM2UnpKWjI3ODVmTHBnNGQvL1ZaZnk4RUxaMUVzTXROaHc3eEpiQ1NYemVoTDFObmNDWDJ0bGZKOThmSGJyN1c5ZDY4ekR6NlRlbjY4N2JXM2owTGtPdnc2WWZIbXArOGVPUERuOTgrOTgyclByc05IUDNqMkQ3UUkzVEduOHlhRGd6LzRrY000dzhTMVdzekNqK1l6azNmLytwc0RIMTJidkVIV29yTWpyV1d6OEtNcWprdzJQMzBpWXV6cDhoL1R0bGNHRmhTVjFiNStyRmVFUUFrbTlYMlk0Yyt2ZERxZk4zRU1BK01NMjFNRm5iM1RxdXBxMSt2eEdtYmhveHM5WFo1d3VDdGFQbS9TbXNjT2k1emF4cFRMNGdzY1c5UkQ4UkZRMDZFY3ZubzJtOCtOaGh1Wk4zRXVHVHV0SmNOa0ZqNDhjaXlYeStkQmNhZEhHcDJGOXdkNXZkRlZyUWdOREFSSUQxTkk3OURvY0RKdk1qanFITVpMTnRTa05EZnhoc1BlL3NabjRYMTZvRllzZ3JnekN6ODQrRE9ITUxhV3dyQ2NOK2t5V1RkcGRCWitSaTl6Ukd6TW05aWVoVzlNTXV6T20rRFI2ZDRzL09jYnhVQlhaK0Vic1JsV2FsSTViK0xLTFB3R0RLM0tBd25yVU8xNWszYjdzL0J1Mkl6Tm5vV241blV0Y1hjVzNybGtiSzJFc1ZtejhJdDZBYy9kV1hoWEphUFdMSHkvTzdQd2xGb011ekE4UEZMZkxIeXRlUk0zYk1hbXo4SVR5V2k3QVZwaVk5NmtqbG40UmlWakUvYnBxcGczOFpHcXgwSFVrb3A1azBBanMvRE44Q2JPOStteU8yOHluMzRaZlVtM3k3UHd6aVZqcSswSTFMamxvZGRxbjY1QStTeThyOHFJeGVyemM2ZHh2Ylg2dkVucFhuYWU1dVltTDluTVRib3FkOUF0bDR4NjUwMThtTHpsL01HZ21XeEVEU01uRzFzK2xrZGRydVltZFVtR0RtT2lKRE5wWUo4dVNJTjdqYTMwUUNKZ1ZCYUNBamZUblppWWlBeVV3YkRNVFZ5U2pDcXo4RWFEVWJiMUk3RndEbWJoamNOSXVqY0pWRm9PVnBabDFpZ1pUY3hOcG0zbEprVVdYVjd2Q3B6Y2lnb2o0cG1Ja0wzQVkzWGxKcFN2ZkRKTGhSSFhTTVFSQkFzSHZLWXNLaHpIS2ZMQWhFRXl2dUhjUkE4KysyV0ZXeUJuaDNMaFdTRzNUYVhSZ1JLTklCZ21hQzRaakhvUUVBeHV0NHliTGpNRUJnTi9HZ2pFNDlpK0k0cUtJbkdDSkVmanJKSk1KZUhnWkhnek01dnhUZVFtV3Y0T0xMZ1VPUlE1NGdFVTVMYUpNdFlkSVA1a2pmWlQyelRaN3pNRUdtUkRVTW80YzZMUCtmSWlIRElMTWlGeVNRR3V2eUNJQUlNckpPRXRra2tGMEZlRVhkOVFicUtGR2Q0VkpaWGlGSVZMTGNoZzAwUThhWExmb3ZFbzNGSEFBcGZGOGp5UHUwemp0Zk53NlNBS0JBSlBEbEhrZWV5Z2hnUEVBcjhIR0V3SUNOQjBVbERZZUllWXBBV09remhnSEpXNXBNSzJnM3dvckJGR015TFFiYmJEY1JWRzZ5Y2dHSW9NWmtOUjVJa0pPRk5DQm1uRTRTNUs4SVVZWW5pNGppRG9BQy9Cd1VtU3lQdHd6M0ZlRXJSRFpCaEtsQVJPOU1IdkNoTFBBQXZBS3NCL0FvTk9jaExvaWNMR1l2QVdNbmdUZ0NFYllEUWxOOWxhSjR3dWdMR2dlTUhUZ1QrSlJFVFFGakFkc2dJWEVTVWlYU2h3UENQVHRBUXdHSkZPRk9CZkFpN1hCekJFdWdEZndBOW9nTUZMOEozQU16eUhIeGxlS05BY1hEOG5kcUJrb0dad0tDVXhXVWpLc1JoS3hvQVpqRlpUR0ZzZFZjZTNsZVFtdXNrb1pXRk1XVDhCTlZGV3lHYjhjR0pLaWdObGljQzUwaHpiRVpjNW1pNGtsUkF2NkRCQTNBVzZRT1BOUnhpQ1JBN2VwOEpJU0NBOUNjQVhGQUdHd0FrZ0xLcWFKRkdBQUFaUkV4bFVLQ1dUNTVsb2g4NWpJeHp2UmdNNk5OSncwSFhGOElRVHc0TXNEREIwR21CQUYwQlBpSGVkOElEOUVKRkx1MUxnNUE2UURKUjBRWlIxR0VBQmJJSlFVQlZEU0FpcTN2QkVNaElDeUlnbzBRaURsOGpsQzZCbThZQW1HWnFhRkFCU01xV3dxbXR0SG93eXlUQWFVQk1ZcmRpVTBLcGFVUEN1cXMzZ1pFamg4VE9SREVFU3VZSUV0a0dEZ1JDWVZZUkNZQlJvT0JJMHA2cUpJQkU2Q0FQdEp4NGdFa29BMVVSQzM2cklxamNCYTBLVXBBakRvQ2xsTUZ5d0dVWTErVzFsT0s0TEJqNXlvcXQvUlZsQTE0cU9mMEJKd1hrcWlxRGFER0Fpc1dEOVFEcU1NQmdwa2RCZ0NPQWp3RStva2lId29rRFRBc0tJZ3dGRi80SHVGQ1NEUmdCSmdBWXdSTERRNEhFanRtRzRKQm0xWUJEaDZPOWF3WmdRdk1sQVpBTEVKSmxLRWQ4YUF4aHdZU0dXQTJOZ29TYTZ6VUFZQ1lIM28rRW9FTWxRUFExeHJRSHdMUEExQm5Za0dHZmIyL0VSU0FNNmpQN05rQXpkbS9SYTJneU1RZUhqeWtvL3h1TndoaEIxcFFRODdSallESURCeHVHYWRSZ0p0SW8wR0VxK0tCa2NYaVp4cVFrYWZVbUN3QWlCWktCdkpmWXpJRVB3QlhFdEc5VWVVNEF0R3NXbklIbWFWOC9ZWnJ2U3BjcEZxNTYrcStWZ0Q5REFneVVSS0t0SWNERjRYWUpJWUFoQUk3SGhXb3MyQStYRUQ2TEFNMzZSdzkrRkNKU1hNUUJsMlFBbWUyd1VQa2VMV2FzT3cyUFFFcS83TUhhOFdBOE13N3hlTVlXUG9EUEJYSTJrYVpoYk1TRklMVVFJTGlIb0VzRjNhRUVYaFVFWGg2NUVkYTBVUnFJK0JuNUg1aEVHbUJiTVRPSUlBei9Ic2J5akxyYVNLbWc5TUg3cUtNNzRYcjB3V2l2TGZpU0pWMnVnbUhOQ05LNCt3a2Q5ZWdPdnh1TmFhc0pyLzBnQlVOdUVDSUFFMWZ6ZHVHNVNSSUZxRWkyRDRha09ZOUFoak8vc05NQVl0SUpoU0UxYVRXdWdFWDBKaWNBSXhZdFpLMlBJVWlsOEhOQXFRLzZUVEExK3JDYXRUTlVhYU1rcXZLYzhVK3N5cTNRNWc3SGRsbVMwR254ckhRWGhzczNzcUkybkZWanV1ZU1LRE1lU1VhZWFXRWlHcmJKZjJhTi9LbUVFSEVtRzZ6YmpXSjBHdEM3SktGczNzWWJoMWxKQmd6WmpzMkJvU0p6REdHZ3FqQjBPT25jY3EwbDkrM1JGbmZkME9ZU3g1VVZYWUVTL1RUQkdIYXZKQzQzREdJallYamV4MlBiUm9uT25CZ3l2MjVLeHJRS0d4YnFKNVNNOUJ1eTBNWm1zbTlqWW1pcHEzY1prS2hsSEdqV2dWU1hqL3d6R2xoZXFyNXQwV3ZkMGVaejBkTlVQSTFxckQ3UXl6dmhodzVKaFZoQ3Uxc1prS2hvMjJwZ2Frd3c3YlV3dTJJei9JUmpOa1l3cVBWMWVpNTZ1R2pETW5VbFZOYW5lMDdWNWt1RmlUNWNkejJyZTdXY2p6aWhmVVd1K1pGakRzRklUVXhoVTAyRTRWcE9TT0FNcndrT1dOc01XREsyOFU2b20xU1hEWHgyR3RacDQzVmFUTGE3QlVHMkdiUmgrLzdjUFJvVmtPRllUWnpDQ05XREVMTnFscS9hQk9sU1Q3V1dTWWJHK1dKU05ldFJFZjd4eHNWM0pXTjN4K3kwbEl4b3RoV0hQbTNTWDJJeWZ1Q0lacnNOUXE4TGFJOEJKQlpSaGlzLzliaGFNVVljd3R1OG9EOGVIcXNBd1ZST1BoVGN4UFBpYXdvZWkrMExSR0puS2lFUkRmdklEZlJ2MnFqQmlteWNaWmdiVXZFVzRsbVNVQjEwRVJqRG9RNG1JZFE2dHI2K3ZyVDNGWXcyTzlaRmVEMG9JRlFvR0sxeHJ0UFNvQ3FQVlJjbG9KZ3kwb05RcUU0aXRoTmNCdzZWTFk5Zkh4cVkrbXgwYkd4OS8rbWh0ZlNnY0NWQ3JsRC9VQ0F4M2JjYVBLMkFjc1laaGFKb3VyakZhZWhPOFJoQ0xqdDcxdFVkajEyL2VIaCtiL2VmVXBkbFVhbnpxNXNMTnFkbXBTNCtPSGVsWVhmVUZ5OVdrbEVTeFBYZ1RiTWEyN3pjTlJnalVvR3RrL2VuNDJQalU3WnV6NDdPM3IxKzYrcmZiTjY5ZS9TOHg1eE1TVjVMSDhZVWNzdG1yc016QXNuc1kyR0VEZTVobGQySENIbUw4azBQYjJxMHRMWU9RT090LzBZQ0tZeEkxaDJBV2dqanB5MVR4V0lyT1NyMFdVb1U4MzZ2NHJDRE9TeEhDUWp5MHpIaXdhWlhHdnVqRjR3Z2E5bGZkcmQxcU85dTJMbHNLRFhyeGZmcjcrLzYrditvcXFXdmJWZ1IrdEp0K1ZLbHJwUVFZOSs4WE9RVjYxY3I0MVJmbnd3aGVBZ2FVU0hXZ2JpZEJsR0pFY1VXcEVJUVNnd21NQ1JWMkpPcHhtNkZFT3V5dmFxKzlVaGlYVU1ZWEYxSkdaY0ZlVjlIWnhIOEVvMzJqNFdHQ1NTbTVpNVNqcEVSUUhnN24zT091cEZReUpMakxiWlI0MUxEUmZueDBQQkE0SFQvemp2SC9WVVlCakdCeFpad0xBNXh6SXIwcmJFK2FSRW5Qc2wzYjlmVHBoSWdGM3c0WDJNQVVMTVR6QkloallhUEtWMVBVUUVGdmhURHUvRStWVVhFNUdBVmxjZ0pHYlh0Z0pJMFZ0em1keGE3bmVBQ0RXMUc5VXZDZGlucllJTWd3aVpmeWtKR3VxMmsvdDB3dURnT1VVVkdlTXE0Vmh4RStCMFpobVJTY1NzakRDQUFMZisxRzkzQ0N1Z3phS1pYY3NqaFVpeVRNaTZReVBFQWhGc1VVWThZZEd4bVVKRVlXMm12OTJUSTV2WEpsMGxBQW8vVy9LcU04R0w4dUVVWmxpVEF5QmxwZDVYK1F3RlFpd3lBZ0MrNHloQ2tZcDJ1bG9wRm85akNQaXpEMFdhMFE1bkdTR1BlQmI5UmNEWXl2Zi91SE1wWHgrV2RwL1RGOE9URE83U2FnaTEwQ0FEQ1J0dWU1RklGQlNCdGpPNUtERVVtbE9EWVJqNlk4QXdFdGdSSmhxQlIvTVJpQlBJd3pLYU1BUnZnWXhxT2RjbUZVWFB2c3AySXdta3NvazJJd1lQbXFGOElKcEd4aUVoZWFoeTJwTkV4NCt3M3NhUTZaVTEycHFHM01HblkwWlNubFFyMUltVzdlS0thTTQyN1NVTXd5OU9YODRDbGxQUHI2NDUvS2huSHJJSDIxTUtxcTZ0SVF1YUUybU5ZRkFXTlFSQUVNRk0xYUJyeUFpeGl6MUlwYXRySzVyaFFicHh0cnF3TkZzdmlGWWV3Yy9QbjNGZVhsakd1M3Z2dnA0Y09IbVQzUUM4STQ2UmxIZDVGODFkMXBwQkIwVkpkSjIxR0dqS1FpMEV5VVNUSXd0R0ZZTmlQWTRLQUxoR3lMZ213RVNiejB0MThZUnZBRWpQQ0lQaTE5K1B6THY1WGJUVzQ5MXpSZVptR2MzZW82amVNMGpOdTNUOEtvMlFnTUp3d0NtVXA1Rk93VEdvbkxKWVYwTld0NG5tUHBUc0tWYlJNRDI0N0xDT0ZSRDNJNnBtaTM3a1Z0elNtN0tBYWowRDRiYzVleTlGWVgvTlhBWXZ6dytkVE44bUQ4RXNya3lkUjNoenN2WDE0R3h2MWpHSDdmUWwwQ3hsS1hDOCtpU0FxbHBMQVpzemd5TVdRTkRwbURLNERCc0NGZHlnUzFvMUdQUWR0aE5CM2M4SlhnR2NWaE5OZGxoTEZ6K0hUMDJjMUxLT1BwTi84Q0dzY3dKb3A4MkZwU3p0QTBmTDZaSGVnYzhMaE94S0dJNkk3aVFlU01XTFpRM0xPRlVGSnhycGhBSmxMTXRUV01pT1BDVE1zU3cwVmhkSmNDSXhsTzZzOWFrd2ZQUnFmTFZZYjJqT2RQcHA0OU9majRDSENVcEl3aWdUeGZKbFcxdzd0TUNzazl3UjBLSXhraFJQS0lqdUZXSkFLVE80akNsWWd3aG1kTmVKSEUxcGJLR2FXUVJMdDl2dUxDT0E5RzV0KzJCcE4xOE5VOE1SYytYSm5zNzVpY3VveG5QSC82YlBwYktKVngwRVp1RDdSOEdBRndUNEtweDdHd0dLSWdCSVNrbGNuZ3FRakZMc3hwRXB0WUVzTTBNVFFkNW1sTDVjQUMwZDBIL3FxTHcwZ0dreGtMVGE1dmJRL3NENHgrV3phTWlneU1iNTVOVGs0ZGZBUXJIaDQ1dFNOOHRsQit6a0JyWGxSQzNESk5hZ3REUkZ3WVRwV0E0ZDNKd0lnb2pMakRtV0VpbGdsaUJJSXB6d1JTVGpETStmUmh3MGJ4Q2Y0WVJtdmgwaWN4SzVPVnlXUXlPRCtmWEZzWkhSb2I2SmgrUFBYbGJ5cCtjYjBNR0RjKy8rcy9OWXpIMHgyVFVDczc0K1BqUjdkOEx3eWp1OXRmM1FBekNWU0J6UlYybzQ0Z1RBaUNtSk9LT0k3bFltUkhMWWtOcE9BWHVybkNjSkxOWVJZWE1PMUQxcmdRREZqSlpHc2xrQWl1cnEwc3QrM3ZqL1YzakpZUG8rSjNmL3lIaHZIdDQrbUJ0bzd0ZzQ5aGZlTmtJaDgwaWxqbytUQnFOdXJTUkxyS2hscEFBaDRmNlMwZEdFb2lqaDVnRFdhbE9JSXNaa3ZFQlBRVDR1bmdrYmxvd0JsQ09CRitVZVAvMlRJNXBZek1qbkF5cVZHRTRudWRiUU9YZy9ISlh3REdsSVl4MnRIZlA3cTljcGdjbVp1YkNKZnFHYmwvVDVVOTQxYXo4U0NodUN1VTdwend0Z3ZNYk82aVdhejNkS0Jsd0V6UEFKYXRBU0dLNkhFK1R6blVNQ1REd3pPK210Smh0Q1lyWTNQenJhdGI3elk3VzNwRFBVTmpiUU5YQWVQeDVQVDA2TURRL2xESDlzcld4MlI0RHRaODZUQnlSMEZyRm5ZU1h0UnhiR3FZOExqdzVqT2xGSm9sbmxMYzhpUkJsT2dOVUZmQVBJS2szdTNKRFNzV0RMVkNvcDFncmE5RUdJMngyTnhjVEl0aWU3TW52aFFmN095OFFoaGFHUU5qKzN2N0hkdGJhK3QxemZQaCtlWUNGbmtjcldlT1ArYkt4TytmMlVGZ2xpa1ArZ1dsbE9uR0N1bzNsU09aNjNuQ05PRkhRcmw2Zk5QWjg0Z0ZMRWRSSVdtNnVhb0VHUENpYjlqR1dwT3JXeXZMTFV1TFMzMHRvWjZyZ3dIQzZPam9IeGhvR3h2cTdCenJuOTVlV1Z1dG04dm80endZQmIyMUlYdDJweVp3SjQyNDVWZ2V4QVlxWEFZeFFyT0E4Ulh5aFJMU3dDNkRGQ2FBakJMSE5aSmRla05VcGtkT3dnZ1VnWEduTWZiaFEwWVVXKytXTjN2NjZ1dmpmZmRhUWtCRHcraS9CSXdiR2diNFowWVl3S0lOYVBUc3hlT0RiY3Z2Z01kNnNtNWVBNW1mcnl3QmhzOGZUR1BHS0l4bzBDeWtJbFJsdEdFUzdsa3dpRERDWEVFSVpBcXFCSWV4clJDR0EyR01uQXNqdCtzWGcvVWhGcnV6dnJxMkJlVXh1TFQ0L1dKOVYyOXY3NVhBcURnQkExQ01EWTBORFExMWhnQkk1eWI0eDlwNkVsRE14ODVWeHUzOFFhWmFmL011eGpCblVJemdrWWwrYmtwdEYwUHFTbGtlVENsU0J3OEcrUUpEMk1xenNEUU1GMXcxTVZKOXZqSkFHQnBHNC92VnRUZnZsbnZ1TGk0dTNXM3E2K3ZyNnJwM2J6QUxZK3dTTUs0ZndkQ1cwWitEb1ZsMGhnYjM5dllHUTJPYnl4cklhaktZS1ptNUdFQTVlUzQyZTRjeCt4ZlhCaVoydFZVSWFocDZCeFFrWUJvc0VtRklSQzBGZVFzZ1lXSTdIakdnOFVaUENFTTNYMGtTRHhaOFp6ZTZHbVptWHIzNkFFdEw0dTBLRk1mcmUwMUx3R0twdnU4TWpJN0hVemV2RE1hWVp0SFowOWtEUE9LTGk0dngwQ1pVREFDQm1tbU1hWkZrVm1QQkpjWThqT0ZkcFdBMkZRYlloS0lNbWFhSlBFaGJocUtHSFkxUUV6eEVjZzdKVTJrWTBRSnBPTnBWRXpzRk1NQTk5VzNBVjY5bVlqTzM3Ny8vWVhYdDdac2Z0emRmMy8wZTF1SlNmVk5UWDlPVndyanh5YWRIWlpKWGhvYlIweE1LdGJTRVdnYTcrdUx4ZUc5UFRpTHJyYnFqeldrY2QvS3BLd2VqR21CSUtWeUhFOGphcnMyTVdReDlSZGpFTkdaTk81VnlJV1JJVTNkZHByelR5ckNoaW5hSDh6QXlLRjdCbW1sNC84Ty8zNzdSZ3VpNys5WGk0bGQvdjFzUHEwa3ZqYU1MYUF4Q08rbkp3cGpNd3JoZWpqSSt6U21qNHhnR2tNakNDQUdNM252eCtCS3NlRmZMYXdEeWJ1VS92SjFkYXh2WkdjZHo1dy9RVDlCUE10QWJTUmNWQlFVMWtwQk5LamJlUk5RVk51MGFrdUpBMkdRSndZbTY0QmxtbDBFNHpLRFNHY293TSs1NDh0TE1EaUY3MGJJSjJUYlE1aUpJTFJnQ0paQksxS2dYL1Q5bjNrY2oyWmJ0SHIrUWkyQmJQLzNPODNhT3JVZE1FakQ1azcrSUMvMCtNalBqRis5VlNWSk5LcUhRZzFtTzVNaGlYN1FSU2tYUkhmVFF4NXVtMEJjUllqMFh6UXAxYjRNZ3dab2VTTDMvMllOdkdRQzJIbjRLQ3FURDg5ZTBNd3ExMGo2VTJLOFZRaFJFdzFjakNlUDJvakNXOG1CY1lTVElqRXZydEs1ZGd4N1lvMWhQVnE4d0pPL2UvWldZL08wRis3MnhoejlpZjBQaXdjTmZ2VWZId2JzbTFWUThieGxRM3hNVTNyR1JTdEM2RGt6VjdIbWlxSHFPYWpBR092MVd2YzVTcTRvUy9mMnYvL0RnMDUvOCtNV0w3NytQTU95OWVkeDU5cXlLclZGa1RqQXRBQ09wUmg2TXBiTXg0OHBWbjRRUDQ5cTFsWlVWcU5pdVZGN2h2VkRBYmwxOUEwMllKOThRa3hlSWNYZ212LzNkNy84cEFBT0NnaVRqZVVhMXFlazlGK1c0cHpwYUZ4Wm92R09hcWlJS2xFN1FucUVVeGYrMENZYkZvNjMvKzAvcDFZNTlDQy8zOWg0L3JwYzZSYXhPcVY2djExcXRBbHZsY2tLTkZJekxxTHJPd296TkxJejE5WUNGRDROOWFsZktUNkFJeVFwYjIrdDdqTW5yNTgvLzh1alJ1MjhBNWowcUNFbERSODd6dG10Wm11VVlob3BvcW5ybVlJRHNpVFNDSGg1OXE0RUhieURJUWlUQm8waHE4ZXBRL00rZlg0UEN5NzAzYng3WEcxVi9rUktsZWcwb1dqR0ttRVhhakFTTTA1aVJBeVBZSTRFWi9tcXZ3c3hLdWRDcTFmZWZoYXRUYWoxK3M3ZjM4by8vK0srRnhzeHdMWFNrbW03YkJnVVBWYlVONmsxTWRPODB4VUJKcXBwZEc3dkZzQ0dHcW1xMFkyeEpHa283aHh5M3ZFd2Z5NFNoQ1NXdzZxUkZGa1pDalNTTXhXUEdoZnlZNFdjU3d1Q3ZFRWFiM3RwZ1VjSE9MYlJhdFZxdFh0L0hUOXZ4WGU1MDZ2OUdhYUZZcUNqUWhwbUlBcmJGaXp4NkVVOWlJMEJrVzFIcDkvdWlaZURCV3dpYTZQWU5TTlByR3JJMGRMWmVjVnkxMnFUVmFEVFlseXd4SFBoV3Jkb3h6RGhGekxpUWI0YWZWN013Mmo2UUFFYVplQkFSTUtHTmpSQlhwUmNxVVNWUnNYVGRrbXhkVjJVYlZZY2sySHFYYWcxVVloN2FWVkZSa0dvazJVRy9JaWkyWnRzYVFpamFWbjdvZlA2TXF4YjkxUWxXb0Vac2hvK2o0cjlOYlpNenlDYjNNMlpjdlJpRWl4Qkh1RWZhUG94S2drV0wvS0FmdVZOc2N0c2ord0RWWlJkUGViZHIySnFzdWdnR1dyZG5XcWhHSmN1U0FRRWx1U1NLZEY5RlVXUTBMR2hqWFZkU2hzSm9iYm5hS0VZcjhxS2VOS05RbUdIR2xZMk5jNG9aRE1iS1NocEdaRWF3VVVJWW9GR256ZExrMWlicVVFQkVOR1JESndDOGhKQkJzd3NrVXdRTFFhVWpGV3JKNEFjdm9XaVhKVlZ6RFZXMkJPVkF1bm1SUzdCZ2NwUTZDVE5hY1M2SjFjakErUG4yd2pDV2pndGpKVzFHSldWR0NLUEJYYnNyaXp4UE1LamUxbVFaVlFZVjVZaWI0SUdZS1NIWDBEekRrbEdJeUtZdUM2cG5HREppcVhQZ2ZGM2hpc1dqek1pRWpGa3dmbkRock15SXRnbHdzUGRZamRWNG15VE5LUGt3U3ArUGhvNXRkZzNKb3ZtbWJrdThLQW95WlZQSjAxUUpQYjFoMGJiUmRWT1YzUzdhRkVtUURjUHREdlNEMGZWNkZrYmFqQ2g4bGl1aEhRekdDdlh3cDk4bVMzTmhBTUtLNzBVY05CTDVKREFqQ0JyNHlZdlY1YXVUQTZvb05RL2JoQ1lXdW1tZ1h6VmRoNmVwcCtPcWdpT2pjKzBPZXFabjl6UkpRdG11MFY5ZUd1akR5WWRHQktORGJ6bG1KR0NVNC9nWndFQTJPWWVZa1lHUk1TTWZCaVhZQmxmZi9halRnU0g5aFNiWFpFZUhub2tteEpYcGFNQnhaWVdhV1Y1REx3Sklrc0tPa2FqTzBEWDVGcmZjbkdGR0xjY012OWhJd3pnTE0rNVB3U0FhSVl4NG0wUm1CTm1FNGFpRlp1RG41NHFiazdHSng4YnVIWGltNXNsMENkYlZOVWZ6ZU5RZGdxTGFqaWpnazRCNlhhRU1vMU9UMG5QdG01dFJYcDF0UmhSQUF6TllveGExOEpmak9tUHhtREVIeHNwMHpHalBDS0FFby9ya0xwMFl3Z1dUSGpNZG5RbDBlc0lMaG1uSVNDQ0NpWjRNQ1ZVQ0hhV3ZTSWJPNWhtOXNmclpxd1NNR1daRUZWYzVWQ1ExejdoOHFrWnQ2V1F3Y21NR1l4SEFhRlM1VDBiczhmVk1tWklJYkZEOXFiQ0h3b051dGVsZDZzOUVDY1VJeWpBbm1BdnJLdkpxb3NqSW1sRlB3U2lITUlKdGtoZ0luejVtSkdlZ1dSanpZa2E4VFFJWWlCb2Y3bnBqbW1LWmlKblV5ZE5JbUNhampqNWdCYnBuT1E2S2RxbmIwOUMxeWJLTllEclF4Nk90V3FySXlERWpEaG5saEJqbllzWnNHTWx0a2pHakVLa1J3V2dlVGc2Zy9VQzNMVG94Y0ZUVlVkbGsxQnlnOEJBRUdXMGJPamhxWGd5NkhVbUhDK2p6ZDVCSzBtSk1tWkVIWStZMk9Ybk1XRG94akJ3ejBqQWFYUFhleUVBZU1XM2I4eXdMSCt5elo3dTlRUmZkaU9xYXRrSERZY3RFYmtISG9xSTdNVWJiSE5mTU02UDBmelhqcStTNUNRMkU1MitUOWhGbUFNYVRMWG5jYzJsdVEwclFvbzZWallDN3J1M1ltb1dPMWRBTUxFL2w2VlJwT0xxTjZObVlDaGt6ekVqRXp5QzFua1hNV0RvNWpDUE5hRmE1SzEvWlk3b1d6RHMwK0xOcFFZeHVjRzFjbzZOcFZ6YzF3NldiS3lJL0hFcTc2TjJiR1RPQ3BoVmZlc3FNU3NhTU00R1JZOFpHT05BSTV6cittamFqUE1PTVJwTXJia3hrbTJwT0N5V0g2YnBzeU9uZmVrUlZTcnVFaFJRa1d4VkJReFNsbmNNbTE0eGhkSkptMUk4eW81MExZN0dZa1lTeGRpT2U3cVJoSkVKb0pZYVJUSzRCakNaZ0xCZTMwYjJpRStQUm5xdThUS01zM2JScHptRnBQWVAzZExCQUYwKy9XQ0FNbnlwM0xpOXpYSFdHR1ZNeEkwWkJabFJtd0Zoc25qRzFUZWJEeURFakJRTm1ORGx1ZjN2QzAyUGxaVmxVWklNS0xUcUVkWkJNRUNaNHJhYzVLRU1rVk9iZmljcHZObENzVlZNdzVzV01TaWFibkJXTU9USERIM1VkeXd4V2ppZk13QVBqT210ZktoSU5MRHhCUk11dXEzM0JRaTNPUzRJaWVhSks5NlI1T213VCsyOXA4TWxRTktiTUtCMWhSdVdjWTBZaXQ4NHpvMUxKWkpPRUdRUmp1YmkyODdiZlA5Qk4xRmVXUnRXbWF2WDdqaUU5bFV4Z1FHMnVTRDEzK04zbzF0VnFBR002WnBSbTFobUY0Q1NwWFFsZ0JQY3pUcE5OTHVUR2pIa3dtQm1zSUo1bkJyMzA4ZXJkWHlxQzBYVVUzdFo3c01HVCszMlVuRTk1Z29FeVN6Z3duYmRmWE85UXZEaUpHVEdNcEJsVE1NNHlaaENNbFhsbVJEQnFVUThmbTBFMG1zM05MMzhydW1OWlJlM3BpSzVMVTFCSFVnUkxsTHNEM2JIR0I2TTdONXJFclpveW81TXVRSU91TlRuT0tCZm1tSEZ2MFczaW0zSHZmbkNMS1YyQ0pzeFlqWEZNbTVHQzBZeGdjRnpwOHRaTlR4NE94OTJCSnV1dTVOazhqeWdxcTVvK0hvcnl4OG45d3lMbnM4ZzNnOVNJNjR3RWpVTENqR3dBdlhlNm1IRU1HS3ZSNGNtVUdmSGNMMjBHZXpYNEc3c1R1aVBzYXA2ckliVTZrcWRyc3UwYWdqaWEzRDVzK0M4NVdFMmEwY21ZVWMrYmRDWE5PQ01ZRithWmNmRlN0aXM1c1JtZzBhaGR2WDhIc2VQQUdvL0hMZ293YlR5MkhPbnRGN3ViN1U0amZEM3hIRE02WWM5YXI1ZXlKMnJSa1VGdXpGZ1l4aHd6MXZOaFpNeUlUdGI4azVORzJnejJRSjlzWEwrN001bDh4TExwMDJUeXI2MTdteDhhaVJjVG40NFppWktMSFM5R0liUVFzU2lFTVNPWStwMXJ6RGlHR1MwL3VRWnpQd2FEbWRGTXdHQzdaZi93ayt1ZmJlM3U3SHk5ZFh2N3hxdEcralhtWjV0UlNtMlVMSXlvNXNxRHNWZzIyYjExT3cwak9tMWR6L1JvaVhsR25oazBCWjAySTlndXBScDdKaXVGVnIzWVRLTkltcEdNR0NHUHRCbnhPbzlzY2l3WTdmQXRMTWVuelpnSGc1MnRULy96S0RPeU1OajNLeFRPSldhRVprVGJaQzBIeG95UU1kT011T282OXFwbXpTajZIK0UrS2RVVHlmVzh6WmlDd1c1b1hGd1BVbXNzQmowTk04d0lEd3RZcDdZWWpNYXNHYWhmYU1ScXRNNHpadVRDdUpTQTBRNjFvSTlLbTUzZVpNdzRBeGhKTXhKbnJTeTkxcUlCK2JRWlo1bE5mQmpCbllSVW9iRWVIY0FuQWtabTdKZUpHUXZEcUdiTjZNU2xSbXhHNFRobS9QQ1VNU082dWhQQkNFN2kxOVBYRVRLbjhKRWFDOEJZbmd1akU4ZlFVbUJHc0V2K3g5dTU5Q2FPWlhHOGQ2bDlyV2JaaTk3VmQ2aWtWQWtRcXNpREZCTWc1S0ZNQllqVkpaUXNwcVZCbWtWTHN4MXJlbHVyWWVFRkN5UVdIaUZqMmJKa2dTV254Tk9Xa0pDOTRBUDBSNWh6N3ZVVFRLb0NKS1NlVWFVUy8vSS9yM3ZQUGZmN3l2aDVUV1g4QUF3bUFDUDFjc3FvK01xZ1Z1Skw0M0Zsck5UVGhURDhJeFpCR0c1R0hwWkdPcXlNNjduZDFuVmd4SmNySS9mRHl2akgzMzllb3paWmhPSG1vRzU1NGdVVU4rTktPWjA3b1IwMXYxSjdhbXoxWUVRWVNtSyszKzk3eWxnZFJ0Qm5MTUFJN0JjNEFZVjV0SE5uYlJoUmhwSjRLV1hBUjd6K3kzLys2eDNMQ3NFbzB5N2h1MkRyWTdDbkt4WHF6M0MzQ2xhRk1ZK2k0aHZLRW1VNHV5WnpqVHRyd0VCbHVEQStMNEZCMDFENHdSU3BvVHdUak1BYTZGeHdqVmFHdDFFUURXT1ZRODhMeXJoeVQ1eFFPemxkYUJJTzVobUxPMnJyS1NPL3FBeC9FVFJDR1c1cHNnbGw0R3lxSUF3dnRucnhoRW9qQ01OckJJM2VhMTBaUnFGUWlGU0czK0VXb1F4M29ZdnVPenVoZFdVWXI1ZkF1RjhLdzFWR2JGUEtPSStFTWErTTNGSmxSTUI0c3hsbHVDZXpxRFNjaHZwQWZDMjZUbU4rcnpYeExNcUlMOEM0RHNVUzEweUNNRmIzR1ZRWnROM1A4NkJCT3dtNURacHZNSS90dGE0QWd3YldFSXpLbzhxWWgzRjdkN29Sbi9IVEtqRFNqK3kxTHNBNFh3VkcwR2NzVjBacXN6QzJYb1ZoZUFjWWczYmk5ZFM3cHJLNFZlRHZxSzFoSnZtSVpwVWdqT3VnTXZ6T1Iyb201WTFGa3hBTS93VGpuLzMrclhNTWg5WW9RVHRKTC9SbmhHdVR6TnNmclZzWGxWRUpMUHdGWVNEN3dKTGZvekJXOGhtLy9CRUpBMm5jMzV6Yzl2c015TkRmVHdyRGlLMEY0eEV6Q2JVa2hBK2NYQytGVVYzYlovenl4OWVnei9DZHh1bTlOSk9xZlZIc003ZDNkMzZSVWx3c1Q5eHRlQS9HazNDNE1Id3pxY1RuOTAyeTg0ZHZmQ05CRmc2TXF5OWZQcS9oTTdZQ3luQmo2eFU5RDkrdlBoaUdyWkxwRkhqVXVsK2tUZlhCOGlUbHRZTDZiYkVydzNCcitFb29Fdy9rNG41WExGYk56b0ZuQXVQVWdVRkdScXpoTXlKaG9ESUF4clRSbUJBZTFmSXR3L1RwZ2RvNUdLSFZuZWRRUmk0WGRKK3BWT0E4Z2FlTUNCaFA5eG1lTXY0ZGdrRm9BSXhKby9IWDVvY3BuYzlReHBQeEluTWJQSm8xcDR4RUVNWVBaNkJSQlh3Z2xnUTJUVUlIc2hpeVMwQXFrd0FNNGpQZXJLY01EOFpWR0VZVHgyYzBQazFCSUtBUXlhcWVNc0ZVWTA0WlBveW5lRkFIaG5OZTBWMGRkMWpFWmJuaTZZSjBNSGt3NkRGNDRqSTJBaU5DR1o0SHBUQnc3QTRsMGtTRnFKYkloUE91YUdXc0FHTitPWU84NEUvRVRGd2JDUjNISWpaeWNSSEl1ZFpYeHRlbE1NQm5ORDlSSFBqNjBEd2F6RnJwdVJPTWtjcDR1cy9JRjV5RHJKNHlVQmFaYk04eWN4VW4rUXllK1dZY1hWQmg0RUZPUDdTK0lUNWpheFZsZlAxbkJJenEvWi8zTXdPbnpMaERtWWhBcHN0aDVOYUVrZmRnVUNPSjV6T1poS2txWXo0aHUyMDdsSVJJeGpiUWphMHdqQzlCWld5dHBBeUVzWmhvbEcrK3pCN3N3ZlNEZnlGUXMra3FnNGxXQnQxNXpxK25ETWR4VnZLWmRrL282QXBma2QyMkhTZTlRUmdwSjVJUUkzRVMwT3JWV2pCZXpjRUlsMm8zVjVha0dtQWxINDV3RUZFVFlZZ01VNHlBTWJkemtsbERHYzVHV3J6ZEcydWR1bTRUR0RTV3BKbFlTMjR4TjVaMWsycUpwRVpEV1p5UTVlQ1FNbDZ2bW9GR3djQzF2eFBNdGs0ZXB1QXRQaHpoTkVGSU8yYXRSMkJVSEJpRlZXQ0VsVkhKdENWbFg2L3JkUUZnWEJObFFLb2x0aGdlcDk3WUQ2cDFJVExVUms0OUdGZHJ3WWhVaGwrZGxFLzZ0d1JHYzJyWXhxUVpnaEhzZm96YVU4czhiV2tuckl4NGhoZjI5WVA5R29IaEtDTU5MQ1JoZ05QYnVJa3RpZWs1WlZ4ZC9mclpoN0cxb2pMSXhra282NnE2TU80SWpNYmt3Ykx3T3lLSndlYWRWR0N6TmFTTXAyeXFSY0ZJQUF6N2tzSXc0eGxaVHVBbmtsdldlREFoVTM4YWpSM2I2b3VFQmNreTNLTDF0OVZodkZvR3cxTkdHV0dBSkZSRzdwOWFWdFZaK1V2RnJ0M0Q2YkdvdXJXd0FXVjA5UDM5T2llWWlUZ1l5SFVzbTd1MkJFaUt1ZVBqcytNenJqRjlLTGN1YnRGOWJnZ0dWY2J2Q3pDcUhvd1RCd1o4NWlLVUowVmF0NmFjRVR4a0NNNzZQbU1lUmlMaHdrQXpNYTJaeENleUxWbFN6aHJ1ZlpnN1hOT0FEUERDWjdFaFpTeUhVYVl3UGdHTUc0U0J0VW1SSVpPSVRrL3VHQkVuWm1XRFBxT3lZalFoczFRS2Jrc0dmakNCY1ZuYjFtemJHTmlTTEdjdG0ydHdaRFpXRTlTeEEybzl4UzhqRE9Qejh5bWo3Q3ZqcGtVWE5ZcnBmaG9IbWFsakxGYk1kSmJ1OE5BU252cUx3bUwzNCtPMUdrV1JrUXQ1a201VmNtM1RIQ3I3ZFRMVnIxYlhkUTFnOE1LMEFRYXlNNTFNcGpoWHJ6RVZyQmF6UVJoYmo4QWdmVzVCWmR6aWdoZm9JbVhoRE1RSmZGRURRNWp4TFRrT1NSR0JrZkVINXNBMyt3bXJvT2NaS01jUytjeDVKbCtwUUE0K1ZoU3RzMytBRjBOdDE3WjF6Z0FZTTNDZG9JdXBQWnZaMCtiUlRtTkhpWUR4MjdwNXhuZGhORDBZZDJueFpLWk1RS3A2QTBlVzRTQkt5SmZqV1dTUk5VMnozVzRuOGxRVytVUzdYUWsvTkhpR3pOeWllYUhOOTZTaE9vYVhPdXkxODVuNGVWc2QxT3UxMmdHOUpldmdFbUQwWkI2TUJJSXFoTFZVU3pLbWpaM0drU0U5SjR6UDh6REs4OG9vOXZ1elFiUEI3VGpqV29ISFJMQ3VaVnoxazAwVkgyZ0lqM1QrTnA4ejRSbUhFanhlZ2JxR1FnSWVHMTVtdTFMd1NGVGF2YUdnYU4rU09MenVjS1FNelVMKzNCeDM5RnJwd0wweTdBQmdXTElLd2pqbXptd2UvQlNqRGhBR0ZBY015Y1V4R2Q5Y05Qblg0ekJjWmR6ZGlrWEpBUDlGSjlNZjQ2UlNqcnMwcEp3Y3oxVXl2TkxCNFd2ZkJQNXRIcFN1alhBUW16QnNrK2VHOXdnYXZoVDNQY0RDSEFyYUtMbjdrUzNWV0hpcjFVWkNyL0RXSEkvMG1udjlEODdOMjdiNW1JQXNHZ00xTGNkYU1mZ2lqcjRINDZkbmd1RXA0NkpsMmRQR0VSMWJxOU54aC9DN01jdktjWWlHR256aDlicXU4WkJMZit2VzRhM2JaYlV4VHg1YkdiRmQ4dnFicHBwVUcrMmgxc1hSYjEyV0xSMGVnamgwL1VEZ3o5dWdEREFUcW95T3B0Z1BrbWtaK2hra0Z6WVBXV2hNNUJVS1EzdzVHS0ZvY2c4d2lrVTBrdVlSaWZPb0RlNzQzUm5pTUhxZ0RWQkdyVlk2TE5XVjNsQ3IxZG5kWkhKM0Z3Q3dnb25mYlBoRGNtL3ZmM3Z3bnRIWUpERE04VzZkL0t2ZGo0ZDB4blpKSDZrNUNvTklvMVl6aG53NkM0WXgwVEVOZnlqR1JJQnhiemVmRndiWmV2NDFFc1luQjBZZi85bzQya0ZkVEd4VkZRYWNqb05COVV1Yno4Z09qTU9hTmxiWUxrdXV6VXJpczJzcVB3UlpzQ3k5ZHhMZjAzTmdKT3RzMTV2eWlERHFCd1pmVVJYTlZrYjd3SU9EcENzaHczLzkwTkV4bEtoaUxBVXBYOW1CRVRTVDZndkJjSlhSRnkyNzJTQkJmakMyeERRL005NXg3eTYzT2YxU2hjRG93UGc0MHBKZDBBVHIzRHdJbGlKb1hYYlBmM1haTVhFYmJZU1JCTWVpR2Rxb1U4TGJXV3UxenJEU2t5U2U1aG4xdXNERTVZUnNLWmNJQXdyRldCcGczQkFZeHZQNWpFVVk1UVZsaURPakNjcmd1Q1BodHRYS3l1REpkRzU3KzVJRDA0aWZ1ekR3TnJXUHJBY0Q3MVVEaWV5NXlrQVlTZzhQY0xiQlRFYktHSWNiOW9iS3R6cmVtbFlyamEvamtLWDBFTVlscVUza25Hd1o3d0RHOFFCaHBNRm5VQmdRV2srV0ttUEQwUVNrRVZhR0tHSmNQZHBwY29PWkxJdForS2wyT0E1aGdLbjdNRXJvS1pMd3kyNlMzQ1FJWUJ6bnlUb3dOQWxkS0hoVlFZSllpNWxKamhkS21GclVhNEtaaHp5bDV5cUR3SkMwZDV3SFF4UXRqQ1pUMjJvVlh4Nkc3ek5VOUo4N1dEKzNXdWxVV2lUZnN1M0w3VnJOWmpLK010aU9KZ2lDNXQ5WHlpYmZhNUJWdnFmaVlOblJFR0cwZXhMdloyVERVYWxHSHArUForS1pzREtrQVlHQlpzS2tXd3dKcmRPSHF2aFNNRzRXZllib3dqZ1QrSmFZVG9PYlI4OEdNTGJyQnA4eEhSZ2xNQU9wbllQQW1XU2RPeWE3ZTRyRW0wTnRyK3ZBVUVsd3pkUDg2N3lRYTdlelE2MVVwM1dxQjhOWEJvSEJUVlNFSVo5QzBuWFVtTXhPeFF2Q3dsa0JwVEIrM3ppTTZrTFZDakJ1UFJqVGh4TUNRNVNMRVBOdzlyZytrRHdZYkYwamVSWEdVNktMM2U1N1JjclR2SUlsTUw2TkMxN2lCWm5xZUF4Q1VrYUhjOG80OEpXaG5YSC9wKzE4WHROYTB6Zyt1ODUrTm5QL2dEdC93OTJsS1hpTkUySjdxeVBSeEZweGpJM09FZEdGZ29JcEp4NDdwNklsVG9WQlY3cHc0VUxJaGNPSUVVVkdqSkJJakw5QUNMcHdPNW1CZHROMmM1L25QVDg4SG0yU2FzZDIwUllhd2lmZjU5ZjdQdS96UUdoOWZvbUh3VFZNZGs2TFdNSTdKV1dJTUJMMHFnZkM5OEE0K0pveUFFWUZZZGhLMnVrMUQ2UFgzUkpnUE12bCttZG1LRC9NVnkwQ0E3eEhxMHJDaDZaTWtnMEpoc0V6ckVLcTJ0NGhZNVRKMmtrRmpJTG9RUGY1cEd0Y3FWWFVqZEZwOGZSbWd0K1MzRXJrTUZhWnR2MFZHSUxMVVBpTVhkNkJZdlY4ZVFqSzBBSU1kZlg2NHNsamhOSFFuQkVZTzdsY3U0dWxLMGlqZnE3aVlaU0ZuTE1QSUg3ZWxtQkFwdHJieGxWMG1Jcm5DQXlGbVpDVExpTWZXdmY1ZE53MUhlVHpwL0JIWjJsM0ljMklTOHI0Ymhrb2Z3WjZlTENRWjJCbzNaejVERnZKSnNKb1F1YklLK044QjNLcUYxaTRucFVoakdBdzJlNkxUckl0aHpGc3RONWhOaTZPMW42bVVJYmdNN2FJYXlwaVliZy9hRXd2QnpnTnZqZ0pkVG9Tak5DQi9qQkUvWDlnaEpZcHc3dUxTZGN2Q0VPTUpyYVNiaXJBR0Vrd0NxcTZFa2F2SzBVTWdDR2FpYW0vamRFWGNwS2RaaHVLdWlidTRKeFhScjR3NGRCTVhOUHJJdGJKa0lTT2J2TDVUY3kvS2k0TGY1bEdDbmdyNUVocnduajA0NUVFdzY0ODZUcWNqeVlBbytNajZYZ1I4NHdTS29NVURielBFTTNrV1dGbkRzYlBrSUl1aFFIdXRBQlp1K29jYWxWTXZQcXRCUWNLZjV0d0hrT3RWb0pDRFErQ056ZHg2anN4MUhISnhWOFVnREQwRG9vOUNZZmNBSU1Kcitvekh0MEpnNDhtSTBrWk9LdC9PaXFlYmtJSmYrbXFRZjVUcWVGUnBjS0JGcG9UYmdZRDhpN01zWmJBNE9ydm9FeFRuYmZyRGU1TVk5aW9Mb1JXdkNwb2RYV21JYWZXOWtkRmlDZmt6bVR6dEpqSGl3SUxmODNxZFhrUGZPR2pONnpQSFlpTE1GWTc5anVSbWNuY1ZZR1lqbzlteXNBU2ZnQjVNUHhrQmxWdHphWXVrZFNRd0doVmF4S01NcWRReGp3TXdXZFVlNmdMMVhuOVNrT09RYnU5bktpTW1oaE5IdWRlMXFmVmZuOE00VFIvSVp5TTU0djVRYlZUY1FwWFNFNkgzczZjdklrR1ExUWdIbGtkQnBqSlNVb0pRK1l5OUozZFM3SUJoNGZoZFpZT0c2UGlML3NnMDhIVVZxcVZ1UEorL2drbVhSZXpwSXVIWVJaZ2JDK0gwVERzTmJiUGVlZnF3V05BZzZrUC8xdFFoZ1RqNmNzbnpldnJFWjZCVmdmUGk4Sm5OS202MUIwbjBOQTd0RVozT014R2srbHd3TDBtakQvY0RlT3dBOG5lelY5T01mVUZNOW4xZGx6alNSRXlEYkNVUWFNNm5wWkhGODhCUnE3d3Nud20xaVlLWld4L0JRYVVyQVJHdTBHZWhLTUh5WW5ScE9ZaDl5WmszdzBlZFdFcHBLdE9ya2Y3K3plajYwRmpYQ2s1bkRoUHpXV3hCdE52MDVtalpKYXh1KzN4U0dSMW40RU9OQ1h6R2U3NVcvakRRKy91dURFWjNFQlJoREM4WG1lbkFubFhFUTkzOGpmWDE1Z2s3d09NUXVHNnEza29EQ1R3VjRCUjVtR28ramc5QXFyVVZ6a3B6d0FZdzBiekFwV0JKdmdZL1hXbHdrMHY2NlMvVEZmcGtOWU1wMFVkQ3Yvam4zL0x4bzZPVXY0QWdSRUwvN0M2TXVaZ3lKVGhFL3FsZDMyNDdlVnk2dXNnakYxWDVRQWIzNTd2bzF0SGI0WXdubHprOFVwVURzTmd2bGNaQklaS2xXczFyb1pRd1RjTE9Ta0RyV2xxR2toZ2NtUXZWTzRDNG5hdFpDdFZuTng0UE9Zc0ZjaHhFSWJERzNMN28rbDBOTWdjSDZmOGNZQVJqOFRZSDFiM0dYZkRPTlQvcjRMcmI2eGp2WVhzTG5Eb1NpSHdxZURTOTNrVXVBL280akVZOVRmQkFHV1lpSmxzcTk3dDlPcmxTUStTcmlZdS9lR1ZvZG1xRGN0TnZEREk1Wi9na1RORzhncXVqSURmYXI1UnhlSGF0WWRQMG93OVNDRU1ObUVueWxnWGhuK3B6NUM5T0xIZ0RhK3d4NkdqSTAyUmVXazVFaGgxYTZwRk0vOGFETldDbWJTaGF1MjJTZVdpQWh3N3VPZW0xMnErUW1WTXJnQUdTR004ZVlyclpITE42OG1VcTloSTMwNUgyK0ZmM09DdHIyNDNrb1p2MzA4SG1PT2pWSXFPMndPUm9KK0hzVXBQbDF3WmdVVmw2UGxYRmw1SHgrVVZZYmdxcFZCak1PSWJBOGp5bTFGOXFxNXRJWXluY2hndjVEQmVLR0JBYUlVeWpwUXVPK1FZTk5jdWc4dkVUVkNEcXNlZ01XMXRhY2FOY2gzN1VxcWN3eWE4M0JRK3BKM0xvWE5Ha3U5UGtsSGF6cnhKc3Y1Z0FJS0pDR09sM3NjZmszZkEwSXNiY01UTkwvaXcwK25vOERlTU56ZDRjL0t5MmJvY2Uyb2VjbStTQTd0L1ZkaFd3cGd6azNNUnhsbS9WOEJFUTZXQ1FnMElWcnU5aTZlZ2tIcFZZOEJtMkZwTk0rUTRUcWVwMVdwR3RYWU9ob3VZaVNOdzh2b29tZkxiRXlkUkptS24xb1h4VTVxWVNZS2NnUzUvZmpOYmRzTHZ3WUU4Vk52Umo2Zjk4cVErcUpjYjQ2RU4rM2cxMHIzSm4rc1NqSE5NUVJVdzhBandaNEJoeHNOeEtOTnlVS2xkNU9vY0JOY21Mdi9wUWpWQ3BqQjV5SlF1OG5pUlY0YkxwWk1ydytXeW43eE8yNjEwTUU0endUQ0QwUVJoL0hGVm4zRXZER3lhSWpCRVplQTNncTNUYWozNDl1cVljNEJQTXhtTkprMXQyQ2VYYUs5NlJCbG1nRkVuQjUrRjg1NElvOUhHZzFBZXhzWUcxNi9qZmRyT1RydFZ2dG95YzkxdXRYckZEWTFpQTcySGJBa3oyY1IzV0NJTFVSa3VLdjM2aUE3U0FXdUVUaVhaa0F6R1NyWEpFaGdMcnpsMzU1UWg5TkpyeVQ0Z29VRURlM2MwSGpWWDdYWnhKVkIzS01Eb0k1emVkcnN1S1FOeHRYcXRGamtEM2ZCY2dWdUFUNzk2aHRzOHpLUlJvN1kxbTBnbEgxZW1tOUVRbFVGbDNyeCtuV1o4UGliOTVqMGJvdFpYQml1RHNmRHFXVDlEZ2VtdlY0UUJOR3lrTzlWb25IVzRtWXhuOEJrT3p6d0c3TkY0c2NkVjhZTlgwUUtNSWZ3VmI1L0ZmOURnL2lDT0c1N3Q0ZEJ4QWxkWS9zTlBwSnBORVJGZmJzcVY0YlN6UisrUHM1VERIazFHTTRrMXplUVJEeU5HMnYxa3J6a2ZBRU5xcHRkS1BjSWVzOWlWWVZCTUlUTFBkYTZZbDNSb21HVWpkalR6eXBqQlVDcERUeVhvTUJzTEhBU2lhVFlXL3g0K2d4VjZIK2RmWnNuZUw4cGhlQzJLYVFuYStZbE1mSWZiQTN2Y0RQaExOaVJXSTBlQjBoRG5EaTBvZzhCdzZLMVV5RXZGNklEZG44M1NBb3pzV2o0RFlZQ2RCQUtCd1B4MEFIR0t4c0pLb0dVdzVxWkdQTFRoYi80UjBqSmhtSmI2REtGVldtdUp4TjBNRzQ3Ylk1a01YNmlKTUI2dG9BMEJCbmFyQkNNQmhaMlEzUjc2YjRDeG9JeDdjS0F5ekxOSFNCNSs5cExvTVdRVHFSYVZRU1pGT0t3c213aG4yVVE4bGtuUkVidGNHU3ZBK0wxb0pwRkVtSkUvTEpoVmFoSU1mank5WXR6aDNXWnluemFVeWxBS1F4eVBvRjQwRS9paE9DazZtbUVTZEpabW1HdzZTc2NEYzhwWW9UWkpabEVaZmliODVUYkFYejByNXFzSUkwVkVHaGJ5ZlVqRGQzUmFXVnVzNTF1VllkZ3dLSlNoMFdqbVlvazBOME1HZzM5Ym9iVlEyV1NLVGpEaERNM1F5YisvVFZGckt1TjNQNlVCQmtPbmJyOTh1RVVQYWw4ZVQrWmdPR1J6M0hUcktNUHdkWjloVWdTVE9SaGtQNEhhRW9nZXM4RUVuWUZhTFhYODl0K3NsVnJiWjJSWk9oSEdjWjBwRU1aOFBCR0hsODFneUFiR0xpckRKUFFJYjMyam1ZaFBzanlldTVReFg2WTVMQzZMeng5bFkwdzRHczFtVDZMaEdCU3QzMEVaTk5qSWgzOTl1STBRWlZDNEE5d25qNjY0bE5LN0RJWkNHZUo0S2pMdVVHZ1ROdHduREg2UW5jSk1URE9YZ2M4cnhKYzNNbVVRbnhISnNyRmdrTTdRQ1QrREtPTGZRUmxodjU4RmFYeTUvUmloNUxjRk16dnhlcjBQVXNac09vRFlRUDRnR0FzK3d5UW9nOWZHY21WWUhKWUlaaGNoaW9FTUl3THhNUEk5bElFMVBFc0cyMzYwVXBRVjcySW9xWkZKekxzVXF3ZUZnS0pVaHZReVN4VEdRMkhzTFVZVC9Kb2UrRW9hbTNxcE1pek9lRGFkaWJpdGJtc2tGUVdSS0tMSkNzckFhSUlGTU1ENDlkZGJ0NXR5ZjZJKzNuNzJmUXJ4N3dyMFF0NGxYMHVwTStMYlBJMVJMWXltbi9rTUVjYmVXakFJMXkzTTJzMGdFZlBHbmxHN0pBRzE3TVl6SjVtNHo1cUFraldhT3NvRTFva21qd0RnbjRneUdPWVc3ZVREcmQwZC8weDkvczkvYjMyZnhOdUMyWVpqQVliRHBjUFpEZnhUS2ExaURPYldLajVqU1dqRmhYMTdIbDBvRUFtRWRCNlRiZmJpV3llRHdXYjh2M0YyUHFHSjVGa2NUNmM3bldSNlpyYUh2c3l5YzFrV3B1Y1B1MzBZR0xwbmw2MWp6R1V1U2xCREVncXhnaG9MU1FnS0tkREVSRzNiS0swZHJaVEdnSmlpREFvMlViQWJVaUFaY3RsRGtidTNPbXhkckpKS0pXRDFaZCt2TkVrdkRaUHUrVjBTZ3FTcVB2VjkzL2QrWmYzZWozUW44NXVibVd4MkorcDAvdUU2WTN4OFlueGs0dHVmNGtGVVo2QWdlU2NuQXJoMkxzdmQ4KzVLejNXOUQ3aDFlV2lpNk9WeHE4YzJhM2I2QzRYNFZuOGF2U0J1TExING9QSE83M3JHL0Fjd3JucktETlp3R3ArWjdxOFZRczgzOXZhV01razdkdU1ab0JGamNlK0NlNWxNZWdrWGtjaGswcHV4VURvWUNQemh1Y240eE1URXlNU1RUQUhCQ0JzR21nb0VTTGwxcmdBTXFrY1FRMlZBSnJtZXVscmRIb2QxTGJxejJ1bDBkdEx4Sk42em9aVVZKdnNITFpsbXJpcnUyNVZoTEoyZm40TjVtdEYvZThaazcxRk9xQ2t2T3F3QWcrTmVoQmQ5aml0bFVLb0w5SGkyQ0RlR0lEeU9CVHljajBiVG02R3NmK2daZi8xNi9GT1ZnVmhNam8vODR6dFFSampoejc2RHNVVTZ2UnBJcEt0MGs2cTY0aHFtRTJJRjJjWmdMRTR0K0pkT2VVRVVHWUU3WE1xRVNRc28xd0VUekp2bE42WWJGci9UYzJmbS9XRk0rd2U3L2pnOCtGWXA5R0tYNHdSUmFqWmJyWmJBYjRkTjB3WUxzM2xSNjZySFU4Y0dEUGVDWmRucVRaU2kyWGdoZjYyTXA0OG1QaDNHNU9Ua0JNRElJaGdvblp5LzB3SmU1NVltQTR0dVYxRlVxOUZxeGtwcDJrcHZDTU50bm9ydmM0d2tpVUFEQnQxNUZRdUZkb0sydVduN05ZMUJmL1VaMFB2OGJRMFNybjZiNjdtbWZMTVlsYzJFTXBzWHF4MmFacEFrT0k3bldGb1MrWFhjWVVjd2puOGx1ZzNkUTZqcWdnZXRjckM0cmQ1SU1KOFBGMEk3aFVFNUhuejY2Qk9WZ1dReE9YbC9jdkw3SHhFTXFGa2lvQXc1UlRwSlhFY3d6aTlyR21GMVVmaXlSUVV1UGJTeUdJWjV3Zm04TGw2ZTVGZ083V2pPQ0R5UHpuaHB6WVlOKzJBQ2lobWZCM2Vtd3VHd1B3WHVaM3F2T3ozS05qNzBtR0xLNDNZN1lHYmlzNkpYVEpJcGZ6cWRNbU5ZWXBkRC93OEZCOE93TE1mejlYSzVubXNKMjZYbEdkVDkvYzJ4cXJSMVZWWms0bXdSTFhaMld3T3BTRFFEY2ZMYkVNWS92L25FeERvK1lBSGo4MTkrQ2dPTXhGb2tLTXNBdzRzUFlDanRjMW50dVhSWnAvUkdXMTgrV3dBVUZxdWRLT3dMdGFweGp1aTBPUUZ0S2lpd01SS3pHd3R3VU5oUGs0VlhlN3VWQ2x1cDdNWGlycHRHL0RZeUFCV2RONUJjaThTejBaUVBNNjFFOXphV052YTMyZnBwWmdYRFNod2pzaUE0bGdmSWFDL29neUpYTC9PMFdBeFJHQ3J3M2t3QkRFMXJYeXFxMllPV0xrSktpYVFLb2ZWUVBoODB5dkhVczMraE5mNGZEMlBJNHM3WTJOZ1hReGdwTkNKSktFQURtbkt1S0YxQW8vYkk3cVdpNlkyYTVuNXozSE1EREI4Wm9zVW1DeWpZSE1QeEExM3dqRkNKejRHTFFsRUFkOXVaQnBubklJNUV0Tk5nWnoyS1gra2lzcnB4RWJzd1JxZHp1T1BCYlBFOWpxRlJ2QW5jYWdBN3kvRFNDWWlOcjNNMGJaZ25VeXpDd1RqcFlJZkV6QTZMcnVscXR5SExqWFlYeFlrQnd4bk1oMEw1YkRRZE5CN3VKSjQ5SHZsNFljRG5ybGpjdTNmdnN5ZmZvVEJKUk5hTWw3cWNwQk9FY1g2dXlDcXU0ejFWdVFRYTUyMGRWMVhLRFFmM2tiR2l4TlRMZGJwMmRJQ0VEQ2pnWkFWdVBXQ0NRSmsyWWJhdEhlU3ZVck5hclRaYmx4TFliQ2p3cXdHRGpQRzhNQWdDdU16L1ZoTFk0anFIb0RGMFRpcnVockYrakJkYk5JOVF0MDVvdXJPMHRNKzhMZGJMbkZnRlpVeVpkYVd0NkJxNlVacE9XUTBZa0Y5THNjMUNjaTJlVFNBWXFjaWZINDk4dERCUUZyblN4YjNSMGJ2WE1MYU1wNkNrRTlJSldLaWk5eW1YUlllU1E1R1ZjemdEUmJOQWtQcndURkVFR1B6YkJsMVpUMmRlVkhnZ0FkcGdNeDVzMmc0bFFtS2JFNCthb0pvNkRJNSsyMmlMM0g3Q2pxckplRWVVakwwNkdYQ2Nxc2pzNE1TZTBCU01EeDRVK1NqbXlaL3lZcVBKQVdzcHQ1SDFVbVMrSWhicmRWYXNSZ25NUnNudHk0YXNkYnVhYW5GYmxsRjdHZmpwRFVLQVVDU2NQUHBHTGZIdnAzY0J4c1JIMGJoaEFjSVlmZkRneSs5L05PWW1rYlhoODNHbkR0d0Job1lUZlRCdFZldktTbGREQ3RFdFo4Z3pPa3lPTC9QTmhyQ2Y2dlhJY0tnRDF5MGM4SWNsRHdZbXNQYWNGNXM1US9rc2hIdWR5eDNWZ0ViY2gyRytUVjVzSDRFZG9QQ2lFYU1VdnNzWGMxeTV6T2RFZHQrUCtmRENIdHVxMFFnRy9TclZUOFpqRUM1bHZpaGNwRHp6ZHRBc3VKa003a2tkdjFtNGdoRkkrSjFXWXRCOUtMa1YvdUdiVVhSOUlQK1IyK3F1Y2FPOEFPczBkUEhneTY4ZWZQNXphYUNNcStmakpKV1VJYlhLR3Q0blZucG5RQU1kdncyR1NoMWJwOXpKQzBGaXkzWG1oSDBlc005Z0pyeXd5bkxBNXpSRFlYT1k1Ulhvb3NwenVXcnJxTmFrNFRyTFhPdDFrOTlENlNaenlqU1BnQ1Q2NDlzYVU5bjBFcUVLQ3g4L1pZNlkvZUFDcU1jVTNtQ2JCL1U2SStXZUZ3b3ZLbXlSQldFMDJaRFY1ck9CbTZ1NmtmVjF5alBvd2dRd25GdUJGY3ZnOVdCbmNpMzQ3T3N4eUpMb2x0OG1qditQRVdCeDk2dUh2NkFTTkpLNi9yTEFtS2hCU2Q0bGV3Q2pwNkxib2NnYWxCL3FzWFhCdkpqbVJJWURoNmZwcFZEY255VDdLLzUxdm40WTJuSmdtTU5mRWRvNWpxbEtBdmhHN1dVTjJRdW9TR0pYU1d5V3pGUTQ2ZVVKTXBsV1c2eGtxSG1UT1ZvNWtDQnl4RTdCalpsODJGdy96VW9BZ3o2cXNuQUVwSzQ2TFRKN1FaOTl5Z0hGaGFxaHM0SFRVVDFtNCswMnF3VVBPQ2tDTlN4RE1DTEJ2NCtPMzRHU1ljTEFjWHZaK1Q2THUzY2ZQdms1YUN6bXZGRUdUTmIwcElhVVlhSFEwVkY1cmhLcVJwMVpMUjc3Vmd4OHZsN25XWUhuOWpzWDZWSWtFcy9zRkhDSHo0UjVZNnpZNXZpbVJLK3V2K2pRemRlTklycjBrOWZpYVJaWVFWNW1YNzZtNjJYMmRZM2JKTkh1VUlIZmNtS3V5QWdoM0dSNGpxOWt3R0NiUlFnbVNOd2NKRnRoTzl1ZnRYbk1pK1kzVUdFb0tJcmxBUXowNXVNS2hkcXNHVENTcWRRUDM0N2VIM3QwLy83NDVNZkFtQndFeVpERloxODgvTlBmU3VnTHhyV2JyNUZJWTU4OUFpWnFQZFVvUnlIWGFxNGVCUldPeFcxMkpGOUJRZ0IvNUFlcGxhK3N4NzB1c0F1N0NmTnZGNXNISEhmRWJrZDZnZnd1TDcxOGVRQWxDZGU0RkZZajZEMjIvR0d6WGEyWG1acDA2RWNUbC9sK2xoYUtPVVpJOTJjUmpObGpBMGFaWnhuTytQZDBVeEoyMHk1am9nWXpORjBHMWNJTjB0MGVqL3ZxL2VCQld6L1NHMEN6dE1jUHh1Nk4zYmx2aUdQOEZzTzRZakdBQVN3ZVB2ekxqMEYvTURITUpvT2xXUVlOQkFOSGFRUlppRWFjRFdjbkRnZFJXZ0p2L0U4WkZRUnc5NkFtajRWN21BbnlhdUd3MldJNFZxSkQveVBzWEVJYVNiYzR6bTI3Y2FaYnA1MitOaTZhdTJvWXVtbnVuYWFubVVYUG9wWW1HemNKa2hoVWdxamtZWkFFU1NCQzNvbm15VlRNb3lxdlN6QkZsUmlJeEVCR21FQ3djVE9MNE43VnphWTJNemQ0dTRYZTNYTytxcnhzZXlhQ2lLdmtsLzg1NTMvTzk5WDNXU2xsenc2RjgrY1RLSTIxU2wwVVFsaGVmZDdpVFFOU3dzMHhreUJkWEs5ODFVRmxKR1VZV29BQnRLQytRUEN3MktaeE8yWERraEpiK0Y4TThHNGdpMTRicnpjMlZ3ZW43Y2pQVitqWG5VN1hpKy91M2J0My84SGZNVktReHVSZkJNa1lpK21acVptbnI5RjNCVWVVWWVrL1phRzJYWC80QU5JRUhoK3VlNnZvUVRlMTJ0NjZMK2NwQ0JjZ2poYmFaNGdYYzFtam9MYVZPYjdlUkdGZjVlWkJCOXVPOTN6MzVBUmRVL09VZnc5eHNoSlBaVythQUtOUjhRWWtHQzRKaHR1aUdDampESlhCY1IyOE1QdHFudzVlVWtveTZQckY5c2Z2SUl2ZnIvR1VCdHdSMno5NkNHRHM0bzN3OXZLUEx4ODhRaHF5Tkw2c2pWdUY1QnNTSkROVFU3UFBYNFZ4d0NQdnBSL2J2Yk9oN2xtdi8vdS82dzhRS0wwZW1weDVWZHlkdHMycmcza1AwK0xCT0VOaGhLK1FDYzFUaWw5cHZsN25XNXpJN3Fsd1VVU24zNE5JT1FmZmNIelNpZGpBbHlPTU9oYUxpamxPWUZ6NlpCaGJNb3c4S3FQR1ZSc2NMNVFPY25hOVZyRXRyNW9zR0tHVjF1eGVxMVhEdzhvR3oxY0FDMTgrLzg5cHNBdjM3djhWamNsKzhpUUpReElHd0poNi9QakpzMWY1ZE5nSE5PVHB1S1gvL0kzTlpsRDNlcllQZit5aVFGWkJHWnRHRzhRSWs0eHZyNnhab2tsb1lDc2NpTHJUNVF0QkphV2wrV3Fkci9GUUtKMEt6QWhVQWlybFNmYndzSGpTMlhFc1VTc0JDVVpXck96SU1PeFhuZUlJak1zMGdjSGVWTHc1ZTJMOTArWDJzbTVKM3FwaWtpL2ZHWnpQMWM4Wkc4Z2k0Y3VIM240My9lZ2JJbzBIY3FEY0hTbVRud1dKSkF5QU1mY21SS2R4eFNEZ0dJY2hUM2QyOVpBNkRRYVNNTlFKY3czQ0ltSTN3dmVzS2U5a3pwdnM0ZUZGa2VWUzY5UnlpSzlYd1NTZGR6bFBnRXgyRnV5bHpnbmtnT3hweHh6UVVwVFRrOEV3eVk0cEF4T29CR05aMTVOaGlObjNOdExSS0xTRGZUc20wd0o1eE5lME9nb0RjT3hhSE02b0wwMkhmbnc1OGUyM0VvMi95UVgyRGhpVGNrZlNENUtCTUFERzQ2ZHZra2s2aE43TDZZQ08rdmFUQldvTm1RaGpJZE5vMWE1U0MyVE5NKzRBV0M1dFlxZlRCdU5RNDBXUmNWRXI1YVB6YWdaZFFxUGxOaTJqTnRiOGZQV01QMlRia2pJU01veXhuREVHSTRRNUEwMFh3bEN1RGM2K1ZQVzNQSnB1S1FPZnVvRTIySldtaytsMzB4TVRBT09SSkEzWmJreitHWXloTUdRWWtEVFM3cjFRbm9oam5aejhPQXJEb0RHU0dTaGFITldxWlk5bk8rZ0E5bk8rZURESDhDZHQ5Tk9OR3o2M0RZMUo1UWJZdE01UFdjRzlSVVk3K1ZoRDVHcWdqSDA5YUNseFFHQkFGSlNjZzJwU3pIQlNBbFVTMDRYbGhxc2VNM1JjdmJZMHNvWTB3cUlQUTJNMHFtMFdSeUJoRDRmMjNPa1gzeitjSURRR09mVHJPNTJvN0QxbEZuMWhFQmhQWnVkZWg1TUhmanFOT0VBY1VwUU1ZUXoyUU1LUGFqc0lkYldHVG9NdjdaaGpYT2EwaVRDYVZkN2RvN1pTckhnS1ljTlYyK3lGT3o2L1RLMkVyOFFpMThwVStSUzByaXNJbzk2cWNmVXp3VTVHWEpaa2hneUpTR25kcHBic0g3c043RlBQUmY3SW5MWXRqaXRqY084TTJSQ0FNOWtOdlNNUnRMdnk5RjZFL3VIZFN4bUduRVB2aGtGUWZEV1NQY2RoZ0RSQ1NiT0hEcVh6NEw4UzYzcFNyRzdCa016djVwb3R6V0hiamlXVll6UE5kaldMdHFwYWJRR01YbDdvL3J1Q0hmN3BhWkV2NUczVVNrNDRML0o4c2NrbmNSMUVnbkhJdFJzWGRBLytzZWlLVmJwY2x1WHBIcmpQUmNYV0FkZXNBTndhejJZN1BLaG5TYnYyQldYZ01hMmFYVWNpYW5lVlEzVEU2MCsvL2Y3aDlFT0VjVXNhWDAzZXFRdTVieDlFaVFUanlaTzU1eitFVStZZFA4RUJCc3hoMlpVczZHMWxhSXlieWkyUFBOWGhXeDAyazRGcWN0ZzZib3N0V3JsSWJSVTY3WFlXUjNYdDB5NTM1UStGekd5VmJWVkUxb3RLSUQ3akZEcWJaanQ3NWZZNTdla0llOHpXTWlLZjN0WlJpazFYaEdPeE5VTzNuK2wyU25IcUM4ckFzbUkxNkIyQnFDdWNUOU1wY3lFVmZ2djkxTVQwdzRjREdBTnAzSVl4NWowL2d6RTdPL2NtN0VxVmRsSnV4SUhCZ3VxUXE4bUlNdkNYY2pOOEJiYVR6SFZhMHBDeWxtMkxIT09qRkpRMngzUlBxL2pWc3RXVEd4Ym51WlZ6anE5Mytad0dZZWlUbkFndXJKYXRBaUttRU9NN3hTemZLb3FDajlKQkJ4LzVyWHVHUFQ2SEk5WnVodDZndFBOM0tnTzBBUjFhd3VjcTUwTzAyK09OZWNJL3ZadWFtZTdER0hvTjRrT0hnVEk1WWpHR0tXTWtUQURHMDJkdm5ENS9MQmJ4SjNPWVNWMzJSTnhpVTB2UEU2dEhsS0hSTEtnMmtoZThqSUxNS3JOblRiRjFrVE5RMjlDWnBzQm0xVG5zMHJPTmVyTnhmSndsL1FWOHlmajZOWC9SL1EvYWJlNjRVY0d4QjdTbC9GbVhCZGNCeXRDNFcySzFpeDRjbGZjYkV6WlJ3eE56Kzhvd21WVHpxczJOclhnaTZndVgwemw2enl6RS9ENzd1MzhCaStteHBER2FRMlVlL1lUeE9Zd3hHcStDZHJjM1ZrQWNJSTR5NHRqUzI3Q3dhdFJEWldpc1JwTTJRQ2VUN3IyUFZ6RkUwdWwwdTExT2NPOHU2NVNnOVdBQnZ2dDJsc1I5TmdPdkxGc1IrWUpMSlExQ0hhV09XSzFnTWNiT0F5VEE4U3lnY2wxU3VOcFNCc2xCcTNQMThhTS82VDRJV2JTS3RURVlaTjEvMDdoQi9HYTRuRS9ua3FtZEdGTkkybjlDRmpNb2pJa0pvb3hCZGIwRlkzSUlRMG9aZDhDWW5mdkhxMFNRTGpDeEhZK0VJMHlTaDk2bWxtR1FZb0lyYTZ1YitJNDB1M0ZmYU0vTWtNOXpWQ2dibDVkeEhZbWF0OGRhNXorZm5MTThDWDJlSzlaRlRzajM5MzVlcGhuK3BsMGhlYUYyMFlMVTBPaDJoTndDcFZNb2RaU3pkSEhoVFlWY0FiMGFyelhVRHM4Ymw5ZlQ0TGZWdGhXSStsd1NDbi9FS3dqZWtOUCtiblpxUm9vU1lydHV3UmlXbEQ2THIyVmh5REJ1UzJQdTJSdTdzNXlLQ1l6Wkk2VU9NalVQT0NCY3JLdlNYRW0rcTFORjN1SGxxc0VTdDZkcGQ1SU94MWNWQ3JLTXRFek4rN3g4NStiMHBGMXZuSjAxenNWdWh6ZTdUUDNWQXAwSmFLQ1dJRVN5WFVrZEhwZDFrY0tqSGlsYk9SUjI3R3BVV3JLYXIxQnExNFlIMGNOZkN5WTFNVmoyQVlxQ2NNUzRmZkg4ODZkVHQyRGNSeGdENC9Xbk1PNlF4aXpReUNkY1NTL0R4THdIQTNYNG9oZ3V1eHNHZWJtVmJORWd1NldYRk9Bd2xWYjl1dVhURW54S2ViVjFlVVVaakFpc2VGT3Q0bjNPWWpITHZJOXFSOWJSUG9VUFl0bE1zWmpwa2lpNml1UndScWJEL1Z3S3JVbWxKQmU2THVMQmRrcXljVnplKzdoZ01vTFZSTnVOSkRCdHB2Wkx3cEd3a3d2RzN6NUhYUkFXdzlKNkY0ekp5YzlnRUovUnB6RTFrQVpvNC9XTGFDTDlQaVlJSmZPQkgrV0IreFY4ZU9zYzZrTnRIVnhvTWRpdE1xOWR3bmM5UEFZVG5KUENrQzhjUVM0aEs0VENlNWQxZk1WVlo0MG05Mk9NSURBeHN5Y1VOQ2dXeVVmSEJ5cVVPcERENkVacEFnTmU4NXRxekJOMm44c0ZMTktBWWk5U1lJNk9ZbjdYZXZUVnN5ZVBwejZMa2p0Z3lDd0dFL0ZCbkl4SlE2Yng5Tmx6RUVjMDVDbkJPeTNzNzhtRmxvU0xNNzRGNXNPZ3RockpCU2Y5aXhoQklNci9kM2MyTDIxdVd4Zy8xcS9FajZyQjRFQWNPUWxrY0NXV094SHVIWjQ2Y2FLSXNSUUpva0dOVXBRUVFTSG13eGlUYUNCcVFKSWdPS3YvdzUyVi9qMW5lbWQzcmJXLzFuNC9ZdFBUbmxQdXltbFB0WnE2ZjNtZVo2Lzl2dnQ5WTJBUURZaUhQeTRyamVKRDdxSGNhR2FPVmo4Nk55VDg1L3dVdEo0cHdYUCtkL3NqM3VWTzdaVkdHR0xQanRndUI0QzJWN2RRRXBmWVhRRUk0WTljNnVibDVlV3AzQ3pWM3MzL0l6U21XRWhodUdFUURUOFlGZzJ0RFlqUmhVaTJsRzFVbng0QlIrcStmRWZ5UUgwQUQralV6MDkyUVNGYmJGTVhiZXZpeWxoK1Qwa0pTNGJid3ovZUM5V3Z1Ky96YUc3NEtHNjh2dnhKU0lKdDlkditmZlZnNHlTeGc3TW9nQkFrMEIrZHg4K2dpdnRXN1d3cGloWVpVeTdSd3VnRmhraU5mZzVET0dWbWRtNmhXVHJMdG5Kb3lKdlVQZlJoTGNHRDBoUVBDNkpFMXZZUFZ1VTdiUHh1YlhFVEc1aytyb3U5OGJRMW9jc0dIcjVWQlRja2lQUDR5R043WlJWQ1Fwd2txMlVLWXZxNFFsR2s0U2Y3K25LVHU4cWNWYUx6NGRERXhKZ3hpUkpHcnpDYzBoQk9nZVNZankwV1NvV3JZdXFHZkYwRnU3U01YZkJZS2IwRkhhZ0V1cEF0M05RVUY1citwRzZpTG5mZnNHMFlycDBaN0YyeTVKNVJ2TGJnMDJZY29qSzVkUXdMODhRaFhvMm9VRlRhUU9JaWx3SVNMeStQcVl0bUpnT3FtQTBqQ2FkSkdJeWdMNHdoQ2NOcEZDczNac0l6YzNQUlp2MnMwTHdndDl4MDB2ZmxDK2hNQlpCYWlVNVNJNVJUTWMzc0ovR2V3bkYySDNZMlJBOVJDSXVvZlNweXV6VHVWQUExSk9sZEdOYjJkb25GTGVrQ1VMU0ZKam8zZ09MelRmV3VYYTluSXd1QVlzS2hpeW5CWW1CZ3dPNHp2R0FRRGFrTkFjTm9ZMEpyQTd3eUY3dkN6Zld0Y2hya0FmR1JGck5MbStTaHI5WEJZMklKVVNlN0d3ZXJtS1lmZW5xdlZreFAzTCtXeERPRVIyQkI2UEtTSzNFUXlNRXhBc0ZqRmRrMmJyOUk0K3p4OWVVeERhS29seXBSUURFZFVpd21wUzZNU2JSTHVzS1FzNnROUTJsRDRnQ3Z6TTNISXNDL1ZtbVUwMDh3RVQ0KzVhKy8wTXFsVW9CcFlPZm9mRzhqS2Q2QkJrU05Oelk1VkdjWjlqYU90M0NQS0Y2aEpCTlJiNW5GTjJYOUlDWmpTTWV0ZlRvSmhMZEVPVDFGdW9tOWcrMU5pWE05dnBHNExXV3g1YTdtVVJLZ2lYU3hWY25Vc2hFd3lBeVNZTHB3c1VCaGVNSUlCc1htRkMwTk1vcnRGSTVqQnRRQlVSck4xdXVsUWx2d2VFUWUxS3NERGxqR0plTnFHOHI2Ky9nK1pQNVpxVlNES3JHTHZPZ01ERjNEQXpQeWluajdzNVhWcmJYZGM3b25ERVZDTFFOVnc4dmtkczczNDNpUWc5NEhmSFBsNUxiV2JoVHZVMCtQZ2tTcTJIaUcrWGhwTVFaWkVacGdzbURaeVZoSUdNR2dVeG1hQnNFWVlMRkJORFFPbThiY3dzTGRjeDJ2dHIvQzdJSkc2VE1rU0s3WXVLclVMcytUeThZUjhUVzZkckJPUEhCd2dvcU9scjAxYk9KWGtuaFRtUE1qd0ZDbkw0V3ZMT0IrcHd6dUE3aUZ6bTVyT3c2TnhlNFJTQUpCNUovQUd3UWlkd2YvSnRnRFNNelBoTU9oMElRSEM4c2ppa1VnNktVTUp3elNSciswaWs2T0NZT0R3bU1oR3NuV0wzRWJYUXRmSlZUSXpWTytXcjY3ZXM1QTE0UlR5dGJXMmdtNnV5U1NINnRDdnhka3UzYVMzSTR2di8rd2ViQkxOL3lBL29uNkJtZ2NkTUZIRmZxR1RLSFNiR0V2UWM1NEFYOUNOOXhvWjJ1bHpQTmlkQUg4Z1ZIQlpURnVMT0xRaFJDR2dXRjB3V0V3R2xPR2h0c3JVaC9SZHViMENJOHJWVnFnRU55djlSbE0weEZkQ0sxaHFDT0NhbUsxbSswMmpZOTZ0Y3ZUeE1ZbVhtZnpmbVgzRVBLd0lQckladk1LcXRWcU5hRHVvQzR1aXVXSFhEV2Q2bUN2TGtCMDBnOTNyZWRzcG5SWnl6U0pSQmhXVWFHUWJSSEpndWNGTjRrL0RFc2FqSVlXaHllTytZVlk1UG4wSkxtNmtiak1OaHZGM0hXZVRJT05TQ2VWcnVhK1BKVEx4ZUpGOFFJS0JvWURiTFd1eE5vWEFtWVBBZ08rbDQ1TkFZUVdEaDhHWDRUaGY4bmw3cXZWNjNRcTM4R2doaG5qNjFmRWNJMXJaeEFFcUxKZWVJN0VnQVNpQ0lWc0ZJS0ZNeStNU3dJQkZxQWNocFNHb3NHMElYRk11bkJ3ZmNUZUxaVVNFUCtKbmJNYVRIZDN4WWRxT284RElDaVBOemRQblU0bm4wK2wwOWZWYXZVK0Iyc1Q0SE5IMmdFSFVMZlF1TU9YSDRZUG8wL2xZZnhQTjJBOGVnYlNBczFhdVlzV1VJQU1vZnR1TFMxR1kwSVRJWHc0MDBLMEYvWTgwaFVHbzBHenF5ME9vcUVuV1F2SHRNSXhDendJU0NTN3M1TVF0OUc3RmVkdVJONnJlc1JNZ1hwNmttaFNxZlExRkx6NDEya0JnQWhnOW56V0VGNmtLNjdMRFhEa3lRRm03UjZzVTQwa29MUkJKQXJOUXZkYU9pOVlmQWE4K3d3ZkdtWldrY2toY1lRRURtMFhvUTkwVEN5NitGdzZQZDg0MkY3K3RMMS9jbmlMczAyNW11b0ltYnlZNGVFRGYrdFNGRC81OVAwREpISnA1K1FnVHBkV2JLL1ZseUtvaURrZ1FVRmhvYkF0NHVFUjJYRDV3REF6U3ArRjQ0MGxqdkZ4bnFTS1I5andVRWdXQUVpN2RMbTdMWGFKZnpnNGdsZnhDa3p3NVo3c3IxOTlVZVpQOG1QU1RpZVBjWU90ZnZNWmtpV3h0cm4rY1gzNWVQLzg5bC92QU1UYzdLekNRQ0JZbHlWVjRiS0lubE9IaHJ4aGFCcnlFQS9oY000cVUwd2NIQWZuSVlHUVl3UVJjTTFTN2VSNCs4Ty8xNWRYMTg3cFJCOGRmTUZ3dU1Nd2hZekVSRzNRckVFVFJwaytCVkhTa0tzZHZLb1dHcTVEMnBWVkVucEFaMkJKZDB3ekVpWXNsRU1zRm9OdUZzUERadi8wTUg1bzA1QTRCajF4c0luRmcwZVlLWVJjTXgrTC9mUGR1L1pTcG9hYnJuRUpkNFlOVlFtYkRteThTblFZZFNPWlBONkZadXZzN0V6OHBTcHFPWjRYRnlPUmFEU0dHRUFQc3dLRGtZUmxEOTFhU0JKbWFlWmlFVEFzckpQT0Fhc1JIVkxaWWRadGFsNngydzdtRjBQRWNvMzBEV1FKaGtrMEdva3NMaTR1dGJQWnBVeTJVRCtEeGpLeHRycU02OU5QS3h1NFYvTVVhQlN5UzlDV2FBUUxrQTF6SWgxVVRZY3RjemhJU0grSXNOQ3IxRUc1SUJrS21tNkx5OElOeEVIRDNYUzRzdFFXaUNFeUkyVXlPeU9NZzFMQm5nUnFBU3NHVlk1ZUFKd2xVWEwwTUh3YVB4UWhvSkpnTlFZWENaa1U0M3F4THZ6QkhXTDFXa0hmblR0T2RVZ2FmVm9ick9zd0U2M2d3UjBqaU1oWlJzdEV5eVVzN1NNemhXcWU2S2lhby9IalF4R1FNc0JuNDJISnJNRTBZVkpUKzhOdUx2b3NXWHdiREpNY0trbjFNUi9pWWJwU0NZUXBSTGxHL2VnMERBTmtSbmxJMEtFUHd1SURWMDNMLzZhbjdVbkRLUWd0Q1lhQ2ljTFphUFVNd3hJSG4xbHNlUUFRY295T2tBbWJDRFdGVGl6cWx4bHkyUDVNT0d3aENFMkwxdEw0Z29lRUFLR25qMzRXRmJaQmJJdjBCTU5FaCtBeGFQb096c05NTUVvaWs1WklpSW9Fdy9YU3ZVS3F0UTZKYnpaUE5pYjFvRE1DWDQ0Um00VExIN3JuTkxvSTlnaUQ0WEMyWWNvdS9mMWFJY3d6eWpWTUpvTEtoQnBjdDVwUS81dlErY2dvYUQyWWpKQWMxUHpCVVppRzA4WGlWUmpERGhpU2hyUHZFRjM2cUk0UFEyUmNFaEV6aldJeVpqUGhjS3lIVnhrR0hNT2s3UXdMaEdrck9Bb0hpMENYQ3d1c1JqUVljTlBnTTYyZVhJUkFOSklSZkpCcXh5VVVOZHVvaDRFakhsbzVZMkxZNXFHSFA0YmZialBRZ2hoUkZNVGtZWktDdFZpbSt6YUhMMmlBM1dGWVBEeHdjTGNJSGd3STRwQTlDSGVOTWM2azV2SnFUWElSVFBLUUJBcUt3d2pYZzViRUtDZWhRNU96Q0FaWStWOXlZaTlUTExjRTNlcXdCS0puWEowaWtnaVRDZXFFdE9MQTQxM2pUZ2JqSTNZK01CS2pvMDRTQTM0a0hDeTZYcW5IWVRod21OWmpjTkRNdGk3SFdFaE11SW9KMklEaGRJU2J4cGtKWEFBY0dLYVlOVFFGOS9UaHdjRmk4ZHIxSmc0Y0hwTnRuOEhoTW95RGlNblcvaEdyeGlXY2NkZm9oUkVzQkV3S2lvS3l4dHRSQzRVak00ZGNIWlpkcjErek42eVdMdjQ0WkdmS3VqSExNU1pXSlpSK3EzQjBJLzdWYi8yWkFIQXRLQXEyTmQ0bzR6b2kwNE9FV3BjTnY2WUxIcVZ1aVhoTXRsYUVxTmRuMU1uRUlaTWVhcXBmSVhCRE1Jb3dUU1kvY3FOUmVKRVk3djMrR2F3Q3ppV3Rxem0xZ0RBaUJnbU9TWEhCWWJySExwRk5HVHRvQ0RZSXl4aWFCQXNLRzhUM0RQKzF5eG9keDlHSDdBUVpHSEFoY1llSlZvcjg0MXYrTUYvdzl1MlVXd2c4S0cxcjJLcHc1Y1NQZ3VCSzFxQUhEWmFvbkFtbjR0QUpqQklmbys2WC9lMm8vRnMxZkFzQWgyQ3ZPM3dYSDRFZnB3aS9hY2FkSG9hSW4wNUdlNjAzZmh6RTh3KzZPa3gyN2pUWXc2VHhaMkVFUExwVEF0SkhQNkVIRlJxTWMzQ09vYm8rNFM2THVBY0p4eVE2L0pOZytEYnNkcUwyZVFqRkhvL3ZRRjhidTlNVmpyUzBNNVBQSUwvOThQS1lYRHlCdUxUU04rakx4VDN3TGlEb3VSUUFieExzY1BkUEpPRU53OTIxK3pKeDYwVllxbXYxdWNwK2NyY2dEQXlhQUg4YWpOY1RKTmdWaXplY3J1WDVETTUvS09Ec3RkWHBvQi9hVy9UV3BRYTl5eCtJQTQyTDFqZHdjQzg2L2lvQzNvNEorRlVQY1B6cjlkRnpESDhQREdlejdnL0ZsMGp3KzhvWHhIZXVPWDVtaUF4L3EwQitESWxoZlB3SzQvZUcwYzA0dmJNSkJIMmZTT3Z4MTRQaDRadlhNdVY3eXZ1ZitPMFhMZmZQOWlmSitBNWJmK0xYaGZHTlIwVitBSXovaXhydW9mN3FuKzEvQ0U1T3A3UDhLM1FBQUFBQVNVVk9SSzVDWUlJPSIgZmlsbD0ibm9uZSIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9IjAuNSIvPjwvZz48L2c+PC9zdmc+PCEtLXJvdGF0aW9uQ2VudGVyOjcwLjA4ODAwMDAwMDAwMDExOjcwLjA4OC0tPg==";
  const goldenRatio = (1 + Math.sqrt(5)) / 2;
  const sqrt3 = Math.sqrt(3);
  const gammaConstant = 0.57721566490153286060651209008240243104215933593992;

  const runtime = vm.runtime;

  function cast_to_array(array) {
    let object = null;
    try {
      object = JSON.parse(array);
      if (!(object.constructor === [].constructor)) {
        object = [];
      }
    } catch {
      object = [];
    }

    return object;
  }
  function cast_to_object(str_object) {
    let object = null;
    try {
      object = JSON.parse(str_object);
      if (!(object.constructor === {}.constructor)) {
        object = {};
      }
    } catch {
      object = {};
    }

    return object;
  }
  function cast_to_vector(array,length=null) {
    array = cast_to_array(array);
    let vector = [];
    for (let i = 0; i < array.length; i++) {
      vector.push(Scratch.Cast.toNumber(stringify(array[i])));
    }
    if (!(length === null)) {
      vector = vector.slice(0,length);
      for (let i = vector.length; i < length; i++) {
        vector.push(0);
      }
    }
    return vector;
  }
  function mod(a,b) {
    return ((a % b) + b) % b;
  }
  function json_stringify_censor(key, value) {
    if (value === Infinity) {
      return 'Infinity';
    } else if (value === -Infinity) {
      return '-Infinity';
    } else if (Number.isNaN(value)) {
      return 0;
    } else {
      return value;
    }
  }
  function stringify(json_object) {
    if (json_object === undefined) {
      return 'undefined';
    } else if (json_object === null) {
      return 'null';
    } else if (json_object.constructor === [].constructor || json_object.constructor === {}.constructor) {
      return JSON.stringify(json_object,json_stringify_censor);
    } else {
      return json_object.toString();
    }
  }
  function convert_angle_units(angle,from_unit,to_unit,relative=false) {
    let degrees_units = ['Scratch degrees','trig degrees'];
    let radians_units = ['Scratch radians','trig radians'];
    let full_circle_units = ['Scratch full circle','trig full circle'];
    let scratch_units = ['Scratch degrees','Scratch radians','Scratch full circle'];

    // convert angle to degrees
    let degrees = null;
    if (degrees_units.includes(from_unit)) {
      degrees = angle;
    } else if (radians_units.includes(from_unit)) {
      degrees = angle * (180 / Math.PI);
    } else if (full_circle_units.includes(from_unit)) {
      degrees = angle * 360;
    } else {
      return 0;
    }

    // convert degrees into trig degrees
    if (scratch_units.includes(from_unit)) {
      if (relative) {
        degrees = -degrees;
      } else {
        degrees = 90 - degrees;
      }
    }

    // convert trig degrees to scratch/trig degrees depending on to_unit
    if (scratch_units.includes(to_unit)) {
      if (relative) {
        degrees = -degrees;
      } else {
        degrees = 90 - degrees;
      }
    }

    // mod degrees
    if (scratch_units.includes(to_unit)) {
      degrees = 180 - mod((180 - degrees),360);
    } else {
      degrees = mod(degrees,360);
    }

    // convert degrees to degrees/radians/full circle depending on to_unit
    let newAngle = null;
    if (degrees_units.includes(to_unit)) {
      newAngle = degrees;
    } else if (radians_units.includes(to_unit)) {
      newAngle = degrees * (Math.PI / 180);
    } else if (full_circle_units.includes(to_unit)) {
      newAngle = degrees / 360;
    } else {
      return 0;
    }

    return newAngle;
  }
  function stage_width() {
    return Scratch.renderer.canvas.width;
  }
  function stage_height() {
    return Scratch.renderer.canvas.height;
  }
  function convert_coordinate_units(xy,from_unit,to_unit) {
    let width = stage_width();
    let height = stage_height();
    if (from_unit == 'Scratch coords' && to_unit == 'JS coords') {
      return [xy[0] + width/2, height - (xy[1] + height/2)];
    } else if (from_unit == 'JS coords' && to_unit == 'Scratch coords') {
      return [xy[0] - width/2, -((xy[1] - height) + height/2)];
    } else if (from_unit == to_unit) {
      return xy;
    } else {
      return [0,0];
    }
  }
  function var_id_from_name(variable_name,util) { // copied from SharkPool
    //support for all variable types (Cloud, Sprite-Only, Global)
    variable_name = Scratch.Cast.toString(variable_name);
    const cloudID = runtime.getTargetForStage().lookupVariableByNameAndType(Scratch.Cast.toString(" " + variable_name), "");
    if (cloudID) return cloudID.id;
    let varFind = "";
    for (const name of Object.getOwnPropertyNames(util.target.variables)) {
      varFind = util.target.variables[name].name;
      if (varFind === variable_name) return util.target.variables[name].id;
    }
    const ID = runtime.getTargetForStage().lookupVariableByNameAndType(variable_name, "");
    if (!ID) return "";
    return ID.id;
  }
  function var_name_exists(variable_name,util) {
    return Scratch.Cast.toBoolean(var_id_from_name(variable_name,util));
  }
  function get_var(variable_name,util) {
    if (!var_name_exists(variable_name,util)) { return 'undefined'; }
    let variable = util.target.lookupOrCreateVariable(variable_name,variable_name);
   	return variable.value;
  }
  function set_var(variable_name,value,util) {
    if (!var_name_exists(variable_name,util)) { return; }
    let variable = util.target.lookupOrCreateVariable(variable_name,variable_name);
   	variable.value = value;
    if (variable.isCloud) { // added from TurboWarp's Scratch 3 code
      util.ioQuery('cloud', 'requestUpdateVariable', [variable.name, value]);
    }
  }
  // get list for variables menus; from SharkPool's extension (see top for credits)
  function get_variables_for_menu() {
    const globalVars = Object.values(vm.runtime.getTargetForStage().variables).filter((x) => x.type == "");
    const localVars = Object.values(vm.editingTarget.variables).filter((x) => x.type == "");
    const uniqueVars = [...new Set([...globalVars, ...localVars])];
    if (uniqueVars.length === 0) return ["(choose a variable)"];
    return uniqueVars.map((i) => (Scratch.Cast.toString(i.name)));
  }
  function bulk_math(array,operation) {
    if (operation == 'min') {
      return Math.min(...array);
    } else if (operation == 'max') {
      return Math.max(...array);
    } else if (operation == 'sum') {
      let sum = 0;
      for (let i = 0; i < array.length; i++) {
        sum += array[i];
      }
      return sum;
    } else if (operation == 'product') {
      let product = 1;
      for (let i = 0; i < array.length; i++) {
        product *= array[i];
      }
      return product;
    } else if (operation == 'average') {
      let sum = 0;
      for (let i = 0; i < array.length; i++) {
        sum += array[i];
      }
      return sum / array.length;
    } else {
      return 0;
    }
  }
  function get_illion(n) {
    n = Math.round(n); // ensure integer

    // skip all logic and say "thousand" if n is 0
    if (n <= 0) {
      return 'thousand';
    }

    // convert n into a base-1000 number with its digits in "sections" from most significant to least significant (in other words splitting 1234567 into 1,234,567 where you would write commas)
    let sections = [];
    let place_value = 1;
    while (n >= place_value) {
      sections.unshift(mod(Math.floor(n / place_value), 1000));
      place_value *= 1000;
    }

    // call "get_illion_short" for each base-1000 "digit" and combine them into one string
    let str = '';
    for (let i = 0; i < sections.length; i++) {
      str += get_illion_short(sections[i]);
    }

    // add the final "-on" to finish "illion"
    str += 'on';

    return str;
  }
  function get_illion_short(n) {
    // See this for more info about the algorithm: https://en.wikipedia.org/wiki/Names_of_large_numbers#Extensions_of_the_standard_dictionary_numbers

    // return one of the basic 10 illions if n < 10
    if (n < 10) {
      let small_illions = ['nilli','milli','billi','trilli','quadrilli','quintilli','sextilli','septilli','octilli','nonilli'];
      return small_illions[n];
    }

    // get each component of the illion
    let possible_ones = ['','un','duo','tre','quattuor','quin','se','septe','octo','nove'];
    let possible_tens = ['','deci','viginti','triginta','quadraginta','quinquaginta','sexaginta','septuaginta','octoginta','nonaginta'];
    let possible_hundreds = ['','centi','ducenti','trecenti','quadringenti','quingenti','sescenti','septingenti','octingenti','nongenti'];
    let ones_num = mod(n, 10);
    let ones = possible_ones[ones_num];
    let tens_num = mod(Math.floor(n / 10), 10);
    let tens = possible_tens[tens_num];
    let hundreds_num = Math.floor(n / 100);
    let hundreds = possible_hundreds[hundreds_num];

    // apply marks to the ones component
    let markable = ['tre','se','septe','nove'];
    if (markable.includes(ones)) {
      // find marks that need to be applied
      let marks = {
        '':[],'un':[],'duo':[],'tre':[],'quattuor':[],'quin':[],'se':[],'septe':[],'octo':[],'nove':[],
        'deci':['N'],'viginti':['M','S'],'triginta':['N','S'],'quadraginta':['N','S'],'quinquaginta':['N','S'],'sexaginta':['N'],'septuaginta':['N'],'octoginta':['M','X'],'nonaginta':[],
        'centi':['NX'],'ducenti':['N'],'trecenti':['N','S'],'quadringenti':['N','S'],'quingenti':['N','S'],'sescenti':['N'],'septingenti':['N'],'octingenti':['M','X'],'nongenti':[]
      };
      let applied_marks = marks[tens];
      if (tens == '') {
        applied_marks = marks[hundreds];
      }

      // apply them
      if (applied_marks.includes('S')) {
        if (ones == 'tre') { ones = 'tres'; }
        if (ones == 'se') { ones = 'ses'; }
      }
      if (applied_marks.includes('X')) {
        if (ones == 'tre') { ones = 'tres'; }
        if (ones == 'se') { ones = 'sex'; }
      }
      if (applied_marks.includes('M')) {
        if (ones == 'septe') { ones = 'septem'; }
        if (ones == 'nove') { ones = 'novem'; }
      }
      if (applied_marks.includes('N')) {
        if (ones == 'septe') { ones = 'septen'; }
        if (ones == 'nove') { ones = 'noven'; }
      }
    }

    // add "illi" at the end of names such as "quadraginta" that don't have it already
    // the only ones that would already have "illi" at the end are covered by "small_illions" at the start of the function
    let str = ones + tens + hundreds;
    str = str.slice(0, -1) + 'illi';

    return str;
  }
  function get_abbreviated_illion(n) {
    let abbreviated_illions = ['k','m','b','t','qa','qi','sx','sp','o','n','d','ud','dd','td','qad','qid','sxd','spd','od','nd','v','uv','dv','tv','qav','qiv','sxv','spv','ov','nv','tg','utg','dtg','ttg','qatg','qitg','sxtg','sptg','otg','ntg','qag','uqag','dqag','tqag','qaqag','qiqag','sxqag','spqag','oqag','nqag','qig'];
    if (n >= abbreviated_illions.length) {
      return '10^' + (3 * n + 3);
    }
    return abbreviated_illions[n];
  }

  // ######  ##  ##  ######  ######  ##    ##  ######  ######  ######  ##    ##      ######  ##      ######  ######  ######
  // ##      ##  ##    ##    ##      ####  ##  ##        ##    ##  ##  ####  ##      ##      ##      ##  ##  ##      ##
  // ####      ##      ##    ####    ##  ####  ######    ##    ##  ##  ##  ####      ##      ##      ######  ######  ######
  // ##      ##  ##    ##    ##      ##    ##      ##    ##    ##  ##  ##    ##      ##      ##      ##  ##      ##      ##
  // ######  ##  ##    ##    ######  ##    ##  ######  ######  ######  ##    ##      ######  ######  ##  ##  ######  ######

  class SoupUtils {
    getInfo() {
      return {
        id: 'souputils',
        name: 'Soup Utils',
        color1: '#f55442',
        color2: '#b83527',
        color3: '#edbbad',
        menuIconURI: util_menu_icon,
        blockIconURI: util_icon,
        blocks: [
          // BLOCKS -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

          {
            opcode: 'lerp',
            blockType: Scratch.BlockType.REPORTER,
            text: 'lerp from [A] to [B] by [N]',
            arguments: {
              A: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: '5'
              },
              B: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: '10'
              },
              N: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: '0.4'
              }
            }
          },
          {
            opcode: 'inverselerp',
            blockType: Scratch.BlockType.REPORTER,
            text: 'inverse lerp of [N] range [A] to [B]',
            arguments: {
              A: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: '5'
              },
              B: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: '10'
              },
              N: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: '7'
              }
            }
          },
          {
            opcode: 'doublelerp',
            blockType: Scratch.BlockType.REPORTER,
            text: 'lerp from [A] to [B] by [N]\'s position between [C] and [D]',
            arguments: {
              A: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: '5'
              },
              B: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: '10'
              },
              C: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: '20'
              },
              D: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: '30'
              },
              N: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: '25'
              }
            }
          },

          '---',

          {
            opcode: 'customround',
            blockType: Scratch.BlockType.REPORTER,
            text: '[TYPE] [A] to the nearest [B]',
            arguments: {
              A: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: '3.46'
              },
              B: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: '0.1'
              },
              TYPE: {
                type: Scratch.ArgumentType.STRING,
                menu: 'ROUND_TYPES_MENU'
              }
            }
          },
          {
            opcode: 'customroundreciprocal',
            blockType: Scratch.BlockType.REPORTER,
            text: '[TYPE] [A] to the nearest 1/[B]',
            arguments: {
              A: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: '3.46'
              },
              B: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: '10'
              },
              TYPE: {
                type: Scratch.ArgumentType.STRING,
                menu: 'ROUND_TYPES_MENU'
              }
            }
          },

          '---',

          {
            opcode: 'extramath',
            blockType: Scratch.BlockType.REPORTER,
            text: '[A] [MATH] [B]',
            arguments: {
              A: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: '12'
              },
              B: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: '5'
              },
              MATH: {
                type: Scratch.ArgumentType.STRING,
                menu: 'EXTRA_MATH_MENU'
              }
            }
          },
          {
            opcode: 'extramathoneinput',
            blockType: Scratch.BlockType.REPORTER,
            text: '[MATH] [A]',
            arguments: {
              A: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: '6'
              },
              MATH: {
                type: Scratch.ArgumentType.STRING,
                menu: 'EXTRA_MATH_ONE_INPUT_MENU'
              }
            }
          },
          {
            opcode: 'mathconstants',
            blockType: Scratch.BlockType.REPORTER,
            text: '[CONSTANT]',
            disableMonitor: true,
            arguments: {
              CONSTANT: {
                type: Scratch.ArgumentType.STRING,
                menu: 'MATH_CONSTANTS'
              }
            }
          },

          '---',

          {
            opcode: 'extralogic',
            blockType: Scratch.BlockType.BOOLEAN,
            text: '[A] [LOGIC] [B]',
            arguments: {
              A: {
                type: Scratch.ArgumentType.BOOLEAN
              },
              B: {
                type: Scratch.ArgumentType.BOOLEAN
              },
              LOGIC: {
                type: Scratch.ArgumentType.STRING,
                menu: 'EXTRA_LOGIC_MENU'
              }
            }
          },
          {
            opcode: 'extracomparators',
            blockType: Scratch.BlockType.BOOLEAN,
            text: '[A] [OPERATOR] [B]',
            arguments: {
              A: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: '4'
              },
              B: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: '4.6'
              },
              OPERATOR: {
                type: Scratch.ArgumentType.STRING,
                menu: 'EXTRA_COMPARATORS_MENU'
              }
            }
          },

          '---',

          {
            opcode: 'resetsprite',
            blockType: Scratch.BlockType.COMMAND,
            text: 'reset all sprite settings, go to [VECTOR] [COORDINATEUNIT], and [SHOWORHIDE]',
            arguments: {
              VECTOR: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: '[0,0]'
              },
              COORDINATEUNIT: {
                type: Scratch.ArgumentType.STRING,
                menu: 'COORDINATE_UNITS_MENU'
              },
              SHOWORHIDE: {
                type: Scratch.ArgumentType.STRING,
                menu: 'SHOW_OR_HIDE_MENU'
              }
            }
          },

          '---',

          {
            opcode: 'getvar',
            blockType: Scratch.BlockType.REPORTER,
            text: 'var [VARIABLE]',
            arguments: {
              VARIABLE: {
                type: Scratch.ArgumentType.STRING,
                menu: 'VARIABLES_MENU'
              }
            }
          },
          {
            opcode: 'setvar',
            blockType: Scratch.BlockType.COMMAND,
            text: 'set var [VARIABLE] to [VALUE]',
            arguments: {
              VARIABLE: {
                type: Scratch.ArgumentType.STRING,
                menu: 'VARIABLES_MENU'
              },
              VALUE: {
              	type: Scratch.ArgumentType.STRING,
                defaultValue: '0'
              }
            }
          },
          {
            opcode: 'modifyvar',
            blockType: Scratch.BlockType.COMMAND,
            text: '[VARIABLE] [OPERATOR] [VALUE]',
            arguments: {
              VARIABLE: {
                type: Scratch.ArgumentType.STRING,
                menu: 'VARIABLES_MENU'
              },
              VALUE: {
              	type: Scratch.ArgumentType.NUMBER,
                defaultValue: '1'
              },
              OPERATOR: {
              	type: Scratch.ArgumentType.STRING,
                menu: 'ASSIGNMENT_OPERATORS_MENU'
              }
            }
          },

          '---',

          {
            opcode: 'jsalert',
            blockType: Scratch.BlockType.COMMAND,
            text: 'alert [MESSAGE]',
            arguments: {
              MESSAGE: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: 'Hello World!'
              }
            }
          },
          {
            opcode: 'jsconfirm',
            blockType: Scratch.BlockType.BOOLEAN,
            text: 'confirm [MESSAGE]',
            arguments: {
              MESSAGE: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: 'Are you sure?'
              }
            }
          },
          {
            opcode: 'jsprompt',
            blockType: Scratch.BlockType.REPORTER,
            text: 'prompt [MESSAGE] default [PLACEHOLDER]',
            arguments: {
              MESSAGE: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: 'What is your name?'
              },
              PLACEHOLDER: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: ''
              }
            }
          },
          {
            opcode: 'jspromptwithdefault',
            blockType: Scratch.BlockType.REPORTER,
            text: 'prompt [MESSAGE] default [PLACEHOLDER], or [DEFAULT] if they cancel',
            arguments: {
              MESSAGE: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: 'What is your name?'
              },
              PLACEHOLDER: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: ''
              },
              DEFAULT: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: 'null'
              }
            }
          },

          '---',

          {
            opcode: 'booleanconstants',
            blockType: Scratch.BlockType.BOOLEAN,
            text: '[BOOLEAN]',
            arguments: {
              BOOLEAN: {
                type: Scratch.ArgumentType.STRING,
                menu: 'BOOLEANS_MENU'
              }
            }
          },
          {
            opcode: 'tonumber',
            blockType: Scratch.BlockType.REPORTER,
            text: 'number [NUMBER]',
            arguments: {
              NUMBER: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: ''
              }
            }
          },
          {
            opcode: 'valueif',
            blockType: Scratch.BlockType.REPORTER,
            text: 'if [BOOLEAN] then [VALUEIFTRUE] else [VALUEIFFALSE]',
            arguments: {
              BOOLEAN: {
                type: Scratch.ArgumentType.BOOLEAN
              },
              VALUEIFTRUE: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: 'true'
              },
              VALUEIFFALSE: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: 'false'
              }
            }
          },
          
          '---',
          
          {
            opcode: 'randomchancepercent',
            blockType: Scratch.BlockType.BOOLEAN,
            text: '[CHANCE]% chance',
            arguments: {
              CHANCE: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: '50'
              }
            }
          },
          {
            opcode: 'randomchanceratio',
            blockType: Scratch.BlockType.BOOLEAN,
            text: '[NUMERATOR] out of [DENOMINATOR] chance',
            arguments: {
              NUMERATOR: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: '1'
              },
              DENOMINATOR: {
              	type: Scratch.ArgumentType.NUMBER,
                defaultValue: '3'
              }
            }
          },
          {
            opcode: 'randomvalue',
            blockType: Scratch.BlockType.REPORTER,
            text: 'random',
            arguments: {}
          },
          
          '---',
          
          {
            opcode: 'userfriendlynumber',
            blockType: Scratch.BlockType.REPORTER,
            text: 'user-friendly number [NUMBER] with format [FORMAT]',
            arguments: {
              NUMBER: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: '1000000'
              },
              FORMAT: {
              	type: Scratch.ArgumentType.STRING,
                menu: 'USER_FRIENDLY_NUMBERS_MENU'
              }
            }
          },

          '---',

          {
            opcode: 'bulkmathtwo',
            blockType: Scratch.BlockType.REPORTER,
            text: '[OPERATION] [NUMONE] [NUMTWO]',
            arguments: {
              OPERATION: {
                type: Scratch.ArgumentType.STRING,
                menu: 'BULK_MATH_OPERATIONS_MENU'
              },
              NUMONE: { type: Scratch.ArgumentType.NUMBER, defaultValue: '1' },
              NUMTWO: { type: Scratch.ArgumentType.NUMBER, defaultValue: '2' }
            }
          },
          {
            opcode: 'bulkmaththree',
            blockType: Scratch.BlockType.REPORTER,
            text: '[OPERATION] [NUMONE] [NUMTWO] [NUMTHREE]',
            arguments: {
              OPERATION: {
                type: Scratch.ArgumentType.STRING,
                menu: 'BULK_MATH_OPERATIONS_MENU'
              },
              NUMONE: { type: Scratch.ArgumentType.NUMBER, defaultValue: '1' },
              NUMTWO: { type: Scratch.ArgumentType.NUMBER, defaultValue: '2' },
              NUMTHREE: { type: Scratch.ArgumentType.NUMBER, defaultValue: '3' }
            }
          },
          {
            opcode: 'bulkmathfour',
            blockType: Scratch.BlockType.REPORTER,
            text: '[OPERATION] [NUMONE] [NUMTWO] [NUMTHREE] [NUMFOUR]',
            arguments: {
              OPERATION: {
                type: Scratch.ArgumentType.STRING,
                menu: 'BULK_MATH_OPERATIONS_MENU'
              },
              NUMONE: { type: Scratch.ArgumentType.NUMBER, defaultValue: '1' },
              NUMTWO: { type: Scratch.ArgumentType.NUMBER, defaultValue: '2' },
              NUMTHREE: { type: Scratch.ArgumentType.NUMBER, defaultValue: '3' },
              NUMFOUR: { type: Scratch.ArgumentType.NUMBER, defaultValue: '4' }
            }
          },
          {
            opcode: 'bulkmathfive',
            blockType: Scratch.BlockType.REPORTER,
            text: '[OPERATION] [NUMONE] [NUMTWO] [NUMTHREE] [NUMFOUR] [NUMFIVE]',
            arguments: {
              OPERATION: {
                type: Scratch.ArgumentType.STRING,
                menu: 'BULK_MATH_OPERATIONS_MENU'
              },
              NUMONE: { type: Scratch.ArgumentType.NUMBER, defaultValue: '1' },
              NUMTWO: { type: Scratch.ArgumentType.NUMBER, defaultValue: '2' },
              NUMTHREE: { type: Scratch.ArgumentType.NUMBER, defaultValue: '3' },
              NUMFOUR: { type: Scratch.ArgumentType.NUMBER, defaultValue: '4' },
              NUMFIVE: { type: Scratch.ArgumentType.NUMBER, defaultValue: '5' }
            }
          },
          {
            opcode: 'bulkmathsix',
            blockType: Scratch.BlockType.REPORTER,
            text: '[OPERATION] [NUMONE] [NUMTWO] [NUMTHREE] [NUMFOUR] [NUMFIVE] [NUMSIX]',
            arguments: {
              OPERATION: {
                type: Scratch.ArgumentType.STRING,
                menu: 'BULK_MATH_OPERATIONS_MENU'
              },
              NUMONE: { type: Scratch.ArgumentType.NUMBER, defaultValue: '1' },
              NUMTWO: { type: Scratch.ArgumentType.NUMBER, defaultValue: '2' },
              NUMTHREE: { type: Scratch.ArgumentType.NUMBER, defaultValue: '3' },
              NUMFOUR: { type: Scratch.ArgumentType.NUMBER, defaultValue: '4' },
              NUMFIVE: { type: Scratch.ArgumentType.NUMBER, defaultValue: '5' },
              NUMSIX: { type: Scratch.ArgumentType.NUMBER, defaultValue: '6' }
            }
          },
          {
            opcode: 'bulkmathseven',
            blockType: Scratch.BlockType.REPORTER,
            text: '[OPERATION] [NUMONE] [NUMTWO] [NUMTHREE] [NUMFOUR] [NUMFIVE] [NUMSIX] [NUMSEVEN]',
            arguments: {
              OPERATION: {
                type: Scratch.ArgumentType.STRING,
                menu: 'BULK_MATH_OPERATIONS_MENU'
              },
              NUMONE: { type: Scratch.ArgumentType.NUMBER, defaultValue: '1' },
              NUMTWO: { type: Scratch.ArgumentType.NUMBER, defaultValue: '2' },
              NUMTHREE: { type: Scratch.ArgumentType.NUMBER, defaultValue: '3' },
              NUMFOUR: { type: Scratch.ArgumentType.NUMBER, defaultValue: '4' },
              NUMFIVE: { type: Scratch.ArgumentType.NUMBER, defaultValue: '5' },
              NUMSIX: { type: Scratch.ArgumentType.NUMBER, defaultValue: '6' },
              NUMSEVEN: { type: Scratch.ArgumentType.NUMBER, defaultValue: '7' }
            }
          },
          {
            opcode: 'bulkmatheight',
            blockType: Scratch.BlockType.REPORTER,
            text: '[OPERATION] [NUMONE] [NUMTWO] [NUMTHREE] [NUMFOUR] [NUMFIVE] [NUMSIX] [NUMSEVEN] [NUMEIGHT]',
            arguments: {
              OPERATION: {
                type: Scratch.ArgumentType.STRING,
                menu: 'BULK_MATH_OPERATIONS_MENU'
              },
              NUMONE: { type: Scratch.ArgumentType.NUMBER, defaultValue: '1' },
              NUMTWO: { type: Scratch.ArgumentType.NUMBER, defaultValue: '2' },
              NUMTHREE: { type: Scratch.ArgumentType.NUMBER, defaultValue: '3' },
              NUMFOUR: { type: Scratch.ArgumentType.NUMBER, defaultValue: '4' },
              NUMFIVE: { type: Scratch.ArgumentType.NUMBER, defaultValue: '5' },
              NUMSIX: { type: Scratch.ArgumentType.NUMBER, defaultValue: '6' },
              NUMSEVEN: { type: Scratch.ArgumentType.NUMBER, defaultValue: '7' },
              NUMEIGHT: { type: Scratch.ArgumentType.NUMBER, defaultValue: '8' }
            }
          }
        ],
        menus: {
          EXTRA_MATH_MENU: {
            acceptReporters: true,
            items: ['//','^','-base log of','-th root of','abs diff','+','-','*','/','%','bitwise AND','bitwise XOR','bitwise OR','L-shift','R-shift (signed)','R-shift (unsigned)']
          },
          EXTRA_MATH_ONE_INPUT_MENU: {
            acceptReporters: true,
            items: ['-','abs of','sign of','','','','10^','e^','log10 of','ln of','round','floor of','ceil of','negative abs of','bitwise NOT of','sin (trig radians) of','cos (trig radians) of','tan (trig radians) of','asin (trig radians) of','acos (trig radians) of','atan (trig radians) of','sin (Scratch degrees) of','cos (Scratch degrees) of','tan (Scratch degrees) of','asin (Scratch degrees) of','acos (Scratch degrees) of','atan (Scratch degrees) of']
          },
          MATH_CONSTANTS: {
            acceptReporters: true,
            items: ['','','','2','3','','ln(10)','ln(2)','log10(e)','log2(e)','','','-']
          },
          ROUND_TYPES_MENU: {
            acceptReporters: true,
            items: ['round','floor','ceiling']
          },
          EXTRA_LOGIC_MENU: {
            acceptReporters: true,
            items: ['and','or','nand','nor','xor ()','xnor (=)','but not']
          },
          EXTRA_COMPARATORS_MENU: {
            acceptReporters: true,
            items: ['=','','<','>','','','','','===','==']
          },
          SHOW_OR_HIDE_MENU: {
            acceptReporters: true,
            items: ['show','hide']
          },
          COORDINATE_UNITS_MENU: {
            acceptReporters: true,
            items: ['Scratch coords','JS coords']
          },
          VARIABLES_MENU: {
            acceptReporters: true,
            items: 'getvariables'
          },
          ASSIGNMENT_OPERATORS_MENU: {
            acceptReporters: true,
            items: ['+=','-=','*=','/=','//=','%=']
          },
          BOOLEANS_MENU: {
            acceptReporters: true,
            items: ['true','false']
          },
          BULK_MATH_OPERATIONS_MENU: {
            acceptReporters: true,
            items: ['min','max','sum','product','average']
          },
          USER_FRIENDLY_NUMBERS_MENU: {
          	acceptReporters: true,
            items: ['1,234,567.89 (truncated)','1,234,567.89012 (not truncated)','1.23 million','1.23m','1,234,567.890 (always 3 decimals)','1,234,567.890120 (always 6 decimals)','1.23410','1d 23h 45m 37s','01:23:45, 00:00:01','1:23:45, 0:01','01:23, 00:01', 'n\'th -illion number']
          }
        }
      };
    }

    // CODE -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

    getvariables() {
      return get_variables_for_menu();
    }

    // blocks
    lerp(args) {
      let a = Scratch.Cast.toNumber(args.A);
      let b = Scratch.Cast.toNumber(args.B);
      let n = Scratch.Cast.toNumber(args.N);
      return (n * (b - a)) + a;
    }
    inverselerp(args) {
      let a = Scratch.Cast.toNumber(args.A);
      let b = Scratch.Cast.toNumber(args.B);
      let n = Scratch.Cast.toNumber(args.N);
      return (n - a) / (b - a);
    }
    doublelerp(args) {
      let a = Scratch.Cast.toNumber(args.A);
      let b = Scratch.Cast.toNumber(args.B);
      let c = Scratch.Cast.toNumber(args.C);
      let d = Scratch.Cast.toNumber(args.D);
      let n = Scratch.Cast.toNumber(args.N);
      return (((n - c) / (d - c)) * (b - a)) + a;
    }
    customround(args) {
      let a = Scratch.Cast.toNumber(args.A);
      let b = Scratch.Cast.toNumber(args.B);
      if (args.TYPE == 'round') {
        return Math.round(a / b) * b;
      } else if (args.TYPE == 'floor') {
        return Math.floor(a / b) * b;
      } else if (args.TYPE == 'ceiling') {
        return Math.ceil(a / b) * b;
      } else {
        return 0;
      }
    }
    customroundreciprocal(args) {
      let a = Scratch.Cast.toNumber(args.A);
      let b = Scratch.Cast.toNumber(args.B);
      if (args.TYPE == 'round') {
        return Math.round(a * b) / b;
      } else if (args.TYPE == 'floor') {
        return Math.floor(a * b) / b;
      } else if (args.TYPE == 'ceiling') {
        return Math.ceil(a * b) / b;
      } else {
        return 0;
      }
    }
    extramath(args) {
      let a = Scratch.Cast.toNumber(args.A);
      let b = Scratch.Cast.toNumber(args.B);
      if (args.MATH == '//') {
        return Math.floor(a / b);
      } else if (args.MATH == '^') {
        return a ** b;
      } else if (args.MATH == '-base log of') {
        return Math.log(b) / Math.log(a);
      } else if (args.MATH == '-th root of') {
        return b ** (1/a);
      } else if (args.MATH == 'abs diff') {
        return Math.abs(a - b);
      } else if (args.MATH == '+') {
        return a + b;
      } else if (args.MATH == '-') {
        return a - b;
      } else if (args.MATH == '*') {
        return a * b;
      } else if (args.MATH == '/') {
        return a / b;
      } else if (args.MATH == '%') {
        return mod(a,b);
      } else if (args.MATH == 'bitwise AND') {
        return a & b;
      } else if (args.MATH == 'bitwise XOR') {
        return a ^ b;
      } else if (args.MATH == 'bitwise OR') {
        return a | b;
      } else if (args.MATH == 'L-shift') {
        return a << b;
      } else if (args.MATH == 'R-shift (signed)') {
        return a >> b;
      } else if (args.MATH == 'R-shift (unsigned)') {
        return a >>> b;
      } else {
        return 0;
      }
    }
    extramathoneinput(args) {
      let a = Scratch.Cast.toNumber(args.A);
      if (args.MATH == '-') {
        return 0 - a;
      } else if (args.MATH == 'abs of') {
        return Math.abs(a);
      } else if (args.MATH == 'sign of') {
        if (a > 0) {
          return 1;
        } else if (a < 0) {
          return -1;
        } else {
          return 0;
        }
      } else if (args.MATH == '10^') {
        return 10 ** a;
      } else if (args.MATH == 'e^') {
        return Math.exp(a);
      } else if (args.MATH == '') {
        return Math.sqrt(a);
      } else if (args.MATH == '') {
        return Math.cbrt(a);
      } else if (args.MATH == '') {
        return a ** 0.25;
      } else if (args.MATH == 'log10 of') {
        return Math.log10(a);
      } else if (args.MATH == 'ln of') {
        return Math.log(a);
      } else if (args.MATH == 'sin (trig radians) of') {
        return Math.sin(a);
      } else if (args.MATH == 'cos (trig radians) of') {
        return Math.cos(a);
      } else if (args.MATH == 'tan (trig radians) of') {
        return Math.tan(a);
      } else if (args.MATH == 'asin (trig radians) of') {
        return Math.asin(a);
      } else if (args.MATH == 'acos (trig radians) of') {
        return Math.acos(a);
      } else if (args.MATH == 'atan (trig radians) of') {
        return Math.atan(a);
      } else if (args.MATH == 'sin (Scratch degrees) of') {
        return Math.sin((Math.PI / 180) * (90 - a));
      } else if (args.MATH == 'cos (Scratch degrees) of') {
        return Math.cos((Math.PI / 180) * (90 - a));
      } else if (args.MATH == 'tan (Scratch degrees) of') {
        return Math.tan((Math.PI / 180) * (90 - a));
      } else if (args.MATH == 'asin (Scratch degrees) of') {
        return 90 - (Math.asin(a) * (180 / Math.PI));
      } else if (args.MATH == 'acos (Scratch degrees) of') {
        return 90 - (Math.acos(a) * (180 / Math.PI));
      } else if (args.MATH == 'atan (Scratch degrees) of') {
        return 90 - (Math.atan(a) * (180 / Math.PI));
      } else if (args.MATH == 'round') {
        return Math.round(a);
      } else if (args.MATH == 'ceil of') {
        return Math.ceil(a);
      } else if (args.MATH == 'floor of') {
        return Math.floor(a);
      } else if (args.MATH == 'negative abs of') {
        return 0 - Math.abs(a);
      } else if (args.MATH == 'bitwise NOT of') {
        return ~a;
      } else {
        return 0;
      }
    }
    mathconstants(args) {
      if (args.CONSTANT == '') {
        return Math.PI;
      } else if (args.CONSTANT == '') {
        return 2 * Math.PI;
      } else if (args.CONSTANT == '') {
        return goldenRatio;
      } else if (args.CONSTANT == '2') {
        return Math.SQRT2;
      } else if (args.CONSTANT == '3') {
        return sqrt3;
      } else if (args.CONSTANT == '') {
        return gammaConstant;
      } else if (args.CONSTANT == '') {
        return 'Infinity';
      } else if (args.CONSTANT == '-') {
        return '-Infinity';
      } else if (args.CONSTANT == '') {
        return Math.SQRT1_2;
      } else if (args.CONSTANT == 'ln(10)') {
        return Math.LN10;
      } else if (args.CONSTANT == 'ln(2)') {
        return Math.LN2;
      } else if (args.CONSTANT == 'log10(e)') {
        return Math.LOG10E;
      } else if (args.CONSTANT == 'log2(e)') {
        return Math.LOG2E;
      } else {
        return 0;
      }
    }
    extralogic(args) {
      let a = Scratch.Cast.toBoolean(args.A);
      let b = Scratch.Cast.toBoolean(args.B);
      if (args.LOGIC == 'and') {
        return a && b;
      } else if (args.LOGIC == 'or') {
        return a || b;
      } else if (args.LOGIC == 'nand') {
        return !(a && b);
      } else if (args.LOGIC == 'nor') {
        return !(a || b);
      } else if (args.LOGIC == 'xor ()') {
        return a != b;
      } else if (args.LOGIC == 'xnor (=)') {
        return a == b;
      } else if (args.LOGIC == 'but not') {
        return a && (!b);
      } else {
        return false;
      }
    }
    extracomparators(args) {
      let comparison = Scratch.Cast.compare(args.A,args.B);
      let a = Scratch.Cast.toNumber(args.A);
      let b = Scratch.Cast.toNumber(args.B);
      if (args.OPERATOR == '=') {
        return comparison == 0;
      } else if (args.OPERATOR == '') {
        return comparison != 0;
      } else if (args.OPERATOR == '<') {
        return comparison < 0;
      } else if (args.OPERATOR == '>') {
        return comparison > 0;
      } else if (args.OPERATOR == '') {
        return comparison <= 0;
      } else if (args.OPERATOR == '') {
        return comparison >= 0;
      } else if (args.OPERATOR == '') {
        return Math.abs(a - b) < 1;
      } else if (args.OPERATOR == '') {
        return Math.abs(a - b) >= 1;
      } else if (args.OPERATOR == '===') {
        return args.A === args.B;
      } else if (args.OPERATOR == '==') {
        return args.A !== args.B;
      } else {
        return false;
      }
    }
    resetsprite(args,util) {
      util.target.setDirection(90);
      util.target.setRotationStyle('all around');
      util.target.clearEffects();
      util.target.setSize(100);

      let vector = cast_to_vector(args.VECTOR,2);
      vector = convert_coordinate_units(vector,args.COORDINATEUNIT,'Scratch coords');
      util.target.setXY(vector[0],vector[1]);

      if (args.SHOWORHIDE == 'show') {
        util.target.setVisible(true);
      } else {
        util.target.setVisible(false);
      }
    }
    getvar(args,util) {
      return get_var(args.VARIABLE,util);
    }
    setvar(args,util) {
      set_var(args.VARIABLE,args.VALUE,util);
    }
    modifyvar(args,util) {
      let a = Scratch.Cast.toNumber(get_var(args.VARIABLE,util));
      let b = Scratch.Cast.toNumber(args.VALUE);
      let newValue = 0;
      if (args.OPERATOR == '+=') {
        newValue = a + b;
      } else if (args.OPERATOR == '-=') {
        newValue = a - b;
      } else if (args.OPERATOR == '-=') {
        newValue = a - b;
      } else if (args.OPERATOR == '*=') {
        newValue = a * b;
      } else if (args.OPERATOR == '/=') {
        newValue = a / b;
      } else if (args.OPERATOR == '//=') {
        newValue = Math.floor(a / b);
      } else if (args.OPERATOR == '%=') {
        newValue = mod(a,b);
      }
      set_var(args.VARIABLE,newValue.toString(),util);
    }
    jsalert(args) {
      return new Promise(function(resolve, reject) {
        alert(args.MESSAGE);
        resolve();
      });
    }
    jsconfirm(args) {
      return new Promise(function(resolve, reject) {
        let result = confirm(args.MESSAGE);
        resolve(result);
      });
    }
    jsprompt(args) {
      return new Promise(function(resolve, reject) {
        let result = prompt(args.MESSAGE,args.PLACEHOLDER);
        if (result === null) {
          resolve('null');
        } else {
          resolve(result);
        }
      });
    }
    jspromptwithdefault(args) {
      return new Promise(function(resolve, reject) {
        let result = prompt(args.MESSAGE,args.PLACEHOLDER);
        if (result === null) {
          resolve(args.DEFAULT);
        } else {
          resolve(result);
        }
      });
    }
    booleanconstants(args) {
      let boolean = Scratch.Cast.toBoolean(args.BOOLEAN);
      return boolean;
    }
    tonumber(args) {
      let number = Scratch.Cast.toNumber(args.NUMBER);
      return number;
    }
    bulkmathtwo(args) { return bulk_math([Scratch.Cast.toNumber(args.NUMONE),Scratch.Cast.toNumber(args.NUMTWO)], args.OPERATION); }
    bulkmaththree(args) { return bulk_math([Scratch.Cast.toNumber(args.NUMONE),Scratch.Cast.toNumber(args.NUMTWO),Scratch.Cast.toNumber(args.NUMTHREE)], args.OPERATION); }
    bulkmathfour(args) { return bulk_math([Scratch.Cast.toNumber(args.NUMONE),Scratch.Cast.toNumber(args.NUMTWO),Scratch.Cast.toNumber(args.NUMTHREE),Scratch.Cast.toNumber(args.NUMFOUR)], args.OPERATION); }
    bulkmathfive(args) { return bulk_math([Scratch.Cast.toNumber(args.NUMONE),Scratch.Cast.toNumber(args.NUMTWO),Scratch.Cast.toNumber(args.NUMTHREE),Scratch.Cast.toNumber(args.NUMFOUR),Scratch.Cast.toNumber(args.NUMFIVE)], args.OPERATION); }
    bulkmathsix(args) { return bulk_math([Scratch.Cast.toNumber(args.NUMONE),Scratch.Cast.toNumber(args.NUMTWO),Scratch.Cast.toNumber(args.NUMTHREE),Scratch.Cast.toNumber(args.NUMFOUR),Scratch.Cast.toNumber(args.NUMFIVE),Scratch.Cast.toNumber(args.NUMSIX)], args.OPERATION); }
    bulkmathseven(args) { return bulk_math([Scratch.Cast.toNumber(args.NUMONE),Scratch.Cast.toNumber(args.NUMTWO),Scratch.Cast.toNumber(args.NUMTHREE),Scratch.Cast.toNumber(args.NUMFOUR),Scratch.Cast.toNumber(args.NUMFIVE),Scratch.Cast.toNumber(args.NUMSIX),Scratch.Cast.toNumber(args.NUMSEVEN)], args.OPERATION); }
    bulkmatheight(args) { return bulk_math([Scratch.Cast.toNumber(args.NUMONE),Scratch.Cast.toNumber(args.NUMTWO),Scratch.Cast.toNumber(args.NUMTHREE),Scratch.Cast.toNumber(args.NUMFOUR),Scratch.Cast.toNumber(args.NUMFIVE),Scratch.Cast.toNumber(args.NUMSIX),Scratch.Cast.toNumber(args.NUMSEVEN),Scratch.Cast.toNumber(args.NUMEIGHT)], args.OPERATION); }
    valueif(args) {
      let boolean = Scratch.Cast.toBoolean(args.BOOLEAN);
      if (boolean) {
        return args.VALUEIFTRUE;
      } else {
        return args.VALUEIFFALSE;
      }
    }
    randomchancepercent(args) {
      let chance = Scratch.Cast.toNumber(args.CHANCE) / 100;
      let rand = Math.random();
      return rand < chance;
    }
    randomchanceratio(args) {
      let chance = Scratch.Cast.toNumber(args.NUMERATOR) / Scratch.Cast.toNumber(args.DENOMINATOR);
      let rand = Math.random();
      return rand < chance;
    }
    randomvalue(args) {
      return Math.random();
    }
    userfriendlynumber(args) {
      let num = Scratch.Cast.toNumber(args.NUMBER);
      let format = args.FORMAT;
      let neg_sign = '';
      if (num < 0) {
        neg_sign = '-';
        num = Math.abs(num);
      }
      if (num === Infinity) {
        return neg_sign + 'Infinity';
      }

      num = Math.round(num*10000000)/10000000; // any more precision risks floating point errors


      let comma_formats = ['1,234,567.89 (truncated)','1,234,567.89012 (not truncated)','1,234,567.890 (always 3 decimals)','1,234,567.890120 (always 6 decimals)'];
      let whole_part_with_commas = null;
      if (comma_formats.includes(format) || (format == '1.23 million' && num < 1000000) || (format == '1.23m' && num < 1000)) {
      	whole_part_with_commas = '';
        let place_value = 1;
        let next_comma = 3;
        let digit = null;
        while (num >= place_value) {
          if (next_comma <= 0) {
          	next_comma = 3;
            whole_part_with_commas = ',' + whole_part_with_commas;
          }
          digit = mod(Math.floor(num / place_value), 10);
          whole_part_with_commas = digit + whole_part_with_commas;
          place_value *= 10;
          next_comma -= 1;
        }
        if (whole_part_with_commas == '') {
          whole_part_with_commas = '0';
        }
        whole_part_with_commas = neg_sign + whole_part_with_commas;
      }

      if (format == '1,234,567.89 (truncated)' || (format == '1.23 million' && num < 1000000) || (format == '1.23m' && num < 1000)) {
        let str = whole_part_with_commas;
        let decimal_part = Math.floor(Math.round(mod(num, 1) * 10000000) / 100000).toString();
        if (decimal_part > 0) {
          str += '.';
          if (decimal_part < 10) {
          	str += '0';
          }
          if (decimal_part.endsWith('0')) {
          	decimal_part = decimal_part.slice(0,-1);
          }
          str += decimal_part;
        }
        return str;
      } else if (format == '1,234,567.89012 (not truncated)') {
        let str = whole_part_with_commas;
        let place_value = 0.1;
        let decimal_part = '.';
        num = mod(num, 1);
        let digit = null;
        while (num > 0.00000001) {
          digit = mod(Math.floor(Math.round((num / place_value) * 10000000) / 10000000), 10);
          num -= digit * place_value;
          decimal_part += digit;
          place_value /= 10;
        } 
        if (decimal_part == '.') {
          decimal_part = '';
        }
        str += decimal_part;
        return str;
      } else if (format == '1.23 million' || format == '1.23m') {
        let illion_index = Math.floor(Math.log10(num) / 3) - 1;
        let illion = null;
        if (format == '1.23m') {
          illion = get_abbreviated_illion(illion_index);
        } else {
          illion = ' ' + get_illion(illion_index);
        }
        let number_part = num / (10 ** ((illion_index + 1) * 3));
        number_part = Math.floor(number_part * 100) / 100;
        return neg_sign + number_part.toString() + illion;
      } else if (format == '1,234,567.890 (always 3 decimals)' || format == '1,234,567.890120 (always 6 decimals)') {
        let digits = 3;
        if (format == '1,234,567.890120 (always 6 decimals)') {
          digits = 6;
        }

        let str = whole_part_with_commas;
        let place_value = 0.1;
        let decimal_part = '.';
        num = mod(num, 1);
        let digit = null;
        for (let i = 0; i < digits; i++) {
          digit = mod(Math.floor(Math.round((num / place_value) * 10000000) / 10000000), 10);
          decimal_part += digit;
          place_value /= 10;
        } 
        if (decimal_part == '.') {
          decimal_part = '';
        }
        str += decimal_part;
        return str;
      } else if (format == '1.23410') {
        if (num == 0) {
          return '0';
        }

        let power = Math.floor(Math.log10(num));

        let number_part = num / (10 ** power);
        number_part = Math.floor(number_part * 1000) / 1000;

        power = power.toString();
        let superscript_numbers = {'0':'','1':'','2':'','3':'','4':'','5':'','6':'','7':'','8':'','9':'','-':''};
        let superscript_power = '';
        for (let i = 0; i < power.length; i++) {
          superscript_power += superscript_numbers[power[i]];
        }
        return neg_sign + number_part.toString() + '10' + superscript_power;
      } else if (format == '1d 23h 45m 37s' || format == '01:23:45, 00:00:01' || format == '1:23:45, 0:01' || format == '01:23, 00:01') {
        let years = null;
        let days = null;
        if (format == '1d 23h 45m 37s') {
          years = Math.floor(num / (365 * 24 * 60 * 60));
          days = mod(Math.floor(num / (24 * 60 * 60)), 365);
        } else {
          years = 0;
          days = Math.floor(num / (24 * 60 * 60));
        }
        let hours = mod(Math.floor(num / (60 * 60)), 24);
        let minutes = mod(Math.floor(num / 60), 60);
        let seconds = mod(Math.floor(num), 60);

        let sections = [];
        if (format == '1d 23h 45m 37s') {
          if (years > 0) { sections.push(neg_sign + years + 'y'); }
          if (days > 0) { sections.push(neg_sign + days + 'd'); }
          if (hours > 0) { sections.push(neg_sign + hours + 'h'); }
          if (minutes > 0) { sections.push(neg_sign + minutes + 'm'); }
          if (seconds > 0) { sections.push(neg_sign + seconds + 's'); }
        } else if (format == '01:23:45, 00:00:01') {
          if (days > 0) { sections.push(days.toString()); }
          sections.push(hours.toString().padStart(2,'0'));
          sections.push(minutes.toString().padStart(2,'0'));
          sections.push(seconds.toString().padStart(2,'0'));
        } else if (format == '1:23:45, 0:01') {
          if (days > 0) { sections.push(days.toString()); }
          if (hours > 0 || sections.length > 0) { if (sections.length > 0) { sections.push(hours.toString().padStart(2,'0')); } else { sections.push(hours.toString()); } /* leading zero only if others come before */ }
          if (sections.length > 0) { sections.push(minutes.toString().padStart(2,'0')); } else { sections.push(minutes.toString()); } // leading zero only if others came before
          sections.push(seconds.toString().padStart(2,'0'));
        } else if (format == '01:23, 00:01') {
          if (days > 0) { sections.push(days.toString()); }
          if (hours > 0 || sections.length > 0) { if (sections.length > 0) { sections.push(hours.toString().padStart(2,'0')); } else { sections.push(hours.toString()); } /* leading zero only if others come before */ }
          sections.push(minutes.toString().padStart(2,'0'));
          sections.push(seconds.toString().padStart(2,'0'));
        }

        if (format == '1d 23h 45m 37s') {
          return sections.join(' ');
        }
        return neg_sign + sections.join(':');
      } else if (format == 'n\'th -illion number') {
        return neg_sign + get_illion(num);
      }

      return '0';
    }
  }

  // load extension
  Scratch.extensions.register(new SoupUtils());
})(Scratch);
